#__file: 'libcoloc/col_addDefault.F90' 0100644    **DO NOT DELETE**
subroutine col_adddefault(sid, t80, v80, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*80 :: t80        ! target name
  character*80 :: v80        ! value
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "adddefault"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid,varname
    call colocation_getSession(css,sid,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Error return from getSession.")
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
  call colocation_adddefault(css,t80,v80,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_stackclear.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_adddefault
#__file: 'libcoloc/col_clearDefaultStack.F90' 0100644    **DO NOT DELETE**
subroutine col_cleardefaultstack(sid, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearDefaultStack"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid,varname
    call colocation_getSession(css,sid,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Error return from getSession.")
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
  call colocation_cleardefaultstack(css,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_stackclear.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_cleardefaultstack
#__file: 'libcoloc/col_clearMatch.F90' 0100644    **DO NOT DELETE**
subroutine col_clearmatch(sid, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearmatch"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid,varname
  call colocation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_clearmatch(css,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_stackclear.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_clearmatch
#__file: 'libcoloc/col_clearMatchStack.F90' 0100644    **DO NOT DELETE**
subroutine col_clearmatchstack(sid, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearMatchStack"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid,varname
    call colocation_getSession(css,sid,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Error return from getSession.")
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
  call colocation_clearmatchstack(css,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_stackclear.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_clearmatchstack
#__file: 'libcoloc/col_closeSession.F90' 0100644    **DO NOT DELETE**
subroutine col_closesession(sid, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "col_closesession"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call colocation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_closesession(css,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_closeSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.'
  return
end subroutine col_closeSession
#__file: 'libcoloc/col_expression.F90' 0100644    **DO NOT DELETE**
subroutine col_expression(expr250, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*250 :: expr250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "expression"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,expr250
  call colocation_expression(expr250,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_expression.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_expression
#__file: 'libcoloc/col_getXMLFile.F90' 0100644    **DO NOT DELETE**
subroutine col_getxmlfile(cid, xml250, crc250, irc)
  use colocation
  implicit none
  integer :: cid             ! session id
  character*250 :: xml250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "getXMLfile"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,xml250
  !
  call colocation_getSession(css,cid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_getxmlfile(css,xml250,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from col_getxmlfile.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_getxmlfile
#__file: 'libcoloc/col_makeMatchList.F90' 0100644    **DO NOT DELETE**
subroutine col_makeMatchList(sid, mid, crc250, irc)
  use colocation
  use model
  implicit none
  integer :: sid             ! session id
  integer :: mid             ! model session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "makematchlist"
  type(col_session), pointer :: css !  current session
  type(mod_session), pointer :: mss !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call colocation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call model_getSession(mss,mid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_makematchlist(css,mss,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_makematchlist.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_makeMatchList
#__file: 'libcoloc/col_makeXML.F90' 0100644    **DO NOT DELETE**
subroutine col_makexml(cid,mid,oid,xml250,test,fill250,crc250, irc)
  use model
  use observations
  use colocation
  implicit none
  integer :: cid ! coloc session id
  integer :: mid ! model session id
  integer :: oid ! observation session id
  character*250 :: xml250
  integer :: test
  character*250 :: fill250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "col_makexml"
  type(col_session), pointer ::  css !  current session
  type(mod_session), pointer ::  mss !  current session
  type(obs_session), pointer ::  oss !  current session
  if (col_bdeb)write(*,*)myname,'Entering.',irc,test
  ! get session objects
  call model_getSession(mss,mid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from mod_getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call observation_getSession(oss,oid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from obs_getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_getSession(css,cid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !
  call  colocation_makexml(css,mss,oss,xml250,test,fill250,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_makexml.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  return
end subroutine col_makexml
#__file: 'libcoloc/colocation.F90' 0100644    **DO NOT DELETE**
module colocation
  use parse
  IMPLICIT NONE
  !
  ! Global constants
  !
  logical     :: col_bdeb=.false.
  !
  ! default values for the model targets
  !
  type :: col_default
     character*80 :: n80   ! name
     integer :: lenn       ! name length
     character*80 :: v80   ! value
     integer :: lenv       ! value length
     real :: val           ! value
     type(col_default), pointer :: prev => null()   ! linked list
     type(col_default), pointer :: next => null()   ! linked list
  end type col_default
  !
  type :: col_location
     integer :: cTrg = 0
     integer :: cii = 0
     character*80, pointer :: v80(:)  => null()      ! value string
     integer, pointer      :: vlen(:) => null()      ! value length
     real, pointer         :: val(:)  => null()      ! value
     logical, pointer      :: vset(:) => null()      ! is value set?
     type(col_default), pointer  :: cDef => null()    ! linked list start
     type(col_default), pointer  :: firstDef => null()! linked list start
     type(col_default), pointer  :: lastDef => null() ! linked list end
     type(col_location), pointer :: prev => null()    ! linked list
     type(col_location), pointer :: next => null()    ! linked list
  end type col_location
  !
  ! match rules for model targets and observation targets
  !
  type :: col_match
     character*80 :: n80     ! name
     character*250 :: e250   ! obs expression
     integer :: itrg=0      ! index to model target array position
     character*80 :: min80     ! lower limit
     character*80 :: max80     ! upper limit
     type(col_match), pointer :: prev => null()   ! linked list
     type(col_match), pointer :: next => null()   ! linked list
  end type col_match
  !
  ! SESSION VARIABLES
  !
  type :: col_session
     integer       :: sid            ! session id...
     character*250 :: obs250=""      ! observation cache file
     integer ::  leno = 0
     character*250 :: mod250=""      ! model cache file
     integer ::  lenm = 0
     character*250 :: xml250 =""     ! xml output file...
     integer :: lenx =0
     !
     ! imported model targets
     integer :: ctrg = 0 ! targets                  ! number of targets allocated
     character*80, pointer :: trg80(:) => null()    ! list of target names
     integer, pointer      :: trg_lent(:) => null() ! list of target name length
     integer, pointer      :: trg_def(:) => null()  ! is target set by default?
     !
     ! default locations
     type(col_location), pointer :: firstLoc => null()   ! linked list start
     type(col_location), pointer :: lastLoc => null()    ! linked list end
     type(col_location), pointer :: currentLoc => null() ! current location input variable
     type(col_location), pointer :: cLoc => null()       ! current location loop variable
     integer :: nLoc=0                                  ! number of items in target-chain
     !
     ! match rules
     type(col_match), pointer :: firstMatch => null()   ! linked list start
     type(col_match), pointer :: lastMatch => null()    ! linked list end
     type(col_match), pointer :: currentMatch => null() ! current match loop
     integer :: nmatch=0                                ! number of items in match-chain
     integer :: cMatch = 0                              ! number of allocated matches
     character*80, pointer :: mat_n80(:)                ! name
     integer, pointer      :: mat_lenn(:)               ! length of name
     character*250, pointer:: mat_e250(:)               ! match expression
     integer, pointer      :: mat_lene(:)               ! length of match expression
     integer, pointer      :: mat_2trg(:)                ! index to model target
     character*80, pointer :: mat_min80(:)                ! lower limit
     character*80, pointer :: mat_max80(:)                ! upper limit
     type(parse_pointer), pointer  :: mat_psp(:) => null()  ! match expression parser
     real, pointer         :: mat_val(:)                ! match value
     integer :: cii                                     ! loop index
     !
     ! all variables used by filter...
     integer ::               nall=0                    ! number of variables
     integer ::               nmod=0                    ! number of model targets
     integer ::               nobs=0                    ! number of obs targets
     integer ::               nind=0                    ! number of index variables
     character*80, pointer :: all_var(:)                ! all variables
     character*80, pointer :: all_lenv(:)               ! length of variable
     real, pointer         :: all_val(:)                ! all values
     !
     ! time information
     !  VALUES(1):	The year
     !  VALUES(2):	The month
     !	VALUES(3):	The day of the month
     !	VALUES(4):	Time difference with UTC in minutes
     !	VALUES(5):	The hour of the day
     !	VALUES(6):	The minutes of the hour
     !	VALUES(7):	The seconds of the minute
     !	VALUES(8):	The milliseconds of the second
     integer :: values(8)
     !
     type(col_session), pointer :: prev => null()         ! linked list
     type(col_session), pointer :: next => null()         ! linked list
  end type col_session
  !
  integer :: maxid=0 ! session counter
  type(col_session), pointer :: firstSession => null()   ! linked list start
  type(col_session), pointer :: lastSession => null()    ! linked list end
  !
CONTAINS
  !
  !###############################################################################
  ! SESSION ROUTINES
  !###############################################################################
  !
  subroutine colocation_opensession(sid,css,crc250,irc)
    implicit none
    integer :: sid
    type(col_session),pointer :: css  !  new session
    character*250 :: crc250
    integer :: irc
    character*26 :: myname="colocation_openSession"
    if (.not.associated(firstSession)) then
       allocate(firstSession, lastSession,stat=irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250,"Unable to allocate 'firstSession/lastSession'.")
          call colocation_errorappend(crc250,"\n")
          return
       end if
       firstSession%next => lastSession
       lastSession%prev => firstSession
    end if
    nullify(css)
    allocate(css,stat=irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250,"Unable to allocate 'new session'.")
       call colocation_errorappend(crc250,"\n")
       return
    end if
    !
    allocate(css%firstLoc,css%lastLoc, stat=irc) ! 
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250,"Unable to allocate &
            & 'css%firstLoc/css%lastLoc'.")
       call colocation_errorappend(crc250,"\n")
       return
    end if
    css%firstLoc%next => css%lastLoc
    css%lastLoc%prev => css%firstLoc
    !
    allocate(css%firstMatch,css%lastMatch, stat=irc) ! 
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250,"Unable to allocate &
            & 'css%firstMatch/css%lastMatch'.")
       call colocation_errorappend(crc250,"\n")
       return
    end if
    css%firstMatch%next => css%lastMatch
    css%lastMatch%prev => css%firstMatch
    css%nmatch=0
    !
    maxid=maxid+1
    css%sid=maxid
    css%prev => lastSession%prev
    css%next => lastSession
    css%prev%next => css
    css%next%prev => css
    sid = css%sid
    return
  end subroutine colocation_opensession

  subroutine colocation_getSession(css,sid,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    integer :: sid
    character*250 :: crc250
    integer :: irc
    character*26 :: myname="colocation_getSession"
    if (.not.associated(firstSession)) then
       irc=911
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250,"No session is opened!")
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
    css => firstSession%next
    do while ( .not.associated(css,target=lastSession))
       if (css%sid .eq. sid) then
          !if (col_bdeb) write(*,*)myname,'Exiting with sid:',sid,irc
          return
       end if
       css=>css%next
    end do
    nullify(css)
    irc=342
    call colocation_errorappend(crc250,myname)
    call colocation_errorappend(crc250,"Invalid session id:")
    call colocation_errorappendi(crc250,sid)
    call colocation_errorappend(crc250,"\n")
    return
  end subroutine colocation_getSession

  subroutine colocation_closeSession(css,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="colocation_closeSession"
    if(col_bdeb)write(*,*)myname,'Entering.',irc
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       call colocation_removeSession(css,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Error return from removeSession.")
          call colocation_errorappendi(crc250,irc)
          call colocation_errorappend(crc250,"\n")
          return
       end if
    else
       irc=599
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250,"Attempt to close none-existent session.")
       call colocation_errorappend(crc250,"\n")
       return
    end if
    if(col_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine colocation_closeSession

  subroutine colocation_removeSession(css,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="colocation_removeSession"
    type(col_location), pointer :: cLoc, nLoc
    type(col_match), pointer :: currmatch, nextmatch
    integer :: ii
    !
    if(col_bdeb)write(*,*)myname,'Removing default stack.'
    ! remove default stack
    nullify(css%currentLoc)
    if (associated(css%firstLoc)) then
       cLoc => css%firstLoc%next
       do while (.not.associated(cLoc,target=css%lastLoc))
          nLoc => cLoc%next
          call colocation_deleteDef(css,cLoc,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from deleteDef.")
             call colocation_errorappendi(crc250,irc)
             call colocation_errorappend(crc250,"\n")
             return
          end if
          deallocate(cLoc)
          cLoc  => nLoc
       end do
       if (associated(css%firstLoc)) deallocate(css%firstLoc)
       if (associated(css%lastLoc)) deallocate(css%lastLoc)
    end if
    !
    if(col_bdeb)write(*,*)myname,'Removing match stack.'
    ! remove match stack
    if (associated(css%firstMatch)) then
       currmatch => css%firstMatch%next
       do while (.not.associated(currmatch,target=css%lastMatch))
          nextmatch => currmatch%next
          call colocation_deleteMatch(css,currmatch,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from deleteMatch.")
             call colocation_errorappendi(crc250,irc)
             call colocation_errorappend(crc250,"\n")
             return
          end if
          currmatch  => nextmatch
       end do
       deallocate(css%firstMatch,css%lastMatch)
       nullify(css%currentMatch)
    end if
    !
    if (associated(css%trg80)) deallocate(css%trg80)
    if (associated(css%trg_lent)) deallocate(css%trg_lent)
    !
    css%prev%next => css%next
    css%next%prev => css%prev
    deallocate(css)
    if(col_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine colocation_removeSession 
  !
  !
  !###############################################################################
  ! TARGET ROUTINES
  !###############################################################################
  !
  subroutine colocation_importTargets(css,mss,crc250,irc)
    use model
    implicit none
    type(col_session), pointer :: css !  current session
    type(mod_session), pointer :: mss !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="colocation_importTargets"
    integer :: ii
    if(col_bdeb)write(*,*) myname,'Entering:',css%ctrg,mss%ctrg
    if(associated(css%trg80)) deallocate(css%trg80)
    if(associated(css%trg_lent)) deallocate(css%trg_lent)
    css%ctrg=mss%ctrg
    if (css%ctrg.ne.0) then
       allocate(css%trg80(css%ctrg), css%trg_lent(css%ctrg),stat=irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250,"Unable to allocate 'trg80'.")
          call colocation_errorappendi(crc250,css%ctrg)
          call colocation_errorappend(crc250,"\n")
          return
       end if
       do ii=1,mss%ctrg
          css%trg80(ii)=mss%trg80(ii)
          css%trg_lent(ii)=mss%trg_lent(ii)
       end do
    end if
    return
  end subroutine colocation_importTargets
  !
  !
  !###############################################################################
  ! DEFAULT ROUTINES
  !###############################################################################
  ! clear the default stack
  !
  subroutine colocation_cleardefaultstack(css,crc250,irc) 
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(col_location), pointer :: currentLoc !  the current default target
    type(col_location), pointer :: nextDef !  the next default target
    character*25 :: myname="colocation_cleardefaultstack"
    if(col_bdeb)write(*,*)myname,' Entering.',irc,associated(css%firstLoc)
    if (associated(css%firstLoc)) then
       currentLoc => css%firstLoc%next
       do while (.not.associated(currentLoc,target=css%lastLoc))
          nextDef => currentLoc%next
          currentLoc%prev%next =>  currentLoc%next
          currentLoc%next%prev =>  currentLoc%prev
          if (associated(currentLoc%vset)) deallocate(currentLoc%vset)
          if (associated(currentLoc%v80)) deallocate(currentLoc%v80)
          if (associated(currentLoc%vlen)) deallocate(currentLoc%vlen)
          if (associated(currentLoc%val)) deallocate(currentLoc%val)
          deallocate(currentLoc,stat=irc)
          css%nLoc=css%nLoc-1
          currentLoc => nextDef 
      end do
    else
       allocate(css%firstLoc,css%lastLoc, stat=irc) ! 
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250,"Unable to allocate &
               & 'css%firstLoc/css%lastLoc'.")
          call colocation_errorappend(crc250,"\n")
          return
       end if
       css%firstLoc%next => css%lastLoc
       css%lastLoc%prev => css%firstLoc
    end if
    if(col_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine colocation_cleardefaultstack
  !
  ! push default values to the stack
  !
  subroutine colocation_pushDefault(css,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(col_location), pointer :: newLoc
    character*25 :: myname="colocation_pushDefault"
    if(col_bdeb)write(*,*)myname,'Entering.',irc
    if (.not.associated(css%firstLoc)) then
       allocate(css%firstLoc,css%lastLoc, stat=irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250,"Unable to allocate 'firstDef/lastDef'.")
          call colocation_errorappend(crc250,"\n")
          return
       end if
       css%firstLoc%next => css%lastLoc
       css%lastLoc%prev => css%firstLoc
       css%nLoc=0
    end if
    if (associated(css%currentLoc)) then
       nullify(css%currentLoc)    ! signal for new location next time
    end if
    if(col_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine colocation_pushDefault
  !
  logical function colocation_loopLocation(css,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_loopLocation"
    if(col_bdeb) write(*,*)myname,' Entering.',associated(css%cLoc)
    colocation_loopLocation=.false. ! only true if all is ok...
    if (.not.associated(css%cLoc)) then
       css%cLoc =>  css%firstLoc%next 
    else
       if (associated(css%cloc,target=css%cLoc%next)) then
          if(col_bdeb) write(*,*)myname,' System error:Self-linking found.'
          irc=998
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250,"System error: Self-linking found.")
          call colocation_errorappend(crc250,"\n")
          return
       end if
       css%cLoc =>  css%cLoc%next
    end if
    if (associated(css%cLoc,target=css%lastLoc)) then
       nullify(css%cLoc)
       if(col_bdeb) write(*,*)myname,' Last location.'
       colocation_loopLocation=.false.
    else
       colocation_loopLocation=.true.
    end if
    if(col_bdeb) write(*,*)myname,' Done.',colocation_loopLocation
    return
  end function colocation_loopLocation
  !
  logical function colocation_loopDefault(css,n80,v80,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*80  :: n80       ! target name
    character*80  :: v80       ! variable
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_loopDefault"
    if(col_bdeb)write(*,*)myname,' Entering.',associated(css%cLoc%cDef)
    colocation_loopDefault=.false. ! only true if all is ok...
    if (.not.associated(css%cLoc%cDef)) then
       css%cLoc%cDef =>  css%cLoc%firstDef%next 
    else
       css%cLoc%cDef =>  css%cLoc%cDef%next
    end if
    if (associated(css%cLoc%cDef,target=css%cLoc%lastDef)) then
       nullify(css%cLoc%cDef)
       if(col_bdeb) write(*,*)myname,' Last location.'
       colocation_loopDefault=.false.
    else
       n80=css%cLoc%cDef%n80
       v80=css%cLoc%cDef%v80
       if(col_bdeb) write(*,*)myname," Default:'"//css%cLoc%cDef%n80(1:css%cLoc%cDef%lenn)//"'"
       colocation_loopDefault=.true.
    end if
    if(col_bdeb) write(*,*)myname,' Done.',colocation_loopDefault
    return
  end function colocation_loopDefault
  !
  ! add default element
  !
  subroutine colocation_addDefault(css,n80,v80,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*80 :: n80 ! target name
    character*80 :: v80 ! target value
    character*250 :: crc250
    integer :: irc
    integer :: ii, irc2, lenv, lenn
    type(col_default),pointer :: newdef
    integer, external :: length
    character*25 :: myname="colocation_addDefault"
    if(col_bdeb)write(*,*)myname,'Entering.',associated(css%currentLoc),irc
    allocate(newdef,stat=irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250,"Unable to allocate 'newdef'.")
       call colocation_errorappend(crc250,"\n")
       return
    end if
    newdef%n80=n80
    call chop0(newdef%n80,80)
    newdef%lenn=length(newdef%n80,80,10)
    newdef%v80=v80
    call chop0(newdef%v80,80)
    newdef%lenv=length(newdef%v80,80,10)
    if(col_bdeb)write(*,*)myname," Assigning: '"//newdef%n80(1:newdef%lenn)//&
         & "' -> '"//newdef%v80(1:newdef%lenv)//"'"
    if (.not.associated(css%currentLoc)) then
       if(col_bdeb)write(*,*)myname,'New Default.'
       allocate(css%currentLoc, stat=irc)
       css%currentLoc%next => css%lastLoc
       css%currentLoc%prev => css%lastLoc%prev
       css%currentLoc%next%prev => css%currentLoc
       css%currentLoc%prev%next => css%currentLoc
       allocate(css%currentLoc%firstDef,css%currentLoc%lastDef, stat=irc) ! 
       css%currentLoc%firstDef%next => css%currentLoc%lastDef
       css%currentLoc%lastDef%prev => css%currentLoc%firstDef
       css%nLoc=css%nLoc+1
    end if
    if(col_bdeb)write(*,*)myname,'Adding default.'
    newdef%next => css%currentLoc%lastDef
    newdef%prev => css%currentLoc%lastDef%prev
    css%currentLoc%lastDef%prev%next => newdef
    css%currentLoc%lastDef%prev => newdef
    if(col_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine colocation_addDefault
  !
  ! retrieve next default values
  !
  subroutine colocation_getdefault(css,nvar,var,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    integer :: nvar
    real, allocatable :: var(:)
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="colocation_getdefault"
    integer :: ii
    integer, external :: length
    if (nvar.ne.css%ctrg.and.allocated(var)) deallocate(var)
    if (.not.allocated(var)) then
       allocate(var(css%ctrg),stat=irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Unable to allocate var.")
          call colocation_errorappendi(crc250,css%ctrg)
          return
       end if
    end if
    if (.not.associated(css%currentLoc)) then
       css%currentLoc => css%firstLoc%next
    end if
    if (.not.associated(css%currentLoc,target=css%lastLoc)) then
       nvar=css%ctrg
       do ii=1,css%ctrg
          var(ii)=css%currentLoc%val(ii)
       end do
       css%currentLoc => css%currentLoc%next
    else
       nvar=0
    end if
    return
  end subroutine colocation_getdefault
  !
  ! delete default from stack
  !
  subroutine colocation_deleteDef (css,cLoc, crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    type(col_location), pointer :: cLoc
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    character*25 :: myname="colocation_deleteDef"
    type(col_default), pointer :: cdef,ndef
    if(col_bdeb)write(*,*)myname,' Entering.',associated(cLoc)
    if (associated(cLoc)) then
       cdef=>cLoc%firstdef%next
       do while (.not.associated(cdef,target=cLoc%lastDef))
          ndef=>cdef%next
          deallocate(cdef)
          cdef=>ndef
       end do
       if (associated(cLoc%firstdef)) deallocate(cLoc%firstdef)
       if (associated(cLoc%lastdef)) deallocate(cLoc%lastdef)
       css%nLoc = css%nLoc - 1
       if (associated(cLoc%vset)) deallocate(cLoc%vset)
       if (associated(cLoc%v80)) deallocate(cLoc%v80)
       if (associated(cLoc%vlen)) deallocate(cLoc%vlen)
       if (associated(cLoc%val)) deallocate(cLoc%val)
       !cLoc%next%prev => cLoc%prev
       !cLoc%prev%next => cLoc%next
       !deallocate(cLoc)
    end if
    if(col_bdeb)write(*,*)myname,' Done.',associated(cLoc)
    return
  end subroutine colocation_deleteDef
  !
  ! default locations
  !
  integer function colocation_defaultCount(css,crc250,irc)
    implicit none
    type(col_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_defaultCount "
    colocation_defaultCount=css%nLoc
    return
  end function colocation_defaultCount
  !
  !
  !###############################################################################
  ! MATCH ROUTINES
  !###############################################################################
  ! clear the match stack
  !
  subroutine colocation_clearmatchstack(css,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(col_match), pointer :: curmatch => null() !  current match
    type(col_match), pointer :: nextmatch => null() !  next match session
    character*28 :: myname="colocation_clearmatchstack"
    if(col_bdeb)write(*,*)myname,'Entering.',irc
    curmatch => css%firstMatch%next
    do while (.not.associated(curmatch,target=css%lastMatch))
       nextmatch => curmatch%next
       call colocation_unlinkMatch(curmatch)
       call colocation_deallocateMatch(curmatch)
       css%nmatch=css%nmatch-1
       curmatch => nextmatch
    end do
    if(col_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine colocation_clearmatchstack
  !
  subroutine colocation_unlinkMatch(match)
    implicit none
    type(col_match), pointer :: match !  current target
    match%prev%next => match%next
    match%next%prev => match%prev
    return
  end subroutine colocation_unlinkMatch
  !
  subroutine colocation_deallocateMatch(match)
    implicit none
    type(col_match), pointer :: match !  current target
    integer :: irc2
    deallocate(match,stat=irc2) ! ignore any errors
    return
  end subroutine colocation_deallocateMatch
  !
  !
  ! add match to current
  !
  subroutine colocation_makeMatchList(css,mss,crc250,irc)
    use model
    use parse
    implicit none
    type(col_session), pointer :: css !  current session
    type(mod_session), pointer :: mss !  model session
    character*80 :: n80
    character*250 :: e250
    character*80 :: min80
    character*80 :: max80
    character*250 :: crc250
    integer :: irc
    type(col_match), pointer :: match
    integer :: ii, irc2, lenv, lenn,lene
    integer, external :: length
    type(col_default), pointer :: cdef
    type(col_location), pointer :: cloc
    logical :: first
    character*25 :: myname="colocation_makeMatchList"
    if(col_bdeb)write(*,*)myname,'Entering.',irc
    if (mss%ctrg.eq.0) then
       if (col_bdeb) write(*,*)myname,'No model targets defined:',mss%ctrg
       irc=347
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," No targets defined!")
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
    !
    ! process defaults. If default is set, match is also re-set
    !
    first=.true.
    cLoc=>css%firstLoc%next
    do while (.not.associated(cLoc,target=css%lastLoc))
       if (css%ctrg.eq.0) then
          irc=147
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," No targets defined!")
          call colocation_errorappendi(crc250,irc)
          call colocation_errorappend(crc250,"\n")
          return
       end if
       cLoc%cTrg=css%ctrg
       if(col_bdeb)write(*,*)myname,'Allocating location-list:',cLoc%cTrg
       allocate(cLoc%vset(cLoc%cTrg), cLoc%v80(cLoc%cTrg), &
            & cLoc%vlen(cLoc%cTrg),  cLoc%val(cLoc%cTrg), stat=irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250,"Unable to allocate 'session: current Default'.")
          call colocation_errorappend(crc250,"\n")
          return
       end if
       if (first) then ! use match from defaults
          call colocation_clearmatchstack(css,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from clearMatchStack")
             call colocation_errorappend(crc250,"\n")
             return
          end if
          e250=""
          min80=""
          max80=""
          call chop0(e250,250)
          call chop0(min80,80)
          call chop0(max80,80)
       end if
       do ii=1,css%cTrg
          cLoc%vset(ii)=.false.
          cLoc%val(ii)=0.0D0
       end do
       cdef=>cLoc%firstDef%next
       do while (.not.associated(cdef,target=cLoc%lastDef))
          call chop0(cdef%n80,80)
          cdef%lenn=length(cdef%n80,80,10)
          ii=1
          LOOPD:do while (ii.le.css%ctrg)
             if (css%trg80(ii)(1:css%trg_lent(ii)).eq.cdef%n80(1:cdef%lenn)) exit LOOPD
             ii=ii+1
          end do LOOPD
          if (ii.le.css%ctrg) then
             if(col_bdeb)write(*,*)myname,'Found target:',ii,', slice=',cdef%n80(1:cdef%lenn)
             cLoc%vset(ii)=.true.
             call chop0(cdef%v80,80)
             cdef%lenv=length(cdef%v80,80,10)
             cLoc%v80(ii)=cdef%v80 ! value
             cLoc%vlen(ii)=cdef%lenv
             read(cdef%v80(1:cdef%lenv),*,iostat=irc2) cLoc%val(ii)
             if (first) then ! Use match from defaults
                call colocation_pushmatch(css,cdef%n80,e250,min80,max80,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,myname)
                   call colocation_errorappend(crc250," Error return from pushMatch")
                   call colocation_errorappend(crc250,"\n")
                   return
                end if
             end if
          else
             irc=220
             if(col_bdeb)then
                write(*,*)myname," Missing Match: ",ii,"'"//cdef%n80(1:cdef%lenn)//"'",cdef%lenn
                write(*,*)myname,' Targets:',cLoc%cTrg,css%ctrg
                do ii=1,css%ctrg
                   write(*,*)myname,' Target:',ii,&
                        & "'"//css%trg80(ii)(1:css%trg_lent(ii))//"'",css%trg_lent(ii)
                end do
             end if
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250,"Model target not found:"//n80(1:lenn))
             return
          end if
          cdef=>cdef%next
       end do
       first=.false.
       if(col_bdeb)write(*,*)myname,'Allocated location-list:',&
            & cLoc%cTrg,(cLoc%val(ii),ii=1,cLoc%cTrg),(cLoc%vset(ii),ii=1,cLoc%cTrg)
       cLoc=>cLoc%next
    end do
    !
    ! sanity check
    !
    if (col_bdeb) then
       cLoc=>css%firstLoc%next
       do while (.not.associated(cLoc,target=css%lastLoc))
          if(col_bdeb)write(*,*)myname,'Location targets:',cLoc%cTrg,size(cLoc%vset)
          cLoc=>cLoc%next
       end do
    end if
    !
    ! clean up
    !
    if (css%cMatch .ne.  0) then
       do ii=1,css%cMatch
          call parse_close(css%mat_psp(ii)%ptr,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from parse_close.")
             return
          end if
       end do
       if(associated(css%mat_n80)) deallocate(css%mat_n80)
       if(associated(css%mat_lenn)) deallocate(css%mat_lenn)
       if(associated(css%mat_e250)) deallocate(css%mat_e250)
       if(associated(css%mat_lene)) deallocate(css%mat_lene)
       if(associated(css%mat_2trg)) deallocate(css%mat_2trg)
       if(associated(css%mat_min80)) deallocate(css%mat_min80)
       if(associated(css%mat_max80)) deallocate(css%mat_max80)
       css%cMatch = 0
    end if
    ! allocate match-list if we have target-list
    if (col_bdeb) write(*,*)myname," Looping over matches: ",css%nmatch,mss%ctrg
    if (mss%ctrg .ne.  0) then
       css%cMatch=0
       do while (colocation_loopMatch(css,n80,e250,min80,max80,crc250,irc))
          ! find index in model target array
          lenn=length(n80,80,10)
          if (col_bdeb) write(*,*)myname," Matching: '"//n80(1:lenn)//"'",lenn,mss%ctrg
          if (lenn.ne.0) then
             ii=1
             LOOPM:do while (ii.le.mss%ctrg)
                if (mss%trg80(ii)(1:mss%trg_lent(ii)).eq.n80(1:lenn)) exit LOOPM
                ii=ii+1
             end do LOOPM
          else
             ii=css%ctrg+1
          end if
          if (ii.le.css%ctrg) then
             css%currentMatch%itrg=ii
             css%cMatch=css%cMatch+1
             if (col_bdeb) write(*,*)myname," Found match: '"//n80(1:lenn)//"'",lenn,ii
          else
             if (col_bdeb) then
                write(*,*)myname," No match:    '"//n80(1:lenn)//"'",lenn,ii
                do ii=1,mss%ctrg
                   write(*,*)myname,' Target:',ii,&
                        & "'"//mss%trg80(ii)(1:mss%trg_lent(ii))//"'",mss%trg_lent(ii)
                end do
             end if
             css%currentMatch%itrg=0
          end if
       end do
       if (col_bdeb) write(*,*)myname,'Allocating Match-lists: ',css%cMatch
       allocate(css%mat_n80(max(1,css%cMatch)), &
            & css%mat_lenn(max(1,css%cMatch)), &
            & css%mat_e250(max(1,css%cMatch)), &
            & css%mat_lene(max(1,css%cMatch)), &
            & css%mat_2trg(max(1,css%cMatch)), &
            & css%mat_min80(max(1,css%cMatch)),  &
            & css%mat_max80(max(1,css%cMatch)), &
            & css%mat_val(max(1,css%cMatch)), &
            & css%mat_psp(max(1,css%cMatch)), stat=irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250,"Unable to allocate 'session:Match'.")
          call colocation_errorappend(crc250,"\n")
          return
       end if
       do ii=1,css%cMatch
          css%mat_lenn(ii)=0
          css%mat_lene(ii)=0
          css%mat_2trg(ii)=0
          css%mat_val(ii)=0.0D0
       end do
       ! loop over matches and find corresponding targets...
       css%cMatch=0
       do while (colocation_loopMatch(css,n80,e250,min80,max80,crc250,irc))
          ii=css%currentMatch%itrg
          if (ii.ne.0) then
             css%cMatch=css%cMatch+1
             lenn=length(n80,80,10)
             lene=length(e250,250,10)
             css%mat_n80(css%cMatch)=n80
             css%mat_lenn(css%cMatch)=lenn
             css%mat_e250(css%cMatch)=e250
             css%mat_lene(css%cMatch)=lene
             css%mat_2trg(css%cMatch)=css%currentMatch%itrg
             if(col_bdeb)write(*,*)myname,"Match: '"//&
                  & css%mat_n80(css%cMatch)(1:css%mat_lenn(css%cMatch))//"' -> '"//&
                  & css%mat_e250(css%cMatch)(1:css%mat_lene(css%cMatch))//"'",ii
             css%mat_min80(css%cMatch)=min80
             css%mat_max80(css%cMatch)=max80
             css%mat_val(css%cMatch)=0.0D0
             call parse_open(css%mat_psp(css%cMatch)%ptr,crc250,irc)
             if (irc.ne.0) then
                call colocation_errorappend(crc250,myname)
                call colocation_errorappend(crc250," Error return from parse_open.")
                return
             end if
          else
             irc=221
             write(*,*)myname,'Targets:',css%ctrg
             do ii=1,css%ctrg
                write(*,*)myname,'Target:',ii,css%trg80(ii)(1:css%trg_lent(ii))
             end do
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250,"Target not found:"//n80(1:lenn))
             return
          end if
       end do
    else if (css%nMatch.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250,"No targets found.")
       call colocation_errorappend(crc250,"\n")
       return
    end if
    ! tell model which targetvalues are set by the match rules.... 
    call  model_setTarget(mss,css%cmatch,css%mat_2trg,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"model_setTarget")
       return
    end if
    if(col_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine colocation_makeMatchList
  !
  ! push current match to the stack
  !
  subroutine colocation_pushmatch(css,n80,e250,min80,max80,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*80 :: n80      ! target name
    character*250 :: e250    ! position/sequence number
    character*80 :: min80      ! lower
    character*80 :: max80      ! upper
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_pushmatch"
    type(col_match), pointer :: match !  current target
    integer :: lenn,lene
    integer,external :: length
    lenn=length(n80,80,10)
    lene=length(e250,250,10)
    if (lenn.ne.0) then
       allocate(match,stat=irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250,"Unable to allocate 'match'.")
       end if
       match%n80=n80
       match%e250=e250
       match%min80=min80
       match%max80=max80
       match%next => css%lastMatch
       match%prev => css%lastMatch%prev
       match%prev%next => match
       match%next%prev => match
       nullify(match)
       css%nmatch=css%nmatch+1
    end if
    if(col_bdeb)write(*,*)myname,"Adding: '"//n80(1:lenn)&
         & //"' <-> '"//e250(1:lene)//"'",css%nmatch
    return
  end subroutine colocation_pushmatch
  !
  logical function colocation_loopMatch(css,n80,e250,min80,max80,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*80  :: n80       ! target name
    character*250  :: e250       ! variable
    character*80  :: min80      ! min value
    character*80  :: max80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_loopMatch"
    if (col_bdeb) write(*,*)myname," Entering.",associated(css%currentMatch),css%nMatch
    colocation_loopmatch=.false. ! only true if all is ok...
    if (.not.associated(css%currentMatch)) then
       css%currentMatch =>  css%firstMatch%next 
    else
       css%currentMatch =>  css%currentMatch%next
    end if
    if (associated(css%currentMatch,target=css%lastMatch)) then
       nullify(css%currentMatch)
       colocation_loopMatch=.false.
    else
       n80=css%currentMatch%n80
       e250=css%currentMatch%e250
       min80=css%currentMatch%min80
       max80=css%currentMatch%max80
       colocation_loopmatch=.true.
    end if
    if (col_bdeb) write(*,*)myname," Done.",associated(css%currentMatch),colocation_loopmatch
    return
  end function colocation_loopMatch
  !
  logical function colocation_loopMatchList(css,n80,e250,min80,max80,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*80 :: n80
    character*250 :: e250
    character*80 :: min80
    character*80 :: max80
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_loopmatchlist"
    if (col_bdeb) write(*,*)myname,'Entering.',irc
    colocation_loopmatchlist=.false. ! only true if all is ok...
    if (.not.associated(css)) return ! no data
    if (css%cii.eq.0) then
       css%cii = 1
    else
       css%cii = css%cii + 1
    end if
    if (css%cii.gt.css%cMatch) then
       css%cii = 0
       colocation_loopmatchlist=.false.
    else
       n80=css%mat_n80(css%cii)
       e250=css%mat_e250(css%cii)
       min80=css%mat_min80(css%cii)
       max80=css%mat_max80(css%cii)
       colocation_loopmatchlist=.true.
    end if
    if (col_bdeb) write(*,*)myname,'Exiting.',irc
    return
  end function colocation_loopmatchlist
  !
  ! delete match rule from stack
  !
  subroutine colocation_deleteMatch (css,match, crc250,irc)
    use parse
    implicit none
    type(col_session), pointer :: css !  current session
    type(col_match), pointer :: match
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    character*25 :: myname="colocation_deleteMatch"
    integer :: ii
    if (associated(match)) then
       css%nmatch = css%nmatch - 1
       match%next%prev => match%prev
       match%prev%next => match%next
       call colocation_deallocateMatch(match)
    end if
    return
  end subroutine colocation_deleteMatch
  !
  ! get number of matchs
  !
  integer function colocation_matchCount(css,crc250,irc)
    implicit none
    type(col_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_matchCount "
    colocation_matchCount=css%nMatch
    return
  end function colocation_matchCount
  !
  ! compile match
  !
  subroutine colocation_compileMatch(css,oss,crc250,irc)
    use observations
    use parse
    implicit none
    type(col_session), pointer :: css !  current session
    type(obs_session), pointer :: oss !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="colocation_compileMatch"
    integer :: lene
    integer :: ii,jj ! match number
    if(col_bdeb)write(*,*)myname,'Entering.',size(oss%trg80),css%cmatch
    if (css%cmatch.ne.0) then
       do ii=1,css%cmatch
          if(col_bdeb)then
             if (allocated(oss%trg80)) then
                write(*,*)myname,'nvar:',size(oss%trg80),allocated(oss%trg80)
                do jj=1,size(oss%trg80)
                   write(*,'(X,A,A,I0,A)') myname,"      var(",jj,")='"//trim(oss%trg80(jj))//"'"
                end do
             else
                write(*,*)myname,'No observation targets.'
             end if
             write(*,*)myname,"'Calling parsef: '"//css%mat_e250(ii)(1:css%mat_lene(ii))//"'",ii
          end if
          call parse_parsef(css%mat_psp(ii)%ptr,css%mat_e250(ii)(1:css%mat_lene(ii)),&
               & oss%trg80,crc250,irc)
          if (irc.ne.0) then
             if(col_bdeb)then
                write(*,*)myname,"Unable to parse:'"//&
                     & css%mat_e250(ii)(1:css%mat_lene(ii))//"'",ii
!                write(*,*)myname,'nvar:',size(oss%trg80)
!                do jj=1,size(oss%trg80)
!                   write(*,*) myname,'var:',jj,trim(oss%trg80(jj))
!                end do
             end if
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from parsef.")
             call colocation_errorappendi(crc250,irc)
             call colocation_errorappend(crc250,"\n")
             return
          end if
          call parse_used(css%mat_psp(ii)%ptr,oss%trg_req)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from used.")
             call colocation_errorappendi(crc250,irc)
             call colocation_errorappend(crc250,"\n")
             return
          end if
       end do
    else
       irc=342
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," No matchs specified.")
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
    if(col_bdeb)write(*,*)myname,'Done.'
    return
  end subroutine colocation_compileMatch
  !
  ! evaluate match
  !
  subroutine colocation_evalMatch(css,val,crc250,irc)
    use parse
    implicit none
    type(col_session), pointer :: css !  current session
    real, allocatable :: val(:)    ! values
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="colocation_evalMatch"
    integer :: ii                     ! match number
    type(col_match), pointer :: match
    if (css%cmatch.ne.0) then
       do ii=1,css%cmatch
          !if (col_bdeb)write(*,*)myname,' Local:',val
          css%mat_val(ii)=parse_evalf(css%mat_psp(ii)%ptr,val,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from evalf.")
             call colocation_errorappendi(crc250,irc)
             call colocation_errorappend(crc250,"\n")
             return
          end if
       end do
    else
       irc=341
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," No matches specified.")
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
    return
  end subroutine colocation_evalMatch
  !
  subroutine colocation_removeMatchList(css,crc250,irc)
    use parse
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="colocation_removeMatchList"
    integer :: ii                     ! match number
    type(col_match), pointer :: match
    do ii=1,css%cmatch
       call parse_close(css%mat_psp(ii)%ptr,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"parse_close")
          return
       end if
    end do
    if (col_bdeb) write(*,*)myname,'De-allocating Match-list. ',css%cMatch
    if (associated(css%mat_psp)) deallocate(css%mat_psp)
    if(associated(css%mat_n80))  deallocate(css%mat_n80)
    if(associated(css%mat_lenn)) deallocate(css%mat_lenn)
    if(associated(css%mat_e250)) deallocate(css%mat_e250)
    if(associated(css%mat_lene)) deallocate(css%mat_lene)
    if(associated(css%mat_2trg))  deallocate(css%mat_2trg)
    if(associated(css%mat_min80))  deallocate(css%mat_min80)
    if(associated(css%mat_max80))  deallocate(css%mat_max80)
    css%cMatch = 0
    return
  end subroutine colocation_removeMatchList
  !
  !
  !###############################################################################
  ! CACHE ROUTINES
  !###############################################################################
  ! clear the match stack
  !
  !
  subroutine colocation_setobscache(css,path250,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_setobscache"
    integer, external :: length
    INTEGER                         :: nvar = 0
    !
    if(col_bdeb)write(*,*)myname,' Entering.',irc
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       css%obs250=path250
       call chop0(css%obs250,250)
       css%leno=length(css%obs250,250,10)
       if(col_bdeb)write(*,*)myname," Path: '"//css%obs250(1:css%leno)//"'"
    end if
    !
  end subroutine colocation_setobscache
  !
  subroutine colocation_getobscache(css,path250,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_getobscache"
    INTEGER                         :: nvar = 0
    integer :: lenp
    integer, external :: length
    !
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       path250=css%obs250
       if(col_bdeb) write(*,*)myname," Path: '"//css%obs250(1:css%leno)//"'"
    end if
    return
  end subroutine colocation_getobscache
  !
  subroutine colocation_setmodcache(css,path250,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_setmodcache"
    integer, external :: length
    INTEGER                         :: nvar = 0
    !
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       css%mod250=path250
       call chop0(css%mod250,250)
       css%lenm=length(css%mod250,250,10)
       if(col_bdeb)write(*,*)myname," Path: '"//css%mod250(1:css%lenm)//"'"
    end if
    !
  end subroutine colocation_setmodcache
  !
  subroutine colocation_getmodcache(css,path250,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_getmodcache"
    INTEGER                         :: nvar = 0
    !
    if(col_bdeb)write(*,*)myname,'Entering.',irc
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       path250=css%mod250
    end if
    !
  end subroutine colocation_getmodcache
  !
  !
  !###############################################################################
  ! FILTER/EXPRESSION ROUTINES
  !###############################################################################
  !
  subroutine colocation_expression(exp250,crc250,irc)
    use parse
    character*250 :: exp250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_expression"
    INTEGER                         :: nvar = 0
    CHARACTER (LEN=80), allocatable :: var(:)
    REAL(rn),           allocatable :: val(:)
    REAL(rn)                                       :: res
    INTEGER                                        :: i
    REAL(rn)                                       :: a
    character(len=:), allocatable        :: cbuff   ! some functions write to the string buffer
    type(parse_session),pointer :: pss => null()
    integer :: lene
    integer, external :: length
    character*50 :: s2
    integer :: len2,lenb
    !--------- -------- --------- --------- --------- --------- --------- --------- -----
    !
    if (col_bdeb) write(*,*) myname,'Entering.',irc
    call chop0(exp250,250)
    lene=length(exp250,250,10)
    if (col_bdeb) write(*,*) myname,'Init.'
    call parse_open (pss,crc250,irc) ! open parse session
    if(irc.ne.0) return
    if (col_bdeb) write(*,*) myname,'Parse.',exp250(1:lene)
    call parse_parsef (pss, exp250(1:lene), var,crc250,irc)        ! parse and bytecompile ith function string 
    if(irc.ne.0) return
    !if (col_bdeb) write(*,*) myname,'Eval.', val
    !if (col_bdeb)write(*,*)myname,' Local:',val
    res = parse_evalf (pss, val,crc250,irc)                 ! interprete bytecode representation of ith function
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Error return from evalf.")
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
    if (parse_string(pss,cbuff)) then
       if (allocated(cbuff)) then
          exp250=cbuff
          deallocate(cbuff)
       else
          exp250="No string available"
       end if
    else
       call colocation_wash(res,s2,len2)
       exp250=s2(1:len2)
    end if
    call chop0(exp250,250)
    if (col_bdeb) write(*,*) myname,'Done.',irc,res
    call parse_close (pss,crc250,irc) ! open parse session
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"parse_close")
       return
    end if
    return
  end subroutine colocation_expression
  !
  !
  !###############################################################################
  ! OUTPUT-TABLE ROUTINES
  !###############################################################################
  ! colocate data and write to table file
  !
  subroutine colocation_makeTable(css,mss,oss,ounit,ocnt,name80,&
       & ncol,col80,colexp250,leg250,test,fill250,crc250,irc)
    use model
    use observations
    use parse
    implicit none
    type(col_session), pointer ::  css !  current session
    type(mod_session), pointer ::  mss !  current session
    type(obs_session), pointer ::  oss !  current session
    integer :: ounit ! output unit
    integer :: ocnt ! output count
    character*80 :: name80
    integer :: ncol
    character*80, allocatable :: col80(:)
    character*250, allocatable :: colexp250(:)
    character*250 :: leg250
    integer :: test
    character*250 :: fill250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_maketable"
    !
    integer :: mloc,mtrg,oloc,otrg
    integer :: tmod,emod,dmod,tobs,ii,jj,nfunc
    logical :: bobsind
    logical :: mod_lval(2),obs_lval(2),bok,lok
    integer :: locid,locstart,locstop
    integer :: lena,lenc,lene,lenn,lenl
    integer, external :: length
    integer :: irc2
    character*50:: cval50(ncol)    ! internal column string
    integer:: clen(ncol)           ! internal column string lengths
    type(col_location),pointer :: cloc
    !
    integer :: mod_cnt=0
    integer :: obs_cnt=0
    real :: mod_minval = 0.0D0
    real :: mod_maxval = 0.0D0
    real :: obs_minval = 0.0D0
    real :: obs_maxval = 0.0D0
    logical :: bbok
    character*50 :: s2
    integer :: len2,lenf
    logical :: fill, fillx,bdeb
    !
    call chop0(fill250,250)
    lenf=length(fill250,250,10)
    fillx=(lenf.ne.0)
    fill=.false.
    !
    irc=0
    bok=.true.
    !
    lena=length(name80,80,10)
    if(col_bdeb)write(*,*)myname,'Entering.',ounit,ncol,size(col80),size(colexp250)
    !
    ! check what we should colocated
    tmod=model_targetCount(mss,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"model_targetCount")
       return
    end if
    tobs=observation_targetCount(oss,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"observation_targetCount")
       return
    end if
    emod=colocation_matchCount(css,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"colocation_matchCount")
       return
    end if
    dmod=colocation_defaultCount(css,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"colocation_defaultCount")
       return
    end if
    if (tmod.ne.0.and.tobs.ne.0.and.(emod.eq.0.and.dmod.eq.0)) then
       irc=234
       call colocation_errorappend(crc250,"Missing model match rules,")
       call colocation_errorappendi(crc250,tmod)
       call colocation_errorappendi(crc250,emod)
       call colocation_errorappendi(crc250,dmod)
       call colocation_errorappendi(crc250,tobs)
       return
    else if (tmod.ne.0.and.tobs.eq.0.and.(emod.eq.0.and.dmod.eq.0)) then
       irc=235
       call colocation_errorappend(crc250,"Missing model default values.")
       call colocation_errorappendi(crc250,tmod)
       call colocation_errorappendi(crc250,emod)
       call colocation_errorappendi(crc250,dmod)
       call colocation_errorappendi(crc250,tobs)
       return
    end if
    !
    ! make target lists
    if (tmod.eq.0) then
       bobsind=.false.
    else
       bobsind=observation_hasValidIndex(oss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"observation_hasValidIndex")
          return
       end if
    end if
    !
    call observation_ignoreCat(oss) ! dont count number of obs per BUFR type/subtype
    !
    ! make expression lists
    ! count expressions (match-expressions + obs-index-expression)
    ! make lists
    if(col_bdeb)write(*,*)myname,'Make model target list.'
    if (tmod.ne.0) then
       call model_clearTargetList(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_clearTargetList")
          return
       end if
       call model_makeTargetList(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_makeTargetList")
          return
       end if
    end if
    if (tobs.ne.0) then
       call observation_clearTargetList(oss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"observation_clearTargetList")
          return
       end if
       call observation_makeTargetList(oss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"observation_makeTargetList")
          return
       end if
    end if
    call colocation_importTargets(css,mss,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"colocation_importTargets")
       return
    end if
    call colocation_makeMatchList(css,mss,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"colocation_makeMatchList")
       return
    end if
    if(col_bdeb)write(*,*) myname,'Set model slices.',css%cmatch
    ! Indicate which model targets should be sliced (match obs targets)
    call model_setSliceIndex(mss,css%cmatch,css%mat_2trg,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"model_setSliceIndex")
       return
    end if
    mod_lval(1)=.false. ! are model limits available?
    mod_lval(2)=.false. ! are model limits available?
    if (tobs.ne.0) then
       if(col_bdeb)write(*,*)myname,'Compile match expressions.',emod,associated(css)
       ! compile observation match-experssions
       call colocation_compileMatch(css,oss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_compileMatch")
          return
       end if
       ! convert obs start/end limits (time) to model start/end limits if possible
       if(col_bdeb)write(*,*)myname,'Setting limits.',mss%ind_lval,mss%ind_minval,&
            & mss%ind_maxval,oss%ind_lval(2),oss%ind_minval,oss%ind_maxval
       !
       ! set observation transformation...
       ! ...the first match expression is always the index-transformation...
       call observation_setTransformation(oss,css%mat_psp(1)%ptr,crc250,irc) ! css%cmatch
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Error return from setTransformation.")
          return
       end if
       ! set observation target names
       call  model_setObsTrg(mss,oss%ntrg,oss%trg80,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_setObsTrg")
          return
       end if
    end if
    if (tmod.ne.0)then
       ! compile model filter (called after model_setFilter and model_setObsTrg)
       call model_compileFilter(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_compileFilter")
          return
       end if
       ! flag used observation targets
       call  model_getObsReq(mss,oss%ntrg,oss%trg_req,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_getObsReq")
          return
       end if
    end if
    if (tobs.ne.0) then
       if(col_bdeb)write(*,*)myname,'Compiling obs filter.',ncol,size(col80),size(colexp250)
       ! compile obs filter
       call observation_compileFilter(oss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"obs_compileFilter")
          return
       end if
    end if
    if(col_bdeb)write(*,*)myname,'Compiling colmn expr.',ncol,size(col80),size(colexp250)
    ! compile column expressions
    call model_compileExpr(mss,ncol,colexp250,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"model_compileExpr")
       return
    end if
    if(col_bdeb)write(*,*)myname,'Analyse limits.',mss%ind_lval,oss%ind_lval
    ! get overall max/min limits...
    if (mss%ind_lval(1).and.oss%ind_lval(1)) then
       mod_minval=max(mss%ind_minval,oss%ind_minval)
       mod_lval(1)=.true.
    else if (mss%ind_lval(1)) then
       mod_minval=mss%ind_minval
       mod_lval(1)=.true.
    else if (oss%ind_lval(1)) then
       mod_minval=oss%ind_minval
       mod_lval(1)=.true.
    else
       mod_lval(1)=.false.
    end if
    if (mss%ind_lval(2).and.oss%ind_lval(2)) then
       mod_maxval=min(mss%ind_maxval,oss%ind_maxval)
       mod_lval(2)=.true.
    else if(mss%ind_lval(2)) then
       mod_maxval=mss%ind_maxval
       mod_lval(2)=.true.
    else if(oss%ind_lval(2)) then
       mod_maxval=oss%ind_maxval
       mod_lval(2)=.true.
    else
       mod_lval(2)=.false.
    end if
    if(col_bdeb)write(*,*)myname,'Adjusting mod limits:',mod_lval,mod_minval,mod_maxval,&
         & associated(mss),associated(oss),associated(css)
    call model_setFileStackLimits(mss,mod_lval,mod_minval,mod_maxval,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Error return from model_setFileStackLimits.")
       return
    end if
    !
    if(col_bdeb)write(*,*)myname,'Entering model file loop.',mod_lval,mod_minval,mod_maxval
    MODFILE: do ! need to enter loop if (tmod.eq.0)
       locid=0 ! observation count (= identification)
       if (tmod.ne.0) then ! we have model targets specified
          ! loop over data
          bok= model_loopFileStack(mss,mod_lval,mod_minval,mod_maxval,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,"model_loopFileStack")
             return
          end if
          if (.not.bok) then
             if(col_bdeb)write(*,*)myname,'No more model files.'
             exit MODFILE ! no more files to process
          else 
             mod_cnt=mod_cnt+1
             call observation_setModelFileId(oss,model_getFileId(mss))
             if(col_bdeb)write(*,*)myname,"Found model file: '"//&
                  & mss%currentFile%fn250(1:mss%currentFile%lenf)//"'",&
                  & mod_cnt,model_getFileId(mss)
          end if
          ! get observation file limits
          obs_lval(1)=mod_lval(1)
          obs_minval=mod_minval
          if (mod_lval(1).and.mss%currentFile%ind_lim) then
             obs_minval=max(mod_minval,mss%currentFile%ind_start)
             obs_lval(1)=.true.
          else if (mod_lval(1)) then
             obs_minval=mod_minval
             obs_lval(1)=.true.
          else if (mss%currentFile%ind_lim) then
             obs_minval=mss%currentFile%ind_start
             obs_lval(1)=.true.
          else
             obs_lval(1)=.false.
          end if
          obs_lval(2)=mod_lval(2)
          obs_maxval=mod_maxval
          if (mod_lval(2).and.mss%currentFile%ind_lim) then
             obs_maxval=min(mod_maxval,mss%currentFile%ind_stop)
          else if (mod_lval(2)) then
             obs_maxval=mod_maxval
             obs_lval(2)=.true.
          else if (mss%currentFile%ind_lim) then
             obs_maxval=mss%currentFile%ind_stop
             obs_lval(2)=.true.
          else
             obs_lval(2)=.false.
          end if
       else
          obs_lval(1)=.false.
          obs_lval(2)=.false.
       end if
       !
       if (tmod.ne.0) then ! we have model targets specified
          call model_openCurrentFile(mss,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from model_openCurrentFile.")
             return
          end if
       end if
       !
       if (tobs.ne.0) then
          if(col_bdeb)write(*,*)myname,'Adjusting obs limits:',obs_lval,mss%currentFile%ind_lim,obs_minval,obs_maxval
          call observation_setFileStackLimits(oss,obs_lval,obs_minval,obs_maxval,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from observation_setFileStackLimits.")
             return
          end if
          ! calculate observation target limits...
          call observation_setTargetLimits(oss,mss%currentfile%dim_var,&
               & mss%currentfile%dim_val,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from observation_setFileStackLimits.")
             return
          end if
       end if
       !
       locstart=locid
       ! initialise the location list
       if (tmod.ne.0) then ! we have observation targets available
          if(col_bdeb)write(*,*)myname,'Clear model location stack.'
          call model_clearLocStack(mss,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,"model_clearLocStack")
             return
          end if
       end if
       if (tobs.ne.0) then
          if(col_bdeb)write(*,*)myname,'Clear observation location stack.'
          call observation_clearLocStack(oss,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,"obs_clearLocStack")
             return
          end if
       end if
          ! call model_sliceTarget(mss,crc250,irc)
       ! if (irc.ne.0) then
       !    call colocation_errorappend(crc250,"model_sliceTarget")
       !    return
       ! end if
       
       if(col_bdeb)write(*,*)myname,'Entering obs file loop.'
       ! loop over obs data, using model/obs start/end limits
       OBSFILE : do ! need to enter loop if (tobs.eq.0)
          if (tobs.ne.0) then ! we have observation targets available
             if (col_bdeb) then
                bdeb=obs_bdeb
                obs_bdeb=.true.
             end if
             bok=observation_loopFileStack(oss,obs_lval,obs_minval,obs_maxval,crc250,irc)
             if (col_bdeb) obs_bdeb=bdeb
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"observation_loopFileStack")
                return
             end if
             if (.not.bok) then
                if(col_bdeb)write(*,*)myname,'No more obs files.'
                exit OBSFILE ! no more files to process
             else 
                obs_cnt=obs_cnt+1
                if(col_bdeb)write(*,*)myname,"Found obs file: '"//&
                     & oss%currentFile%fn250(1:oss%currentFile%lenf)//"'",&
                     & oss%currentFileIndex
             end if
          end if
          if (tobs.ne.0.and.tmod.ne.0) then ! we have observation targets available
             if(col_bdeb)write(*,*)myname,'Entering observation loop.'

             ! loop over obs data, using model start/end limits
             LOCATION : do
                !if(col_bdeb)write(*,*)myname,'Slice observation file.'
                ! read next observation into static BUFR memory and set oss%trg_val
                call observation_getNextLoc(oss,bok,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"observation_getNextLoc")
                   return
                end if
                if (.not.bok) then
                   if(col_bdeb)write(*,'(X,A,A,I0,A)')myname,&
                        & 'No more observations to process A (',locid,')'
                   exit LOCATION
                end if
                locid=locid+1
                !
                !if(col_bdeb)write(*,*)myname,'Evaluate expressions.'
                ! evaluate experessions
                call colocation_evalMatch(css,oss%trg_val,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_evalMatch")
                   return
                end if
                !
                ! set observation variables...
                if(col_bdeb)write(*,*)myname,'Set model values.'
                call  model_setObsVal(mss,oss%ntrg,oss%trg_val,oss%trg_vok,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_setObsVal")
                   return
                end if

                ! set match variables...
                if(col_bdeb)write(*,*)myname,'Set model targets.'
                call  model_setTargetVal(mss,css%cMatch,css%mat_2trg,css%mat_val,&
                     & crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_setTargetVal")
                   return
                end if
                ! check target values
                lok=.true.
                ! make new location from observation
                if(col_bdeb.and.model_lucky(locid))write(*,*)myname,'Push location:',locid
                call model_locpushtarget(mss,locid,lok,crc250,irc) ! uses match variables
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_locPush")
                   return
                end if
             end do LOCATION
             if(col_bdeb)write(*,*)myname,'Locations:',locid
          else if (tmod.ne.0) then ! use model default values
             if(col_bdeb)write(*,*)myname,'Creating locations from default.',associated(css%firstLoc)
             if(col_bdeb)write(*,*)myname,'...:',associated(css%firstLoc%next)
             cLoc=>css%firstLoc%next
             do while (.not.associated(cLoc,target=css%lastLoc))
                if(col_bdeb)write(*,*)myname,'Make target values from default.',cLoc%cTrg,cloc%val,cloc%vset
                ! make target values
                call  model_setTargetDVal(mss,cLoc%cTrg,cLoc%vset,cLoc%val,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_setTargetDVal")
                   return
                end if
                ! make new location from observation
                locid=locid+1
                if(col_bdeb)write(*,*)myname,'Creating location:',locid
                ! check target values
                lok=.true.
                ! make new location from default
                if(col_bdeb.and.model_lucky(locid))write(*,*)myname,'Push location:',locid
                call model_locpushtarget(mss,locid,lok,crc250,irc) ! uses match variables
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_locPush")
                   return
                end if
                cLoc=>cLoc%next
             end do
             if(col_bdeb)write(*,*)myname,'Locations:',locid
          end if
          ! end obs data loop
          ! do not delete obs-file contents since obs-file...
          ! ...contents must be available for other model files.
          if (tobs.eq.0.or.test.ne.0) then
             exit OBSFILE
          end if
       end do OBSFILE
       !
       if (tmod.ne.0) then
          if(col_bdeb)write(*,*)myname,'Slicing model locations:',mss%nloc,locid-locstart,locid
          ! finally slice the model file and write model output
          call model_sliceTable(mss,bok,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,"model_sliceTable")
             return
          end if
       end if
       locstop=locid
       !
       ! loop over observations again, write valid observations to XML...
       !         
       do locid=locstart+1,locstop
          if (mod_bdeb)write(*,*)myname,'locready=',mss%locReady
          lok=.true.
          if (tmod.ne.0) then ! we have match expressions specified
             call  model_checkTargetVal(mss,locid,lok,crc250,irc)
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"model_checkTargetVal")
                return
             end if
             call model_checkFilter(mss,locid,lok,crc250,irc)        
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"model_checkFilter")
                return
             end if
          end if
          !
          if (lok) then
             call model_evalExpr(mss,ncol,cval50,clen,crc250,irc)
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"evalExpr")
                return
             end if
             if (ncol.ne.0) then
                write(ounit,"(X,A)",advance="no",iostat=irc) name80(1:lena)
             else
                write(ounit,"(X,A)",iostat=irc) name80(1:lena)
             end if
             if (irc.ne.0) then
                call colocation_errorappend(crc250,myname)
                call colocation_errorappend(crc250," Unable to write 01 "//name80(1:lena))
                call colocation_errorappendi(crc250,irc)
                call colocation_errorappend(crc250,"\n")
                return
             end if
             ocnt=ocnt+1
             fill=fillx
             do ii=1,ncol
                if (ii.ne.ncol) then
                   write(ounit,"(X,A)",advance="no",iostat=irc) cval50(ii)(1:clen(ii))
                else
                   write(ounit,"(X,A)",iostat=irc) cval50(ii)(1:clen(ii))
                end if
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,myname)
                   call colocation_errorappend(crc250," Unable to write 02 "//name80(1:lena))
                   call colocation_errorappendi(crc250,irc)
                   call colocation_errorappend(crc250,"\n")
                   return
                end if
             end do
             if(col_bdeb.and.locid.lt.100)then
                write(*,'(2(X,A),100(X,F0.1))')&
                     & myname,'MPO:',mss%mpo_val
                write(*,'(2(X,A),100(X,L1))')&
                     & myname,'mpo:',mss%mpo_vok
                write(*,'(2(X,A),100(X,A))')&
                     & myname,'VAL:',(cval50(ii)(1:clen(ii)),ii=1,ncol)
             end if
          end if
       end do
       ! end obs data loop
       ! do not delete obs-file contents since obs-file...
       ! ...contents must be available for other model files.
       ! remove location stack
       call model_clearLocStack(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_clearLocStack")
          return
       end if
       ! remove location lists
       call model_clearLocList(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Error return from clearLoc.")
          call colocation_errorappendi(crc250,irc)
          call colocation_errorappend(crc250,"\n")
          return
       end if
       ! remove current model file contents
       call model_clearCurrentFile(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Error return from clearLoc.")
          call colocation_errorappendi(crc250,irc)
          call colocation_errorappend(crc250,"\n")
          return
       end if
       if (tmod.ne.0) then ! we have model targets specified
          call model_closeCurrentFile(mss,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from model_closeCurrentFile.")
             return
          end if
       end if
       ! end model loop
       if (tmod.eq.0.or.test.ne.0)  then
          exit MODFILE
       end if
    end do MODFILE
    !
    call colocation_removeMatchList(css,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"closeMatch")
       return
    end if
    !
    if (fill) then
       if (col_bdeb)write(*,*) myname,"Making fill file: '"//fill250(1:lenf)//"'"
       call colocation_fill(fill250,lenf,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Error return from fill.")
          call colocation_errorappendi(crc250,irc)
          call colocation_errorappend(crc250,"\n")
          return
       end if
    else
       if (col_bdeb)write(*,*) myname,"No fill file: '"//fill250(1:lenf)//"'"
    end if
    !write(*,*) myname,'Done.'
    return
  end subroutine colocation_makeTable
  !
  subroutine colocation_setXmlfile(css,xml250,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: xml250 ! name of xml file
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    character*22 :: myname="colocation_setXmlFile"
    css%xml250=xml250
    css%lenx=length(xml250,250,10)
    if(col_bdeb)write(*,*)myname,' Path: ',css%xml250(1:css%lenx)
    return
  end subroutine colocation_setXmlfile
  !
  subroutine colocation_strepfiles(css,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_strepfiles"
    integer,parameter  :: nn = 6
    character*100 :: src100(nn) = (/'YY','MM','DD','HH','MI','SS'/)
    character*100 :: rep100(nn)
    logical :: lrep(nn)
    integer, external :: length
    call colocation_settime(css,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Error return from settime.")
       call colocation_errorappendi(crc250,irc)
       return
    end if
    ! values(1):	the year
    ! values(2):	the month
    ! values(3):	the day of the month
    ! values(4):	time difference with utc in minutes
    ! values(5):	the hour of the day
    ! values(6):	the minutes of the hour
    ! values(7):	the seconds of the minute
    ! values(8):	the milliseconds of the second
    write(rep100(1),'(i4.4)')css%values(1)
    write(rep100(2),'(i2.2)')css%values(2)
    write(rep100(3),'(i2.2)')css%values(3)
    write(rep100(4),'(i2.2)')css%values(5)
    write(rep100(5),'(i2.2)')css%values(6)
    write(rep100(6),'(i2.2)')css%values(7)
    if(col_bdeb)write(*,*)myname,' Values: ',css%values
    if (css%lenx.ne.0)then
       call colocation_strep(css%xml250,nn,src100,rep100,lrep,irc)
       css%lenx=length(css%xml250,250,10)
    end if
    return
  end subroutine colocation_strepfiles
  !
  subroutine colocation_setTime(css,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_clearsetstack"
    !call date_and_time(VALUES=css%values)
    call parse_date_and_time(css%values)
    return
  end subroutine colocation_setTime
  !
  subroutine colocation_strep(str250,nn,src100,rep100,lrep,irc)
    implicit none
    ! search for, and replace, key words in string with given information...
    character*250 str250
    integer nn
    character*100 src100(nn)
    character*100 rep100(nn)
    logical lrep(nn)
    integer irc
    !
    logical bdone
    character*250 buff250
    character*1000 buff1000
    integer ii,jj,length,lens,lenr,leni
    !
    character*16 myname
    data myname /'strep'/
    !
    do ii=1,nn
       call chop0(src100(ii),100)
       call chop0(rep100(ii),100)
       leni=length(str250,250,10)
       lens=length(src100(ii),100,2)
       lenr=length(rep100(ii),100,2)
       bdone=(leni.eq.0)
       do while (.not.bdone)
          buff250=str250
          bdone=.true.
          do jj=1,leni-lens+1
             !     write(*,*) myname,'"',str250(jj:jj+lens-1),'"',
             !     &              src100(ii)(1:lens),'"'
             if (str250(jj:jj+lens-1).eq.&
                  &              src100(ii)(1:lens)) then
                buff1000=str250(1:jj-1)//&
                     &                 rep100(ii)(1:lenr)//&
                     &                 str250(jj+lens:leni)
                call chop0(buff1000,251)
                str250=buff1000(1:250)
                leni=length(str250,250,10)
                !     write(*,*) myname,str250(1:leni)
                lrep(ii)=.true.
                bdone=(buff250.eq.str250)
             end if
          end do
       end do
    end do
    !     
    return
  end subroutine colocation_strep
  !
  subroutine colocation_getXmlfile(css,xml250,crc250,irc)
    implicit none
    type(col_session), pointer :: css !  current session
    character*250 :: xml250 ! name of xml file
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    character*22 :: myname="colocation_getXmlFile"
    call colocation_strepfiles(css,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"colocation_strepfiles")
       return
    end if
    xml250=css%xml250
    if(col_bdeb)write(*,*)myname,' Path: ',css%xml250(1:css%lenx)
    return
  end subroutine colocation_getXmlfile
  !
  subroutine colocation_makeXML(css,mss,oss,xml250,test,fill250,crc250, irc)
    use model
    use observations
    use parse
    implicit none
    type(col_session), pointer :: css !  current session
    type(mod_session), pointer :: mss !  current session
    type(obs_session), pointer :: oss !  current session
    character*250 :: xml250
    integer :: test
    character*250 :: fill250
    character*250 :: crc250
    integer :: irc
    integer, external :: length,ftunit
    integer :: lenc,lene
    character*26 :: myname="colocation_makeXML"
    integer :: tmod,emod,dmod,tobs,ii,jj,nfunc
    logical :: bobsind
    integer :: locid,locstart,ounit,lenx
    integer :: irc2
    !
    integer :: mod_cnt=0
    integer :: obs_cnt=0
    real :: mod_minval = 0.0D0
    real :: mod_maxval = 0.0D0
    real :: obs_minval = 0.0D0
    real :: obs_maxval = 0.0D0
    logical :: mod_lval(2),obs_lval(2),bok,bbok,lok,bdeb
    type(col_location),pointer :: cloc
    integer :: lenf
    logical :: fill, fillx
    !
    call chop0(fill250,250)
    lenf=length(fill250,250,10)
    fillx=(lenf.ne.0)
    fill=.false.
    !
    irc=0
    bok=.true.
    !
    if(col_bdeb)write(*,*)myname,'Entering.'
    !
    ! check what we should colocated
    tmod=model_targetCount(mss,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"model_targetCount")
       return
    end if
    tobs=observation_targetCount(oss,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"observation_targetCount")
       return
    end if
    emod=colocation_matchCount(css,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"colocation_matchCount")
       return
    end if
    dmod=colocation_defaultCount(css,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"colocation_defaultCount")
       return
    end if
    if (tmod.ne.0.and.tobs.ne.0.and.(emod.eq.0.and.dmod.eq.0)) then
       irc=234
       call colocation_errorappend(crc250,"Missing model match rules,")
       call colocation_errorappendi(crc250,tmod)
       call colocation_errorappendi(crc250,emod)
       call colocation_errorappendi(crc250,dmod)
       call colocation_errorappendi(crc250,tobs)
       return
    else if (tmod.ne.0.and.tobs.eq.0.and.(emod.eq.0.and.dmod.eq.0)) then
       irc=235
       call colocation_errorappend(crc250,"Missing model default values.")
       call colocation_errorappendi(crc250,tmod)
       call colocation_errorappendi(crc250,emod)
       call colocation_errorappendi(crc250,dmod)
       call colocation_errorappendi(crc250,tobs)
       return
    end if
    !
    ! make target lists
    if (tmod.eq.0) then
       bobsind=.false.
    else
       bobsind=observation_hasValidIndex(oss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"observation_hasValidIndex")
          return
       end if
    end if
    !
    ! make expression lists
    ! count expressions (match-expressions + obs-index-expression)
    ! make lists
    if(col_bdeb)write(*,*)myname,'Make model target list.',test
    if (tmod.ne.0) then
       call model_makeTargetList(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_makeTargetList")
          return
       end if
    end if
    if (tobs.ne.0) then
       call observation_makeTargetList(oss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"observation_makeTargetList")
          return
       end if
    end if
    call colocation_importTargets(css,mss,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"colocation_importTargets")
       return
    end if
    call colocation_makeMatchList(css,mss,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"colocation_makeMatchList")
       return
    end if
    if(col_bdeb)write(*,*) myname,'Set model slices.',css%cmatch
    ! Indicate which model targets should be sliced (match obs targets)
    call model_setSliceIndex(mss,css%cmatch,css%mat_2trg,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"model_setSliceIndex")
       return
    end if
    mod_lval(1)=.false. ! are model limits available?
    mod_lval(2)=.false. ! are model limits available?
    if(col_bdeb)write(*,*)myname,'Compile match expressions.',emod,associated(css)
    if (tobs.ne.0) then ! only compile if we have observations...
       if(col_bdeb)write(*,*)myname,'Compile match expressions.',emod,associated(css)
       ! compile observation match-experssions
       call colocation_compileMatch(css,oss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_compileMatch")
          return
       end if
       ! convert obs start/end limits (time) to model start/end limits if possible
       if(col_bdeb)write(*,*)myname,'Setting limits.',mss%ind_lval,mss%ind_minval,&
            & mss%ind_maxval,oss%ind_lval(2),oss%ind_minval,oss%ind_maxval
       !
       ! set observation transformation...
       ! ...the first match expression is always the index-transformation...
       call observation_setTransformation(oss,css%mat_psp(1)%ptr,crc250,irc) ! css%cmatch
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Error return from setTransformation.")
          return
       end if
       ! set observation target names
       call  model_setObsTrg(mss,oss%ntrg,oss%trg80,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_setObsTrg")
          return
       end if
    end if
    if (tmod.ne.0) then
       ! compile model filter (called after model_setFilter and model_setObsTrg)
       call model_compileFilter(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_compileFilter")
          return
       end if
       ! flag used observation targets
       call  model_getObsReq(mss,oss%ntrg,oss%trg_req,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_getObsReq")
          return
       end if
    end if
    if (tobs.ne.0) then
       ! compile obs filter
       call observation_compileFilter(oss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"obs_compileFilter")
          return
       end if
    end if
    if(col_bdeb)write(*,*)myname,'Analyse limits.',mss%ind_lval,oss%ind_lval
    ! get overall max/min limits...
    if (mss%ind_lval(1).and.oss%ind_lval(1)) then
       mod_minval=max(mss%ind_minval,oss%ind_minval)
       mod_lval(1)=.true.
    else if (mss%ind_lval(1)) then
       mod_minval=mss%ind_minval
       mod_lval(1)=.true.
    else if (oss%ind_lval(1)) then
       mod_minval=oss%ind_minval
       mod_lval(1)=.true.
    else
       mod_lval(1)=.false.
    end if
    if (mss%ind_lval(2).and.oss%ind_lval(2)) then
       mod_maxval=min(mss%ind_maxval,oss%ind_maxval)
       mod_lval(2)=.true.
    else if(mss%ind_lval(2)) then
       mod_maxval=mss%ind_maxval
       mod_lval(2)=.true.
    else if(oss%ind_lval(2)) then
       mod_maxval=oss%ind_maxval
       mod_lval(2)=.true.
    else
       mod_lval(2)=.false.
    end if
    if(col_bdeb)write(*,*)myname,'Adjusting mod limits:',mod_lval,mod_minval,mod_maxval,&
         & associated(mss),associated(oss)
    call model_setFileStackLimits(mss,mod_lval,mod_minval,mod_maxval,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Error return from model_setFileStackLimits.")
       return
    end if
    !
    ! open output xml file unit, ounit
    !
    call chop0(xml250,250)
    lenx=length(xml250,250,20)
    if(col_bdeb)write(*,*)myname,' Path: ',xml250(1:lenx),test
    ! open file
    ounit=ftunit(irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," no free unit number for "//xml250(1:lenx))
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
    open ( unit=ounit, status="unknown", form="formatted", &
         &        access="sequential", &
         &        iostat=irc, file=xml250(1:lenx) )
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," unable to open "//xml250(1:lenx))
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       return
    end if
    ! overwrite xml-file...
    write(ounit,'("<colocation>")',iostat=irc2)
    !
    if(col_bdeb)write(*,*)myname,'Entering model file loop.',mod_lval,mod_minval,mod_maxval,obs_lval,obs_minval,obs_maxval
    MODFILE: do ! need to enter loop if (tmod.eq.0)
       locid=0 ! observation count (= identification)
       if (tmod.ne.0) then ! we have model targets specified
          ! loop over data
          bok= model_loopFileStack(mss,mod_lval,mod_minval,mod_maxval,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,"model_loopFileStack")
             return
          end if
          if (.not.bok) then
             if(col_bdeb)write(*,*)myname,'No more model files.'
             exit MODFILE ! no more files to process
          else 
             mod_cnt=mod_cnt+1
             call observation_setModelFileId(oss,model_getFileId(mss))
             if(col_bdeb)write(*,*)myname,"Found model file: '"//&
                  & mss%currentFile%fn250(1:mss%currentFile%lenf)//"'",&
                  & mod_cnt,model_getFileId(mss)
          end if
          !
          ! write file opening xml-tag
          !
          call model_filestartxml(mss,ounit,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,"model_filestartxml")
             return
          end if
          ! get observation file limits
          obs_lval(1)=mod_lval(1)
          obs_minval=mod_minval
          if (mod_lval(1).and.mss%currentFile%ind_lim) then
             obs_minval=max(mod_minval,mss%currentFile%ind_start)
             obs_lval(1)=.true.
          else if (mod_lval(1)) then
             obs_minval=mod_minval
             obs_lval(1)=.true.
          else if (mss%currentFile%ind_lim) then
             obs_minval=mss%currentFile%ind_start
             obs_lval(1)=.true.
          else
             obs_lval(1)=.false.
          end if
          obs_lval(2)=mod_lval(2)
          obs_maxval=mod_maxval
          if (mod_lval(2).and.mss%currentFile%ind_lim) then
             obs_maxval=max(mod_maxval,mss%currentFile%ind_stop)
          else if (mod_lval(2)) then
             obs_maxval=mod_maxval
             obs_lval(2)=.true.
          else if (mss%currentFile%ind_lim) then
             obs_maxval=mss%currentFile%ind_stop
             obs_lval(2)=.true.
          else
             obs_lval(2)=.false.
          end if
       else
          obs_lval(1)=.false.
          obs_lval(2)=.false.
       end if
       !
       !
       if (tmod.ne.0) then ! we have model targets specified
          call model_openCurrentFile(mss,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from model_openCurrentFile.")
             return
          end if
       end if
       !
       if (tobs.ne.0) then
          if(col_bdeb)write(*,*)myname,'Adjusting obs limits:',obs_lval,mss%currentFile%ind_lim,obs_minval,obs_maxval
          call observation_setFileStackLimits(oss,obs_lval,obs_minval,obs_maxval,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from observation_setFileStackLimits.")
             return
          end if
          ! calculate observation target limits...
          call observation_setTargetLimits(oss,mss%currentfile%dim_var,&
               & mss%currentfile%dim_val,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from observation_setFileStackLimits.")
             return
          end if
       end if
       !
       if(col_bdeb)write(*,*)myname,'Entering obs file loop.'
       ! loop over model data, using model/obs start/end limits
       OBSFILE : do ! need to enter loop if (tobs.eq.0)
          if (tobs.ne.0) then ! we have observation targets available
             if (col_bdeb) then
                bdeb=obs_bdeb
                obs_bdeb=.true.
             end if
             bok=observation_loopFileStack(oss,obs_lval,obs_minval,obs_maxval,crc250,irc)
             if (col_bdeb) obs_bdeb=bdeb
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"observation_loopFileStack")
                return
             end if
             if (.not.bok) then
                if(col_bdeb)write(*,*)myname,'No more obs files.'
                exit OBSFILE ! no more files to process
             else 
                obs_cnt=obs_cnt+1
                if(col_bdeb)write(*,*)myname,"Found obs file: '"//&
                     & oss%currentFile%fn250(1:oss%currentFile%lenf)//"'"
             end if
             !
             ! write file opening xml-tag
             !
             call observation_filestartxml(oss,ounit,crc250,irc)
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"observation_filestartxml")
                return
             end if
          end if
          locstart=locid
          if (tobs.ne.0.and.tmod.ne.0) then ! we have observation targets available
             ! initialise the location list
             if(col_bdeb)write(*,*)myname,'Clear model locations.'
             call model_clearLocStack(mss,crc250,irc)
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"model_clearLocStack")
                return
             end if
             ! call model_sliceTarget(mss,crc250,irc)
             ! if (irc.ne.0) then
             !    call colocation_errorappend(crc250,"model_sliceTarget")
             !    return
             ! end if

             if(col_bdeb)write(*,*)myname,'Entering observation loop.'

             ! loop over obs data, using model start/end limits
             LOCATION : do
                !if(col_bdeb)write(*,*)myname,'Slice observation file.'
                ! read next observation into static BUFR memory and set oss%trg_val
                call observation_getNextLoc(oss,bok,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"observation_getNextLoc")
                   return
                end if
                if (.not.bok) then
                   if(col_bdeb)write(*,'(X,A,A,I0,A)')myname,&
                        & 'No more observations to process B (',locid,')'
                   exit LOCATION
                end if
                locid=locid+1
                !
                !write(*,*)myname,'Evaluate expressions.'
                ! evaluate experessions
                call colocation_evalMatch(css,oss%trg_val,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_evalMatch")
                   return
                end if
                !
                ! set observation variables...
                !write(*,*)myname,'Set model targets.'
                call  model_setObsVal(mss,oss%ntrg,oss%trg_val,oss%trg_vok,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_setObsVal")
                   return
                end if

                ! set match variables...
                !write(*,*)myname,'Set model targets.'
                call  model_setTargetVal(mss,css%cMatch,css%mat_2trg,css%mat_val,&
                     & crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_setTargetVal")
                   return
                end if
                ! check target values
                lok=.true.
                ! make new location from observation
                if(col_bdeb.and.model_lucky(locid))write(*,*)myname,'Push location:',locid
                call model_locpushtarget(mss,locid,lok,crc250,irc) ! uses match variables
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_locPush")
                   return
                end if
             end do LOCATION
             if(col_bdeb)write(*,*)myname,'Locations:',locid
          else if (tmod.ne.0) then ! use model default values

             if(col_bdeb)write(*,*)myname,'Clearing loc stack.',mss%ctrg,associated(mss%trg_v80)
             ! initialise the location list
             call model_clearLocStack(mss,crc250,irc)
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"model_clearLocStack")
                return
             end if
             ! call model_sliceTarget(mss,crc250,irc)
             ! if (irc.ne.0) then
             !    call colocation_errorappend(crc250,"model_sliceTarget")
             !    return
             ! end if
             if(col_bdeb)write(*,*)myname,'Creating locations from default.',associated(css%firstLoc)
             if(col_bdeb)write(*,*)myname,'...:',associated(css%firstLoc%next)
             cLoc=>css%firstLoc%next
             do while (.not.associated(cLoc,target=css%lastLoc))
                if(col_bdeb)write(*,*)myname,'Make target values from default.'
                ! make target values
                call  model_setTargetDVal(mss,cLoc%cTrg,cLoc%vset,cLoc%val,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_setTargetDVal")
                   return
                end if
                ! make new location from observation
                locid=locid+1
                if(col_bdeb)write(*,*)myname,'Creating location:',locid
                ! check target values
                lok=.true.
                ! make new location from default
                if(col_bdeb.and.model_lucky(locid))write(*,*)myname,'Push location:',locid
                call model_locpushtarget(mss,locid,lok,crc250,irc) ! uses match variables
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_locPush")
                   return
                end if
                cLoc=>cLoc%next
             end do
             if(col_bdeb)write(*,*)myname,'Locations:',locid
          end if
          !
          if (tmod.ne.0) then
             if(col_bdeb)write(*,*)myname,'Slicing model locations:',locid
             ! finally slice the model file and write model XML to stdout
             call model_sliceXML(mss,ounit,bok,crc250,irc)
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"model_sliceXML")
                return
             end if
          end if
          !
          ! loop over observations again, write valid observations to XML...
          !         
          if (tobs.ne.0) then
             locid=locstart
             if (mod_bdeb)write(*,*)myname,'B locready=',mss%locReady
             OBSERVATION : do
                ! read next location into static memory
                call observation_getNextLoc(oss,bok,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"observation_getNextLoc")
                   return
                end if
                if (.not.bok) then
                   if(col_bdeb)write(*,'(X,A,A,I0,A)')myname,&
                        & 'No more observations to process C (',locid,')'
                   exit OBSERVATION
                end if
                !
                locid=locid+1
                lok=.true.
                if (tmod.ne.0) then ! we have match expressions specified
                   call  model_checkTargetVal(mss,locid,lok,crc250,irc)
                   if (irc.ne.0) then
                      call colocation_errorappend(crc250,"model_checkTargetVal")
                      return
                   end if
                   call model_checkFilter(mss,locid,lok,crc250,irc)
                   if (irc.ne.0) then
                      call colocation_errorappend(crc250,"model_checkFilter")
                      return
                   end if
                end if
                !if (col_bdeb)write(*,*)myname,' OOK:',oss%currentFile%ook
                !
                if (lok) then
                   call observation_writeXML(oss,ounit,locid,crc250,irc)
                   if (irc.ne.0) then
                      call colocation_errorappend(crc250,"observation_writeXML")
                      return
                   end if
                   call model_writeXML(mss,ounit,locid,crc250,irc)
                   if (irc.ne.0) then
                      call colocation_errorappend(crc250,"observation_writeXML")
                      return
                   end if
                   fill=fillx
                end if
             end do OBSERVATION
          else if (tmod.ne.0) then ! use model default values
             write(*,*)myname,'Printing output:',locstart,css%nloc
             do locid=locstart+1,locstart+css%nloc
                lok=.true.
                call  model_checkTargetVal(mss,locid,lok,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_checkTargetVal")
                   return
                end if
                call model_checkFilter(mss,locid,lok,crc250,irc)
                if (irc.ne.0) then
                   call colocation_errorappend(crc250,"model_checkFilter")
                   return
                end if
                if (col_bdeb)write(*,*)myname,' SEARCH:',locid,lok
                !
                if (lok) then
                   ! write location default values to XML (not implemented)...
                end if
             end do
          end if
          ! end obs data loop
          ! do not delete obs-file contents since obs-file...
          ! ...contents must be available for other model files.
          if (tobs.ne.0.or.test.ne.0) then
             call observation_filestopxml(oss,ounit,crc250,irc)
             if (irc.ne.0) then
                call colocation_errorappend(crc250,"observation_filestopxml")
                return
             end if
          else 
             exit OBSFILE
          end if
       end do OBSFILE
       ! remove location stack
       call model_clearLocStack(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,"model_clearLocStack")
          return
       end if
       ! remove location lists
       call model_clearLocList(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Error return from clearLoc.")
          call colocation_errorappendi(crc250,irc)
          call colocation_errorappend(crc250,"\n")
          return
       end if
       ! remove current model file contents
       call model_clearCurrentFile(mss,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Error return from clearLoc.")
          call colocation_errorappendi(crc250,irc)
          call colocation_errorappend(crc250,"\n")
          return
       end if
       if (tmod.ne.0) then ! we have model targets specified
          call model_closeCurrentFile(mss,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,myname)
             call colocation_errorappend(crc250," Error return from model_closeCurrentFile.")
             return
          end if
       end if
       ! end model loop
       if (tmod.ne.0.or.test.ne.0)  then
          ! write file stop xml-tag
          call model_filestopxml(mss,ounit,crc250,irc)
          if (irc.ne.0) then
             call colocation_errorappend(crc250,"model_filestopxml")
             return
          end if
       else 
          exit MODFILE
       end if
    end do MODFILE
    !
    call colocation_removeMatchList(css,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"closeMatch")
       return
    end if
    !
    ! close xml output file unit, ounit
    !
    call model_writeModelDataXML(mss,ounit,crc250,irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,"model_writeModelDataXML")
       return
    end if
    write(ounit,'(A,I0,A,I0,A)',iostat=irc2) " <file_overlap mod='",mod_cnt,"' obs='",obs_cnt,"'/>"
    write(ounit,'("</colocation>")',iostat=irc2)
    close (unit=ounit,iostat=irc)
    if (irc.ne.0) irc=0 ! oh well...
    !
    if (fill) then
       call colocation_fill(fill250,lenf,crc250,irc)
       if (irc.ne.0) then
          call colocation_errorappend(crc250,myname)
          call colocation_errorappend(crc250," Error return from fill.")
          call colocation_errorappendi(crc250,irc)
          call colocation_errorappend(crc250,"\n")
          return
       end if
    else
       if (col_bdeb)write(*,*) myname,"No fill file: '"//fill250(1:lenf)//"'"
    end if
    !write(*,*) myname,'Done.'
    return
  end subroutine colocation_makeXML
  !
  !
  !###############################################################################
  ! ERROR ROUTINES
  !###############################################################################
  !
  !
  subroutine colocation_errorappend(crc250,string)
    implicit none
    character*250 :: crc250
    character*(*) :: string
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    lenb=len(trim(string))
    buff250=string(1:lenb)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//" "//buff250(1:min(250-lenc-1,lenb))
    end if
    call chop0(crc250,250)
  end subroutine colocation_errorappend
  subroutine colocation_errorappendi(crc250,inum)
    implicit none
    character*250 :: crc250
    integer :: inum
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    write(buff250,'(I12)')inum
    call chop0(buff250,250)
    lenb=length(buff250,250,1)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//" "//buff250(1:min(250-lenc-1,lenb))
    end if
    call chop0(crc250,250)
  end subroutine colocation_errorappendi
  !
  !
  !###############################################################################
  ! SORTING ROUTINES
  !###############################################################################
  !
  !
  subroutine colocation_heapsearch1r(maxnn,key,eps,nn,ind,tkey,left,right)
    !
    implicit none
    !
    integer :: maxnn
    real :: key(maxnn)
    real :: eps ! tolerance
    integer :: nn
    integer :: ind(nn)
    real :: tkey
    integer :: left
    integer :: right
    !
    real :: mid
    integer :: mfl,mcl,kfl,kcl,mch
    logical bdone
    !
    if (nn.eq.0) then
       left=-1                ! first element regardless of value
       return
    end if
    !
    left = 1
    right = nn
    do
       mid=float(left+right)/2.0D0
       mfl=floor(mid)
       mcl=ceiling(mid)
       kfl=colocation_cmpr(tkey,key(ind(mfl)),eps)
       kcl=colocation_cmpr(tkey,key(ind(mcl)),eps)
       !write(*,'(X,A,X,I3,F9.2,5(X,I3),3(X,F9.2),2(X,I5))')'colocation_heapsearch:',left,mid,right,mfl,mcl,kfl,kcl,&
       !& tkey,key(ind(mfl)),key(ind(mcl)),ind(mfl),ind(mcl)
       if (kfl.eq.0) then        ! target is at ceiling => exit
          left=mfl
          right=mfl
          exit
       else if (kcl.eq.0) then   ! target is at floor => exit
          left=mcl
          right=mcl
          exit
       else if (kfl.gt.0) then   ! target is lower than floor
          IF (left.eq.right) then
             right=mfl-1
             exit ! out of bounds -> exit
          else
             right=mfl
          end if
       else if (kcl.lt.0) then   ! target is higher than ceiling
          if (left.eq.right) then
             left=mcl+1
             exit ! out of bounds -> exit
          else
             left=mcl
          end if
       else                      ! target is between floor and ceiling => exit
          left=mfl
          right=mcl
          exit
       end if
    end do
    IF (left > right) return
    !find first match...
    bdone=(left<2)
    do while (.not.bdone)
       mch=colocation_cmpr(tkey, key(ind(left-1)),eps)
       if (mch == 0) then ! equal or target is below
          left=left-1
          bdone=(left<2)
       else
          bdone=.true.
       end if
    end do
    !find last match
    bdone=(right>nn-1)
    do while (.not.bdone)
       mch=colocation_cmpr(tkey, key(ind(right+1)),eps)
       if (mch == 0) then ! equal or target is above
          right=right+1
          bdone=(right>nn-1)
       else
          bdone=.true.
       end if
    end do
    !
  end subroutine colocation_heapsearch1r
  !
  subroutine colocation_heapsort1r(mm,key1,eps,newnn,nn,ind,uniq)
    !
    !! Generate sorted index for key1 
    !
    implicit none

    integer :: mm                ! Number of elements
    real :: key1(mm)             ! key
    real :: eps                  ! key tolerance (when are they equal)
    integer :: newnn             ! new number of keys
    integer :: nn                ! Number of elements
    integer :: ind(nn)           ! Resulting sorted index
    logical uniq               ! Ignore duplicate records
    !
    integer :: ii,dmp

    if (nn.eq.0) then
       newnn=0
       return
    end if
    !
    do ii = nn/2, 1, -1
       call colocation_pushdownr(ii, nn, mm,key1,eps,newnn,nn,ind)
    end do
    do ii = nn, 2, -1
       call colocation_swap(ind(1), ind(ii))
       call colocation_pushdownr(1, ii-1, mm,key1,eps,newnn,nn,ind)
    end do
    !
    if (uniq) then
       dmp=0
       newnn=1
       do ii=2,nn
          if (colocation_cmpr(key1(ind(ii-1)),key1(ind(ii)),eps) /= 0) then
             ! Keep ind(ii)
             newnn = newnn+1
             ind(newnn) = ind(ii)
          else
             dmp=dmp+1
          end if
       end do
       if(col_bdeb)write(*,*) "COLOCATION_HEAPSORT dumped elements:",dmp
    else
       newnn=nn
    end if
    !
    !
  end subroutine colocation_heapsort1r
  !
  subroutine colocation_heapsort1i(mm,key1,newnn,nn,ind,uniq)
    !
    !! Generate sorted index for key1 
    !
    implicit none

    integer :: mm                ! Number of elements
    integer :: key1(mm)             ! key
    integer :: newnn             ! new number of keys
    integer :: nn                ! Number of elements
    integer :: ind(nn)           ! Resulting sorted index
    logical uniq               ! Ignore duplicate records
    !
    integer :: ii,dmp

    if (nn.eq.0) then
       newnn=0
       return
    end if
    !
    do ii = nn/2, 1, -1
       call colocation_pushdowni(ii, nn, mm,key1,newnn,nn,ind)
    end do
    do ii = nn, 2, -1
       call colocation_swap(ind(1), ind(ii))
       call colocation_pushdowni(1, ii-1, mm,key1,newnn,nn,ind)
    end do
    !
    if (uniq) then
       dmp=0
       newnn=1
       do ii=2,nn
          if (colocation_cmpi(key1(ind(ii-1)),key1(ind(ii))) /= 0) then
             ! Keep ind(ii)
             newnn = newnn+1
             ind(newnn) = ind(ii)
          else
             dmp=dmp+1
          end if
       end do
       if(col_bdeb)write(*,*) "COLOCATION_HEAPSORT dumped elements:",dmp
    else
       newnn=nn
    end if
    !
    !
  end subroutine colocation_heapsort1i
  !
  subroutine colocation_pushdownr(first, last,mm,key1,eps,newnn,nn,ind)
    !
    implicit none
    integer :: first
    integer :: last
    integer :: mm                ! Number of elements
    real :: key1(mm)             ! key
    real :: eps                  ! key tolerance (when are they equal)
    integer :: newnn             ! new number of keys
    integer :: nn                ! Number of elements
    integer :: ind(nn)           ! Resulting sorted index
    !
    integer :: r
    !
    r = first
    !
    MAINLOOP: do while (r <= last/2)
       if (last == 2*r) then
          if (colocation_cmpr(key1(ind(r)),key1(ind( 2*r)),eps) > 0) then
             call colocation_swap(ind(r), ind(2*r))
          end if
          exit MAINLOOP
       else
          if (colocation_cmpr(key1(ind(r)),key1(ind(2*r)),eps) > 0 .and. &
               & colocation_cmpr(key1(ind(2*r)),key1(ind(2*r+1)),eps) <= 0) then
             call colocation_swap(ind(r), ind(2*r))
             r = 2*r
          else if (colocation_cmpr(key1(ind(r)),key1(ind(2*r+1)),eps)>0 .and. &
               & colocation_cmpr(key1(ind(2*r+1)),key1(ind(2*r)),eps)<0) then
             call colocation_swap(ind(r), ind(2*r+1))
             r = 2*r+1
          else
             exit MAINLOOP
          end if
       end if
    end do MAINLOOP
    !
  end subroutine colocation_pushdownr
  !
  subroutine colocation_pushdowni(first, last,mm,key1,newnn,nn,ind)
    !
    implicit none
    integer :: first
    integer :: last
    integer :: mm                ! Number of elements
    integer :: key1(mm)          ! key
    integer :: newnn             ! new number of keys
    integer :: nn                ! Number of elements
    integer :: ind(nn)           ! Resulting sorted index
    !
    integer :: r
    !
    r = first
    !
    MAINLOOP: do while (r <= last/2)
       if (last == 2*r) then
          if (colocation_cmpi(key1(ind(r)),key1(ind( 2*r))) > 0) then
             call colocation_swap(ind(r), ind(2*r))
          end if
          exit MAINLOOP
       else
          if (colocation_cmpi(key1(ind(r)),key1(ind(2*r))) > 0 .and. &
               & colocation_cmpi(key1(ind(2*r)),key1(ind(2*r+1))) <= 0) then
             call colocation_swap(ind(r), ind(2*r))
             r = 2*r
          else if (colocation_cmpi(key1(ind(r)),key1(ind(2*r+1)))>0 .and. &
               & colocation_cmpi(key1(ind(2*r+1)),key1(ind(2*r)))<0) then
             call colocation_swap(ind(r), ind(2*r+1))
             r = 2*r+1
          else
             exit MAINLOOP
          end if
       end if
    end do MAINLOOP
    !
  end subroutine colocation_pushdowni
  !
  !
  integer function colocation_cmpr(a,b,eps)
    implicit none
    real :: a
    real :: b
    real :: eps
    if (abs(a-b) < eps) then
       colocation_cmpr = 0
    else if (a < b) then
       colocation_cmpr = 1
    else
       colocation_cmpr = -1
    end if
  end function colocation_cmpr
  !
  integer function colocation_cmpi(a,b)
    implicit none
    integer :: a
    integer :: b
    if (a == b) then
       colocation_cmpi = 0
    else if (a < b) then
       colocation_cmpi = 1
    else
       colocation_cmpi = -1
    end if
  end function colocation_cmpi
  !
  !
  subroutine colocation_swap(k1, k2)
    !
    implicit none
    !
    integer :: k1
    integer :: k2
    !
    integer :: tmp
    !
    tmp = k1
    k1 = k2
    k2 = tmp
    !
  end subroutine colocation_swap
  !
  !
  !###############################################################################
  ! STRING ROUTINES
  !###############################################################################
  !
  !
  subroutine findDelimiter(var80,del,pos)
    implicit none
    character*80 :: var80
    character*1 :: del
    integer :: pos
    logical :: bdone
    pos=min(80,pos+1)
    bdone=(pos.eq.80)
    do while (.not.bdone)
       if (var80(pos:pos).eq.del) then
          bdone=.true.
       else
          pos=min(80,pos+1)
          bdone=(pos.eq.80)
       end if
    end do
  end subroutine findDelimiter

  subroutine colocation_wash(val,s2,len2)
    implicit none
    real :: val
    character*50 :: s2
    integer :: len2,lenb
    integer, external :: length
    integer :: jj,irc
    write(s2,'(F0.10)',iostat=irc) val; 
    if (irc.ne.0) then
       s2="NA"
       len2=2
    else
       call chop0(s2,50); 
       lenb=length(s2,50,10) ! ignore last digit...
       len2=lenb-1 ! ignore last digit
       OUTER: do JJ=1,len2
          if (s2(JJ:JJ).eq.".") then
             INNER: do while (s2(len2:len2).eq."0")
                len2=len2-1
             end do INNER
             exit OUTER
          end if
       end do OUTER
       ! handle special cases:
       if (s2(len2:len2).eq.".") len2=len2-1  ! .00000
       if (s2(1:len2).eq."-") len2=len2-1    ! -.0000
       if (len2.eq.0) then              ! .00000 or -.0000
          s2="0"
          len2=1
       end if
       if (len2.eq.lenb-1) len2=lenb ! include last digit...
    end if
    return
  end subroutine colocation_wash
  ! !
  ! subroutine colocation_wash(val,s2,len2)
  !   real :: val
  !   character*50 :: s2
  !   integer :: len2,lenb
  !   integer, external :: length
  !   integer :: jj,irc
  !   write(s2,'(F0.10)',iostat=irc) val; 
  !   if (irc.ne.0) then
  !      s2="NA"
  !      len2=2
  !   else
  !      call chop0(s2,50); 
  !      len2=length(s2,50,10) ! ignore last digit...
  !      lenb=len2
  !      len2=len2-1
  !      if (len2.gt.1) then
  !         OUTER: do JJ=1,len2
  !            if (s2(JJ:JJ).eq.".") then
  !               INNER: do while (len2.gt.JJ.and.&
  !                    & (s2(len2:len2).eq."0".or.s2(len2:len2).eq."."))
  !                  len2=len2-1
  !               end do INNER
  !               exit OUTER
  !            end if
  !         end do OUTER
  !         if (len2.eq.1.and.s2(1:1).eq.".") then
  !            s2="0"
  !         else if (s2(len2:len2).eq.".") then
  !            len2=len2-1
  !         end if
  !      end if
  !      if (len2.eq.lenb-1) len2=lenb
  !   end if
  !   return
  ! end subroutine colocation_wash
  !
  subroutine colocation_fill(fill250,lenf,crc250,irc)
    character*250 :: fill250
    integer :: lenf
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="colocation_fill"
    character*100 :: buff100
    integer, external :: ftunit
    integer :: unitw
    unitw=ftunit(irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250,'Error return from ftunit.')
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       if (col_bdeb) write(*,*) myname,'Error return from ftunit.', irc
       return
    endif
    open (unit=unitw,form="formatted",action="write",iostat=irc,file=fill250(1:lenf))
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Unable to open "//fill250(1:lenf))
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       if (col_bdeb)write(*,*) myname,"unable to open "//fill250(1:lenf)
       return
    end if
    write(unitw,'("Data available.")',iostat=irc)
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Unable to write 03 "//fill250(1:lenf))
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       if (col_bdeb)write(*,*) myname,"unable to write 03 "//fill250(1:lenf)
       return
    end if
    close (unitw,iostat=irc)
    open (unit=unitw,form="formatted",action="read",iostat=irc,file=fill250(1:lenf))
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Unable to open "//fill250(1:lenf))
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       if (col_bdeb)write(*,*) myname,"unable to open "//fill250(1:lenf)
       return
    end if
    read(unitw,*,iostat=irc) buff100
    if (irc.ne.0) then
       call colocation_errorappend(crc250,myname)
       call colocation_errorappend(crc250," Unable to read 01"//fill250(1:lenf))
       call colocation_errorappendi(crc250,irc)
       call colocation_errorappend(crc250,"\n")
       if (col_bdeb)write(*,*) myname,"unable to read 01 "//fill250(1:lenf)
       return
    end if
    close (unitw,iostat=irc)
    irc=chmod(fill250(1:lenf),"a+w")
    if (irc.ne.0) then
       if (col_bdeb)write(*,*)"Unable to chmod '"//fill250(1:lenf)//"'"
       irc=0 ! file could be owned by someone else, so...
    end if
    return
  end subroutine colocation_fill
  !
  logical function model_lucky(cnt)
    integer :: cnt
    integer :: skip
    skip=10**(int(log10(real(max(1,cnt)))))
    model_lucky=(mod(cnt,skip).eq.0)
  end function model_lucky
  !
end module colocation
#__file: 'libcoloc/col_openSession.F90' 0100644    **DO NOT DELETE**
subroutine col_opensession(sid, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "col_opensession"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call colocation_opensession(sid,css,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_openSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.',sid
  return
end subroutine col_opensession
#__file: 'libcoloc/col_pushDefault.F90' 0100644    **DO NOT DELETE**
subroutine col_pushdefault(sid, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "pushdefault"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call colocation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_pushdefault(css,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_pushdefault.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_pushdefault
#__file: 'libcoloc/col_pushMatch.F90' 0100644    **DO NOT DELETE**
subroutine col_pushmatch(sid, nam80, expr250, l80, u80, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*80 :: nam80
  character*250 :: expr250
  character*80 :: l80
  character*80 :: u80
  character*250 :: crc250
  integer :: irc
  character*250 :: buff250
  integer :: lenc
  character*25 :: myname = "col_pushMatch"
  type(col_session), pointer :: css !  current session
  !if(col_bdeb)write(*,*) myname,'Entering.',irc,sid
  call colocation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_pushmatch(css,nam80,expr250,l80,u80,crc250,irc)
  if (irc.ne.0) then
     !write(*,*) 'pushMatch Error.'
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_pushexp.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !if(col_bdeb)write(*,*) myname,'Done.'
  return
end subroutine col_pushmatch
#__file: 'libcoloc/col_setDefault.F90' 0100644    **DO NOT DELETE**
!void col_setdefault_(int* sid, int* nt, char* trg80, char* crc250, int* irc, int len1, int len2, int len3);
subroutine col_setDefault(sid, nt, trg80, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  integer :: nt
  character*80 :: trg80(nt)
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setdefault"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call colocation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_setdefault(css, nt, trg80, crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_setdefault.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_setDefault
#__file: 'libcoloc/col_setModCache.F90' 0100644    **DO NOT DELETE**
subroutine col_setmodcache(sid, path250, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*250 :: path250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setmodcache"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,path250
  call colocation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_setmodcache(css,path250,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_setmodcache.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_setmodcache
#__file: 'libcoloc/col_setObsCache.F90' 0100644    **DO NOT DELETE**
subroutine col_setobscache(sid,path250, crc250, irc)
  use colocation
  implicit none
  integer :: sid             ! session id
  character*250 :: path250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setobscache"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,path250
  call colocation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_setobscache(css,path250,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from colocation_setobscache.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_setobscache
#__file: 'libcoloc/col_setXMLFile.F90' 0100644    **DO NOT DELETE**
subroutine col_setxmlfile(cid, xml250, crc250, irc)
  use colocation
  implicit none
  integer :: cid             ! session id
  character*250 :: xml250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setxmlfile"
  type(col_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,xml250
  !
  call colocation_getSession(css,cid,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from getSession.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  call colocation_setxmlfile(css,xml250,crc250,irc)
  if (irc.ne.0) then
     call colocation_errorappend(crc250,myname)
     call colocation_errorappend(crc250," Error return from col_setxmlfile.")
     call colocation_errorappendi(crc250,irc)
     call colocation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine col_setxmlfile
#__file: 'libmod/mod_clearFileStack.F90' 0100644    **DO NOT DELETE**
subroutine mod_clearfilestack(sid, varname, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*80 :: varname
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearFileStack"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid,varname
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_clearfilestack(css,varname,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_stackclear.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine mod_clearfilestack
#__file: 'libmod/mod_clearTargetStack.F90' 0100644    **DO NOT DELETE**
subroutine mod_cleartargetstack(sid, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearTargetStack"
  type(mod_session), pointer :: css !  current session
  !if (mod_bdeb) write(*,*), 'Entering.',irc,sid
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_cleartargetstack(css,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_stackclear.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine mod_cleartargetstack
#__file: 'libmod/mod_closeSession.F90' 0100644    **DO NOT DELETE**
subroutine mod_closesession(sid, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "determinefileorder"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_closesession(css,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_closeSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.'
  return
end subroutine mod_closeSession
#__file: 'libmod/mod_determineFileOrder.F90' 0100644    **DO NOT DELETE**
subroutine mod_determinefileorder(sid, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "determinefileorder"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_stackorder(css,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_stackorder.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.'
  return
end subroutine mod_determinefileorder
#__file: 'libmod/model.F90' 0100644    **DO NOT DELETE**
!
!"*********************************************************************************************"
!"***This software is ONLY permitted used by staff at the Norwegian Meteorological Institute***"
!"*********************************************************************************************"
! 1) define files/make cache
! 2) define variable targets
!    ...and indexes etc.
! 3) define slice variables/clear locations
!    4) push locations
! 5) loop over files
!    6) get output array(nloc,ntrg).
!
module model
  use parse
  IMPLICIT NONE
# include "netcdf.inc"
  !
  ! Global constants
  !
  character*1 :: sep = "|"
  logical     :: mod_bdeb=.false.
  !
  ! target variables
  !
  type :: mod_target
     character*80 :: n80         ! name
     integer :: lenn             ! length of name
     character*80 :: v80         ! variable
     character*80 :: min80         ! lower limit
     character*80 :: max80         ! upper limit
     logical :: lslice = .false. ! is target a slice variable
     type(mod_target), pointer :: prev => null()   ! linked list
     type(mod_target), pointer :: next => null()   ! linked list
  end type mod_target
  !
  ! Location item
  !   
  type :: mod_location
     integer :: locid
     integer :: iloc
     integer :: csli=0                  ! number of slice variables
     real, allocatable :: sli_val(:)    ! value of slice variable
     integer :: ctrg=0                  ! number of target variables
     real, allocatable    :: trg_val(:) ! value of target variable
     logical, allocatable :: trg_vok(:) ! value of target variable
     logical, allocatable :: trg_set(:)! is target variable set?
     integer :: cobs=0                  ! number of obs variables
     real, allocatable    :: obs_val(:) ! value of obs variable
     logical, allocatable :: obs_vok(:) ! is value set?
     integer :: ndim                    ! number of dimensions
     integer :: noff                    ! number of offset
     integer, allocatable :: pos(:,:)   ! current position (unexpanded)
     real, allocatable    :: rpos(:,:)  ! current position in real (unexpanded)
     real, allocatable    :: intpf(:,:) ! interpolation factor
     integer, allocatable :: lstart(:,:)! start position (unexpanded)
     integer, allocatable :: lstop(:,:) ! stop position
     integer, allocatable :: search(:)  ! is grid search successful, 0=ok?
     logical :: bok = .true.
     type(mod_location), pointer :: prev => null()   ! linked list
     type(mod_location), pointer :: next => null()   ! linked list
  end type mod_location
  !
  type :: mod_locPointer
     type(mod_location), pointer :: ptr => null()
  end type mod_locPointer
  !
  ! a batch job contains variables with common dimensions
  type mod_batch
     integer :: ndim
     integer, allocatable      :: ind(:)         ! dimension index in file
     integer, allocatable      :: inc(:)         ! current search increment
     integer, allocatable      :: dim2sli(:)     ! slice index
     real, allocatable         :: trgdim(:)      ! slice target
     character*80, allocatable :: dim80(:)       ! dimension name
     integer :: nvar
     integer, allocatable      :: var(:)         ! variable index in file
     real, allocatable         :: val(:)         ! current value...
     logical, allocatable      :: proc(:)        ! processed?
     integer, allocatable      :: var2sli(:)     ! index to slice
     real, allocatable         :: trgvar(:)      ! slice target value
     character*80, allocatable :: var80(:)       ! variable name
     type(mod_batch), pointer  :: prev => null() ! linked list
     type(mod_batch), pointer  :: next => null() ! linked list
  end type mod_batch
  !
  type mod_plan
     type(mod_batch), pointer  :: first => null() ! linked list start
     type(mod_batch), pointer  :: last => null()  ! linked list end
     integer :: ndim
     logical, allocatable      :: innerDim(:)! is inner dimension
     integer :: nvar
     real, allocatable         :: trgvar(:)  !  variable target values
     integer, allocatable      :: slc2var(:) ! index from slice array to file var
     integer, allocatable      :: slc2dim(:) ! index from slice array to file dim
     logical, allocatable      :: proc(:)    ! is variable processed
  end type mod_plan
  !
  type mod_attribute
     character*80  :: att80
     integer :: lena
     integer :: type
     integer :: len
     character*1, allocatable ::  ac(:)
     integer*1,  allocatable::  a1(:)
     integer*2,  allocatable::  a2(:)
     integer*4,  allocatable::  a4(:)
     real*4,     allocatable::  ar(:)
     real*8,     allocatable::  ad(:)
  end type mod_attribute
  !
  type :: mod_attPointer
     type(mod_attribute), pointer :: ptr => null()
  end type mod_attPointer
  !
  type :: mod_variable
     character*80 :: var80
     integer :: lenv
     integer :: type
     ! dimensions
     integer :: ndim = 0                    ! number of variable dimensions
     integer(KIND=4), allocatable :: ind(:) ! points to file-dimensions
     integer(KIND=4), allocatable :: istart(:)
     integer(KIND=4), allocatable :: icount(:)
     integer :: natt=0
     type(mod_attPointer), pointer :: att(:) => null()
     real :: scale = 1.0D0
     real :: offset = 0.0D0
     ! missing value
     logical :: mmrange = .false. ! are limits set?
     logical :: mmset   = .false. ! were there any valid values?
     real :: minval = 0.0D0
     real :: maxval = 0.0D0
     integer :: misstype = 0 ! default
     character*1 ::mc
     integer*1::   m1
     integer*2::   m2
     integer*4::   m4
     real*4::      mr
     real*8::      md
     integer*8    :: len = 0
     character*1,allocatable::  fc(:)
     integer*1,  allocatable::  f1(:)
     integer*2,  allocatable::  f2(:)
     integer*4,  allocatable::  f4(:)
     real*4,     allocatable::  fr(:)
     real*8,     allocatable::  fd(:)
  end type mod_variable
  !
  type :: mod_varPointer
     type(mod_variable), pointer :: ptr => null()
  end type mod_varPointer
  !
  ! MODEL OFFSET IN SLICE TARGETS
  !
  type :: mod_offset
     character*80 :: off80
     integer :: leno=0
     integer :: index=0
     integer :: csli                                ! number of slices
     logical, pointer ::             sli_set(:) =>  null() ! is slice offset?
     type(parse_pointer), pointer :: sli_psp(:) => null()  ! offset parse pointer
     type(mod_offset), pointer ::    prev => null() ! linked list
     type(mod_offset), pointer ::    next => null() ! linked list
  end type mod_offset
  !
  type :: mod_offPointer
     type(mod_offset), pointer :: ptr => null()
  end type mod_offPointer
  !
  ! MODEL FILE STACK
  !
  type :: mod_file
     character*250                   :: fn250 = "" ! file name
     integer                         :: lenf
     integer                         :: ncid     ! netcdf id
     CHARACTER(len=10)               :: cfiletype = "netcdf"
     character*250 :: mod250=""                  ! model id
     ! index variable
     real :: trg                                 ! target value of index variable
     integer :: tsort                            ! total number of sort values 
     real :: ind_start                           ! sort starting value (index variable)
     real :: ind_stop                            ! sort stop value (index variable)
     logical :: ind_lim = .false.                ! are ind_start/ind_stop available?
     ! sorting the index variable
     integer :: nsort=0                          ! number of sort values
     real, allocatable :: sort(:)                ! values array
     integer,allocatable :: indsort(:)           ! index of sorted values
     character*250, allocatable :: desc250(:)    ! description of position
     type(mod_file), pointer :: prev => null()   ! linked list
     type(mod_file), pointer :: next => null()   ! linked list
     ! dimensions (names, length)
     integer :: ndim = 0                         ! number of dimensions
     character*80, allocatable :: dim80(:)       ! dimension names
     integer, allocatable :: lend(:)             ! dimension name length
     integer, allocatable :: dim_trg(:)          ! index to target (0=no target)
     integer, allocatable :: istart(:)           ! dimension start
     integer, allocatable :: istop(:)            ! dimension stop
     character*80, allocatable :: dim_var(:)     ! dimension name
     real, allocatable :: dim_val(:)             ! dimension values
     ! variables
     integer :: nvar                             ! number of variables
     character*80, allocatable :: var80(:)       ! variable name
     integer, allocatable :: lenv(:)             ! variables name length
     type(mod_varPointer), pointer :: var(:)  => null() ! variable pointer
     integer :: ngatt          ! number of global attributes
     integer :: unlimdimid     ! index to the dimension that is unlimited...
     integer :: ook(10),orm(10)
  end type mod_file
  !
  type :: mod_filePointer
     type(mod_file), pointer :: ptr => null()
  end type mod_filePointer
  !
  ! SESSION VARIABLES
  !
  type :: mod_session
     integer                         :: sid
     CHARACTER(LEN=250)              :: fn250
     CHARACTER(len=10)               :: cfiletype = "netcdf"
     !
     type(mod_file), pointer :: firstFile => null()   ! linked list start
     type(mod_file), pointer :: lastFile => null()    ! linked list end
     type(mod_file), pointer :: currentFile => null()
     type(mod_file), pointer :: nextFile => null()
     type(mod_filePointer), pointer   :: fileStack(:) => null() ! array of the stack elements
     real, allocatable            :: fileStackSort(:,:)
     integer, allocatable         :: fileStackInd(:,:)
     integer :: nFileIndexes = 0              ! total number of files on the stack
     integer :: nFileSortIndexes = 0          ! number of file indexes on the stack
     integer :: newnFileSortIndexes(2)        ! new number of file indexes on the stack
     integer :: currentFileSortIndex = 0      ! current stack index element
     integer :: currentFileIndex = 0          ! current stack element
     logical :: fileReady =.false.           ! are sorted data ready for use?
     integer :: leftFileSortIndex = 0         ! ref fileStackSort(*,2) - maxvalues
     integer :: rightFileSortIndex = 0        ! ref fileStackSort(*,1) - minvalues
     logical :: sortLimitsOk  = .false.       ! is there overlap between current file and min/max limits
     character*80, allocatable :: sys_var(:)
     real, allocatable         :: sys_val(:)
     integer,dimension(8)      :: values    
     integer :: fok(10),frm(10)
     !
     type(mod_offset), pointer :: firstOffset => null()   ! linked offset list start
     type(mod_offset), pointer :: lastOffset => null()    ! linked offset list end
     integer :: nOffsetIndexes = 0              ! total number of files on the stack
     type(mod_offPointer), pointer :: offset(:)  => null() ! variable pointer
     !
     integer :: tsort = 0              ! total number of "index values" on the stack
     integer :: msort                  ! maximum number of "index variables"
     !
     ! index variable
     character(LEN=80)         :: ind_trg   ! index name
     integer :: ind_lent=0                  ! length of sorting variable
     character(LEN=80)         :: ind_var   ! index sorting variable
     integer :: ind_lenv=0                  ! length of sorting variable
     logical :: ind_set = .false.
     real    :: ind_minval=0.0D0
     real    :: ind_maxval=0.0D0
     logical :: ind_lval(2) = .false.
     !
     ! locations
     type(mod_location), pointer :: firstLoc => null()   ! linked list start
     type(mod_location), pointer :: lastLoc => null()    ! linked list end
     integer :: nloc=0                                   ! number of items in location-chain
     integer :: locoo = 0                                ! offset between locid and position in locdata
     type(mod_locPointer), allocatable :: locData(:)     !  data locations
     logical :: locReady = .false.
     !
     ! slice variables
     integer :: csli = 0                      ! number of slice variables allocated
     character*80, allocatable :: sli80(:)    ! slice name
     integer, allocatable      :: sli_lens(:) ! length of slice variable
     character*80, allocatable :: sli_v80(:)  ! slice variable
     integer, allocatable      :: sli_lenv(:) ! length of slice variable
     integer, allocatable      :: sli_2trg(:) ! index from slice to target
     !
     ! targets
     type(mod_target), pointer :: firstTrg => null()   ! linked list start of target-chain
     type(mod_target), pointer :: lastTrg => null()    ! linked list end of target-chain
     type(mod_target), pointer :: currentTrg => null() ! current target loop
     integer :: ntrg=0                                 ! number of items in target-chain
     integer :: ctrg = 0                               ! number of targets allocated in array
     character*80, pointer :: trg80(:) => null()       ! list of target names
     integer, pointer      :: trg_lent(:) => null()    ! list of target name length
     character*80, pointer :: trg_v80(:) => null()     ! list of variable names
     integer, pointer      :: trg_lenv(:) => null()    ! list of target name length
     integer, pointer      :: trg_offset(:) => null()  ! list of target offset
     integer, pointer      :: trg_dim(:) => null()     ! index to dimension
     integer, pointer      :: trg_var(:) => null()     ! index to variable
     integer, pointer      :: trg_type(:) => null()     ! index to variable
     character*80, pointer :: trg_min80(:) => null()     ! list of lower limits
     character*80, pointer :: trg_max80(:) => null()     ! list of upper limits
     real, pointer         :: trg_minval(:) => null()  ! list of lower values
     real, pointer         :: trg_maxval(:) => null()  ! list of upper values
     logical, pointer      :: trg_sliceset(:) => null()! is target a slice variable?
     logical, pointer      :: trg_valset(:) => null()  ! is target value set by match?
     logical, pointer      :: trg_minset(:) => null()  ! list of is lower set?
     logical, pointer      :: trg_maxset(:) => null()  ! list of is upper set?
     logical, pointer      :: trg_req(:) => null()     ! is variable required?
     logical, pointer      :: trg_vok(:) => null()     ! is variable required?
     real, pointer         :: trg_val(:) => null()     ! list of values
     integer, pointer      :: trg_ook(:) => null()
     integer, pointer      :: trg_orm(:) => null()
     integer, pointer      :: trg_fok(:) => null()
     integer, pointer      :: trg_frm(:) => null()
     logical :: trg_set=.false.                     ! is target list set?
     !
     ! observation targets...
     integer :: cobs = 0                            ! number of observation values
     character*80, pointer :: obs_var(:)  => null() ! list of obs target names
     integer, pointer      :: obs_lenv(:) => null() ! list of obs target name length
     logical, pointer      :: obs_req(:)  => null() ! list of required variables
     logical, pointer      :: obs_vok(:)  => null() ! list of observation values
     real, pointer         :: obs_val(:)  => null() ! list of observation values
     !
     integer :: cpsp=0
     type(parse_pointer), pointer :: psp(:)=>null() ! parse pointer
     !
     CHARACTER*250 :: FLT250
     integer :: lenf=0
     logical ::  mpo_set=.false.
     integer :: cmpo=0
     character*80, allocatable :: mpo_var(:)   ! list of variable names
     integer, allocatable      :: mpo_lenv(:)  ! list of target name length
     logical, allocatable      :: mpo_req(:)   ! list of required variables
     logical, allocatable      :: mpo_vok(:)   ! list of valid varlues
     real, allocatable         :: mpo_val(:)   ! list of values
     type(parse_session), pointer :: psf => null()
     !
     ! output
     integer :: otrg=0                        ! number of allocated output target
     integer :: oloc=0                        ! number of allocated output locations
     real, pointer :: oval(:,:) => null()     ! output values
     logical, pointer :: oset(:,:) => null()  ! are output values set?
     !
     integer :: fid = 0 ! file id (index number)
     !
     type(mod_session), pointer :: prev => null()      ! linked list
     type(mod_session), pointer :: next => null()      ! linked list
  end type mod_session
  !
  integer :: maxid=0 ! session counter
  type(mod_session), pointer :: firstSession => null() ! linked list start
  type(mod_session), pointer :: lastSession => null()  ! linked list end
  !
CONTAINS
  !
  !
  !###############################################################################
  ! SESSION ROUTINES
  !###############################################################################
  !
  subroutine model_opensession(sid,css,crc250,irc)
    integer :: sid
    type(mod_session),pointer :: css  !  new session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_openSession"
    if (.not.associated(firstSession)) then
       allocate(firstSession, lastSession,stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate 'firstSession/lastSession'.")
          call model_errorappend(crc250,"\n")
          return
       end if
       firstSession%next => lastSession
       lastSession%prev => firstSession
    end if
    nullify(css)
    allocate(css,stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'new session'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    !call date_and_time(VALUES=css%values) ! get current date and time
    call parse_date_and_time(css%values) ! get current date and time
    !call model_timeOffset(css)                ! add offset...
    if (allocated(css%sys_var)) deallocate (css%sys_var)
    if (allocated(css%sys_val)) deallocate (css%sys_val)
    allocate(css%sys_var(2),css%sys_val(2),stat=irc)
    css%sys_var(1)="now"
    css%sys_var(2)="midnight"
    css%sys_val(1)=parse_f1970(&
         & real(css%values(1)),real(css%values(2)),&
         & real(css%values(3)),real(css%values(5)),&
         & real(css%values(6)),real(css%values(7)))
    css%sys_val(2)=parse_f1970(&
         & real(css%values(1)),real(css%values(2)),&
         & real(css%values(3)),0.0D0,&
         & 0.0D0,0.0D0) ! midnight
    !
    maxid=maxid+1
    css%sid=maxid
    css%prev => lastSession%prev
    css%next => lastSession
    css%prev%next => css
    css%next%prev => css
    sid = css%sid
    css%nFileIndexes=0
    css%tsort=0
    !
    allocate(css%firstFile,css%lastFile, stat=irc) ! 
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate &
            & 'css%firstFile/css%lastFile'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    css%firstFile%next => css%lastFile
    css%lastFile%prev => css%firstFile
    !
    allocate(css%firstOffset,css%lastOffset, stat=irc) ! 
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate &
            & 'css%firstOffset/css%lastOffset'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    css%firstOffset%next => css%lastOffset
    css%lastOffset%prev => css%firstOffset
    css%noffsetindexes=0
    !
    allocate(css%firstLoc,css%lastLoc, stat=irc) ! 
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate &
            & 'css%firstLoc/css%lastLoc'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    css%firstLoc%next => css%lastLoc
    css%lastLoc%prev => css%firstLoc
    css%locReady=.false.
    !
    allocate(css%firstTrg,css%lastTrg, stat=irc) ! 
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate &
            & 'css%firstTrg/css%lastTrg'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    css%firstTrg%next => css%lastTrg
    css%lastTrg%prev => css%firstTrg
    !
    ! mark as prepared
    css%fileReady=.false.
    return
  end subroutine model_opensession

  subroutine model_getSession(css,sid,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: sid
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_getSession"
    if (.not.associated(firstSession)) then
       irc=911
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"No session is opened!")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    css => firstSession%next
    do while ( .not.associated(css,target=lastSession))
       if (css%sid .eq. sid) then
          !if (mod_bdeb) write(*,*)myname,'Exiting with sid:',sid,irc
          return
       end if
       css=>css%next
    end do
    nullify(css)
    irc=342
    call model_errorappend(crc250,myname)
    call model_errorappend(crc250,"Invalid session id:")
    call model_errorappendi(crc250,sid)
    call model_errorappend(crc250,"\n")
    return
  end subroutine model_getSession

  subroutine model_closeSession(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_closeSession"
    if(mod_bdeb)write(*,*)myname,'Entering.',irc
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       call model_removeSession(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from removeSession.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    else
       irc=599
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Attempt to close none-existent session.")
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_closeSession

  subroutine model_removeSession(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(mod_file), pointer :: cfile, cfilen
    type(mod_offset), pointer :: coffset, coffsetn
    type(mod_location), pointer :: cloc, clocn
    type(mod_target), pointer :: ctrg, ctrgn
    integer :: ii
    character*25 :: myname="model_removeSession"
    ! remove location stack
    if(mod_bdeb)write(*,*)myname,'Entering.',irc
    if(mod_bdeb)write(*,*)myname,'Un-slice.'
    !
    if (allocated(css%sys_var)) deallocate (css%sys_var)
    if (allocated(css%sys_val)) deallocate (css%sys_val)
    !
    ! remove global slice arrays
    if (allocated(css%sli80)) deallocate(css%sli80)
    if (allocated(css%sli_lens)) deallocate(css%sli_lens)
    if (allocated(css%sli_v80)) deallocate(css%sli_v80)
    if (allocated(css%sli_lenv)) deallocate(css%sli_lenv)
    if (allocated(css%sli_2trg)) deallocate(css%sli_2trg)
    !
    ! remove file-stack
    if (associated(css%filestack)) then
       do ii=1,size(css%filestack)
          if (associated(css%filestack(ii)%ptr)) then
             nullify(css%filestack(ii)%ptr)
          end if
       end do
       deallocate(css%filestack)
    end if
    if(mod_bdeb)write(*,*)myname,'Un-stack.'
    if (allocated(css%filestacksort)) deallocate(css%filestacksort)
    if (allocated(css%filestackind)) deallocate(css%filestackind)
    if (associated(css%firstFile)) then
       cfile => css%firstFile%next
       do while (.not.associated(cfile,target=css%lastFile))
          cfilen => cfile%next
          call model_deleteFile(css,cfile,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from deleteFile.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          cfile  => cfilen
       end do
       deallocate(css%firstFile,css%lastFile)
    end if
    !
    if(mod_bdeb)write(*,*)myname,'Un-Offset.'
    if (associated(css%firstOffset)) then
       coffset => css%firstOffset%next
       do while (.not.associated(coffset,target=css%lastOffset))
          coffsetn => coffset%next
          call model_deleteOffset(css,coffset,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from deleteOffset.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          coffset  => coffsetn
       end do
       deallocate(css%firstOffset,css%lastOffset)
    end if
    !
    if(mod_bdeb)write(*,*)myname,'Un-Loc.'
    ! remove location arrays
    call model_clearLocList(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from clearLoc.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    ! remove location stack
    css%locReady=.false.
    if (associated(css%firstLoc)) then
       cloc => css%firstLoc%next
       do while (.not.associated(cloc,target=css%lastLoc))
          clocn => cloc%next
          call model_deleteLoc(css,cloc,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from deleteLoc.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          cloc  => clocn
       end do
       deallocate(css%firstLoc,css%lastLoc)
    end if
    !
    if(mod_bdeb)write(*,*)myname,'Un-Trg and Un-MPO.'
    ! remove target stack
    call model_cleartargetlist(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from cleartargetlist.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if (associated(css%firstTrg)) then
       ctrg => css%firstTrg%next
       do while (.not.associated(ctrg,target=css%lastTrg))
          ctrgn => ctrg%next
          call model_deleteTarget(css,ctrg,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from deleteTrg.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          ctrg  => ctrgn
       end do
       deallocate(css%firstTrg,css%lastTrg)
    end if
    if(mod_bdeb)write(*,*)myname,'Un-Out.'
    !
    ! remove output variables
    if (associated(css%oval)) deallocate(css%oval)
    if (associated(css%oset)) deallocate(css%oset)
    !
    if (associated(css%obs_var)) deallocate(css%obs_var)
    if (associated(css%obs_lenv)) deallocate(css%obs_lenv)
    if (associated(css%obs_req)) deallocate(css%obs_req)
    if (associated(css%obs_vok)) deallocate(css%obs_vok)
    if (associated(css%obs_val)) deallocate(css%obs_val)
    css%cobs=0
    !
    if(mod_bdeb)write(*,*)myname,'Un-Psf.'
    ! deallocate observation filter...
    if (css%lenf.ne.0) then
       call parse_close(css%psf,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from parse_close.")
          return
       end if
    end if
    !
    if(mod_bdeb)write(*,*)myname,'Un-PSP.',associated(css%psp)
    call model_clearPSP(css%psp,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,"clearPSP.")
       return
    end if
    !
    if(mod_bdeb)write(*,*)myname,'Un-link.'
    ! unlink from session-chain
    css%prev%next => css%next
    css%next%prev => css%prev
    deallocate(css)
    if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_removeSession
  !
  !
  !###############################################################################
  ! STACK ROUTINES
  !###############################################################################
  ! initialise the stack
  !
  subroutine model_initfilestack(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_initfilestack"
    ! initialise chain
    allocate(css%firstFile,css%lastFile, stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'css%firstFile/css%lastFile'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    css%firstFile%next => css%lastFile
    css%lastFile%prev => css%firstFile
    css%nFileIndexes=0
    css%tsort=0
    ! mark as prepared
    css%fileReady=.false.
  end subroutine model_initfilestack
  !
  subroutine model_initoffsetstack(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_initoffsetstack"
    ! initialise chain
    if(mod_bdeb)write(*,*)myname,' Entering.',css%nOffsetIndexes
    allocate(css%firstOffset,css%lastOffset, stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'css%firstOffset/css%lastOffset'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    css%firstOffset%next => css%lastOffset
    css%lastOffset%prev => css%firstOffset
    css%nOffsetIndexes=0
    return
  end subroutine model_initoffsetstack
  !
  ! clear the MODEL STACK
  !
  subroutine model_clearfilestack(css,var80,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*80 :: var80
    character*250 :: crc250
    integer :: irc
    type(mod_file), pointer :: currentFile => null()
    type(mod_file), pointer :: stackNext => null()
    integer, external :: length
    integer :: lens
    character*25 :: myname="model_clearfilestack"
    if(mod_bdeb)write(*,*)myname,' Entering.'
    if (.not.associated(css%firstFile)) then
       call model_initfilestack(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from rmItem.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    css%ind_var=var80
    call chop0(css%ind_var,80)
    lens=length(css%ind_var,80,10)
    currentFile => css%firstFile%next
    do while (.not.associated(currentFile,target=css%lastFile))
       stackNext => currentFile%next
       call model_deleteFile(css,currentFile,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from rmItem.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       currentFile => stackNext
    end do
    css%fileReady=.false.
    if (css%nFileIndexes .ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," System error:")
       call model_errorappendi(crc250,css%nFileIndexes)
       call model_errorappend(crc250,"\n")
       irc=940
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Done.'
  end subroutine model_clearfilestack
  !
  subroutine model_deleteOffset (css,df,crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_offset), pointer :: df
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    character*25 :: myname="model_deleteOffset"
    if(mod_bdeb)write(*,*)myname,'Entering.'
    if (associated(df)) then
       if (associated(df%sli_set)) deallocate(df%sli_set)
       call model_clearPSP(df%sli_psp,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from clearPSP.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       !
       if (associated(df%prev)) then
          df%prev%next =>df%next
       end if
       if (associated(df%next)) then
          df%next%prev =>df%prev
       end if
       css%noffsetindexes=css%noffsetindexes-1
       deallocate(df)
    endif
    if(mod_bdeb)write(*,*)myname,'Done.'
    return
  end subroutine model_deleteOffset
  !
  ! remove item from model stack
  !
  subroutine model_deleteFile (css,df,crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_file), pointer :: df
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    character*25 :: myname="model_deleteFile"
    !if(mod_bdeb)write(*,*)myname,'Entering.'
    if (associated(df)) then
       css%nFileIndexes = css%nFileIndexes - 1
       css%tsort = css%tsort - df%nsort
       css%fileReady=.false.
       df%next%prev => df%prev
       df%prev%next => df%next
       css%currentfile => df
       call model_clearCurrentFile(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from clearCurrentFile.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    !if(mod_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine model_deleteFile
  !
  ! delete file contents
  !
  subroutine model_clearCurrentFile (css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    character*25 :: myname="model_clearCurrentFile"
    type(mod_file), pointer :: df
    integer :: irc2
    integer :: ii
    !if(mod_bdeb)write(*,*)myname,'Entering.',associated(css%currentFile)
    df => css%currentFile
    if (associated(df)) then
       if (allocated(df%sort)) deallocate(df%sort,stat=irc2)
       if (allocated(df%indsort)) deallocate(df%indsort,stat=irc2)
       if (allocated(df%desc250)) deallocate(df%desc250,stat=irc2)
       if (allocated(df%dim80)) deallocate(df%dim80,stat=irc2)
       if (allocated(df%lend)) deallocate(df%lend,stat=irc2)
       if (allocated(df%dim_trg)) deallocate(df%dim_trg,stat=irc2)
       if (allocated(df%istart)) deallocate(df%istart,stat=irc2)
       if (allocated(df%istop)) deallocate(df%istop,stat=irc2)
       if (allocated(df%dim_var)) deallocate(df%dim_var,stat=irc2)
       if (allocated(df%dim_val)) deallocate(df%dim_val,stat=irc2)
       if (allocated(df%var80)) deallocate(df%var80,stat=irc2)
       if (allocated(df%lenv)) deallocate(df%lenv,stat=irc2)
       !if(mod_bdeb)write(*,*)myname,'Deleting vars:',df%nvar
       if (associated(df%var)) then
          do ii=1,df%nvar
             !if(mod_bdeb)write(*,*)myname,'Var:',ii !,associated(df%var(ii)%ptr)
             call model_deleteVariable(df%var(ii)%ptr,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from deleteVariable.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             if (associated(df%var(ii)%ptr)) deallocate(df%var(ii)%ptr)
          end do
       end if
       if (associated(df%var)) deallocate(df%var,stat=irc2)
    end if
    !if(mod_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine model_clearCurrentFile
  !
  ! Add model-file (grib/netcdf) to the MODEL STACK
  !
  subroutine model_pushFile(css,path250,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(mod_file),pointer :: newFile
    logical  :: bok =.false.
    character(len=80), allocatable, dimension(:) :: dim80
    integer :: nvalues, tsize, ndims
    integer :: ii,jj,kk,tt
    CHARACTER(LEN=80)               :: var80
    integer, external :: length
    integer :: lenc,leni,lenv,lens,lenp,lend
    logical :: bbok
    integer :: nslice
    character*80, allocatable :: sdim80(:)
    character*25 :: myname="model_pushFile"
    if(mod_bdeb)write(*,*)myname,'Entering.',css%nFileIndexes,irc
    call chop0(path250,250)
    lenp=length(path250,250,20)
    !mod_bdeb=.true.
    write(*,*)myname," Pushing '"//path250(1:lenp)//"'"
    if (.not.associated(css%firstFile)) then
       call model_initfilestack(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from stackinit.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    ! create new stack-item
    bok=.true.
    !write(*,*)myname," Allocating"
    allocate(newFile,stat=irc)
    if (irc.ne.0) then
       bok=.false.
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate new stack item.")
       call model_errorappend(crc250,"\n")
       return
    end if
    ! open file
    if (bok) then
       ! set file name...
       nslice=0
       allocate(sdim80(1))
       newFile%fn250=path250
       newFile%lenf=lenp
       newFile%cfileType=css%cfiletype
       ! open file
       call model_openFile(css,newFile,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from openFile.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    if (bok) then
       if (bok) then
          call model_readInventory(css,newFile,crc250,irc)
          if (irc.ne.0) then
             bok=.false.
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from readInventory.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       end if
       if (bok) then
          call model_setRange(css,newFile,crc250,irc)
          if (irc.ne.0) then
             bok=.false.
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from setLimits.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if          
       end if
       if (bok) then
          call model_readSortVariable(css,newFile,crc250,irc)
          if (irc.ne.0) then
             bok=.false.
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from readSortVariable.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       end if
       call model_closeFile(css,newFile,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from closeFile.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    ! push onto stack
    if (bok) then
       css%nFileIndexes=css%nFileIndexes + 1
       css%tsort=css%tsort + newFile%nsort
       css%fileReady=.false.
       newFile%prev => css%lastFile%prev
       newFile%next => css%lastFile
       newFile%prev%next => newFile
       newFile%next%prev => newFile
    else
       call deleteFile(css,newFile,crc250,irc)
       deallocate(newFile,stat=irc)
       irc=0 ! ignore any errors
    end if
    if(mod_bdeb)write(*,*)myname,' Done.',css%nFileIndexes
  end subroutine model_pushFile

  !
  ! Remove last model-file on the MODEL STACK
  !
  subroutine model_popfile(css,path250,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(mod_file), pointer :: currentFile => null()
    type(mod_file), pointer :: prevFile => null()
    character*25 :: myname="model_popfile"
    logical :: bdone
    integer, external :: length
    integer :: lenp
    if(mod_bdeb)write(*,*)myname,'Entering.',css%nFileIndexes,irc
    if (.not.associated(css%firstFile)) then
       call model_initfilestack(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from rmItem.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    call chop0(path250,250)
    lenp=length(path250,250,10)
    currentFile => css%lastFile%prev
    bdone=associated(currentFile,target=css%firstFile)
    do while (.not. bdone) 
       prevFile=>currentFile%prev
       if (currentFile%fn250(1:currentFile%lenf).eq.path250(1:lenp).or.lenp.eq.0) then
          if(mod_bdeb)write(*,*)myname," File: '"//path250(1:lenp)//"'"
          call model_deleteFile(css,currentFile,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from deleteFile.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          css%fileReady=.false.
          bdone=(lenp.eq.0)
       end if
       currentFile=>prevFile
       bdone=(bdone.or.associated(currentFile,target=css%firstFile))
    end do
    if(mod_bdeb)write(*,*)myname,' Done.',css%nFileIndexes
    return
  end subroutine model_popfile

  !
  ! Peek at last model-file put onto the MODEL STACK
  !
  subroutine model_peeklen(css,maxrep,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: maxrep
    character*250 :: crc250
    integer :: irc
    type(mod_file), pointer :: currentFile => null()
    integer :: ii,jj
    character*25 :: myname="model_peeklen"
    if (.not.associated(css%firstFile)) then
       call model_initfilestack(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from stackinit.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    currentFile => css%lastFile%prev
    maxrep=1
    if (.not.associated(currentFile,target=css%firstFile)) then
       ! file name
       maxrep=maxrep+1
       maxrep=maxrep+4
       maxrep=maxrep+currentFile%ndim*1
       do ii=1,currentFile%nvar
          maxrep=maxrep+1
          do jj=1,currentFile%var(ii)%ptr%ndim
             maxrep=maxrep+1
          end do
       end do
    end if
    if(mod_bdeb)write(*,*)myname,' Done.',maxrep
  end subroutine model_peeklen
  !
  subroutine model_peek(css,maxrep,nrep, rep250, crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: maxrep
    integer :: nrep
    character*250 :: rep250(maxrep)
    character*250 :: crc250
    integer :: irc
    character*50 :: s1, s2, s3
    integer, external :: length
    integer :: len1,len2,len3,lenm,lenv,lena,lenr,lend,lens
    type(mod_file), pointer :: currentFile => null()
    integer :: ii,jj
    character*80 :: var80
    character*25 :: myname="model_peek"
    if(mod_bdeb)write(*,*)myname,' Entering.'
    if (.not.associated(css%firstFile)) then
       call model_initfilestack(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from stackinit.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    currentFile => css%lastFile%prev
    nrep=0
    if (.not.associated(currentFile,target=css%firstFile)) then
       ! file name
       nrep=min(maxrep,nrep+1)               ! file name  +1
       call chop0(currentFile%fn250,250)
       lenm=length(currentFile%fn250,250,20)
       rep250(nrep)="file"//sep//"name"//sep//currentFile%fn250(1:lenm)
       ! sorting variable is available
       call chop0(css%ind_var,80)
       lens=length(css%ind_var,80,10)
       if (lens.gt.0) then
          nrep=min(maxrep,nrep+1)             ! target value   +1
          rep250(nrep)="file"//sep//"index"//sep//"variable"//sep//css%ind_var(1:lens)
          write(s1,'(I0)') currentFile%nsort; call chop0(s1,50); len1=length(s1,50,10)
          nrep=min(maxrep,nrep+1)          ! sort values      +nsort
          rep250(nrep)="file"//sep//"index"//sep//"len"//&
               & sep//s1(1:len1)
          if (currentFile%nsort.gt.0) then
             write(s1,'(F17.5)') currentFile%ind_start; call chop0(s1,50); len1=length(s1,50,10)
             nrep=min(maxrep,nrep+1)          ! sort values      +nsort
             rep250(nrep)="file"//sep//"index"//sep//"start"//&
                  & sep//s1(1:len1)
             write(s1,'(F17.5)') currentFile%ind_stop; call chop0(s1,50); len1=length(s1,50,10)
             nrep=min(maxrep,nrep+1)          ! sort values      +nsort
             rep250(nrep)="file"//sep//"index"//sep//"stop"//&
                  & sep//s1(1:len1)
          end if
       end if
       ! dimensions
       write(s1,'(I12)') currentFile%ndim; call chop0(s1,50); len1=length(s1,50,10)
       do ii=1,currentFile%ndim
          write(s2,'(I12)') ii; call chop0(s2,50); len2=length(s2,50,10)
          call chop0(currentFile%dim80(ii),80)
          lend=length(currentFile%dim80(ii),80,10)
          nrep=min(maxrep,nrep+1)              ! dimension size  +currentFile%ndim
          write(rep250(nrep),*) currentFile%istop(ii)
          lenr=length(rep250(nrep),250,10)
          rep250(nrep)="file"//sep//"dimension"//sep//s2(1:len2)//sep// &
               & currentFile%dim80(ii)(1:lend)//sep//"size"//sep//rep250(nrep)(1:lenr)
       end do
       if(mod_bdeb)write(*,*)myname,' Near.'
       ! variables (name, dimensions)
       write(s1,'(I12)') currentFile%nvar; call chop0(s1,50); len1=length(s1,50,10)
       do ii=1,currentFile%nvar
          write(s1,'(I12)') ii; call chop0(s1,50);len1=length(s1,50,10)
          var80=currentFile%var(ii)%ptr%var80
          call chop0(var80,80)
          lenv=length(var80,80,10)
          if(mod_bdeb)write(*,*)myname,'VAR80:',var80(1:lenv),lenv
          write(s2,'(I12)') currentFile%var(ii)%ptr%ndim; call chop0(s2,50);len2=length(s2,50,10)
          nrep=min(maxrep,nrep+1)                 ! var index  +currentFile%nvar
          rep250(nrep)="file"//sep//"variable"//sep//s1(1:len1)//sep//"name"//sep//var80(1:lenv)
          do jj=1,currentFile%var(ii)%ptr%ndim
             write(s2,'(I12)') jj; call chop0(s2,50);len2=length(s2,50,10)
             s3= currentFile%dim80(currentFile%var(ii)%ptr%ind(jj))(1:50);call chop0(s3,50);len3=length(s3,50,10)
             nrep=min(maxrep,nrep+1)              ! dimension index  +currentFile%nvar * currentFile%var(ii)%ptr%ndim
             rep250(nrep)="file"//sep//"variable"//sep//s1(1:len1)//sep &
                  & //"dimension"//sep//s2(1:len2)//sep//s3(1:len3)
          end do
       end do
    end if

    !do ii=1,nrep
    !  lenr=length(rep250(ii),250,100)
    !  write(*,*) myname,'REP:',ii,maxrep,rep250(ii)(1:lenr)
    !end do

    if(mod_bdeb)write(*,*)myname,' Done.',maxrep,nrep
  end subroutine model_peek
  !
  !
  !###############################################################################
  ! STACK LOOP ROUTINES
  !###############################################################################
  ! Forecasts from one analysis is pready at a time... (=the same parameters)
  ! Used in this way
  ! 1) model_setFileStackLimits: make index limits of files in stack
  ! 2) model_loopFileStack: loop over files until false return...
  integer function model_getFileId(css)
    type(mod_session), pointer :: css !  current session
    model_getFileId=css%currentFileIndex
    return
  end function model_getFileId
  !
  logical function model_loopFileStack(css,mod_lval,mod_minval,mod_maxval,crc250,irc)
    type(mod_session), pointer :: css !  current session
    logical :: mod_lval(2)
    real :: mod_minval
    real :: mod_maxval
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_loopFileStack"
    logical :: bdone,found
    found=.false.
    bdone=(.not. css%sortLimitsOk)
    if (bdone) then ! index is not sorted..
       css%frm(1)=css%frm(1)+css%nFileIndexes ! no sort index
    else if (css%currentFileSortIndex.lt.css%leftFileSortIndex) then ! first
       css%fok(1)=css%fok(1)+css%nFileIndexes ! we have a sort index
       css%frm(2)=css%frm(2)+(css%leftFileSortIndex-1&
            & +css%nFileIndexes-css%rightFileSortIndex) ! outside index search
    end if
    do while (.not.bdone)
       css%currentFileSortIndex=max(css%currentFileSortIndex+1,css%leftFileSortIndex)
       if (css%currentFileSortIndex.gt.css%rightFileSortIndex) then ! last
          css%currentFileSortIndex=0
          css%currentFileIndex=0
          nullify(css%currentFile)
          bdone=.true.
       else
          css%currentFileIndex=css%fileStackInd(css%currentFileSortIndex,2)
          css%currentFile => css%fileStack(css%currentFileIndex)%ptr
          ! check if inside limits
          if (.not.((mod_lval(1).and.mod_minval.gt.css%currentFile%ind_stop) .or.&
               & (mod_lval(2).and.mod_maxval.lt.css%currentFile%ind_start)).and. &
               & .not.((css%ind_lval(1).and.css%ind_minval.gt.css%currentFile%ind_stop) .or.&
               & (css%ind_lval(2).and.css%ind_maxval.lt.css%currentFile%ind_start))) then
             if (model_rangeCheck(css,crc250,irc)) then
                ! write(*,*)myname,'Passed check:',css%currentFileSortIndex,associated(css%currentFile), &
                ! &   'min:',mod_lval(1),mod_minval,css%currentFile%ind_stop,&
                ! &   'max:',mod_lval(2),mod_maxval,css%currentFile%ind_start, &
                ! & ' MIN:',css%ind_lval(1),css%ind_minval,css%currentFile%ind_stop, &
                ! & ' MAX:',css%ind_lval(2),css%ind_maxval,css%currentFile%ind_start       
                found=.true.
                bdone=.true.
                css%fok(3)=css%fok(3)+1 ! within target range
             else
                css%frm(3)=css%frm(3)+1 ! outside target range
             end if
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from model_rangeCheck.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             if (mod_bdeb) write(*,*)myname,' Found:',css%sortLimitsOk,&
                  & css%currentFileSortIndex,css%leftFileSortIndex,css%rightFileSortIndex
             css%fok(2)=css%fok(2)+1 ! within index search
          else
             css%frm(2)=css%frm(2)+1 ! outside index search
          end if
       end if
    end do
    !write(*,*)myname,'Index:',css%currentFileSortIndex,found
    model_loopFileStack=found
    return
  end function model_loopFileStack
  !
  ! check if we immediately know that current file is outside target limits
  !
  logical function model_rangeCheck(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: ii
    character*250 :: crc250
    integer :: irc
    logical :: bdone,found
    integer :: itrg
    type(mod_file),pointer :: f
    type(mod_variable),pointer :: v
    integer :: ff
    character*22 :: myname="model_rangeCheck"
    ! check if we have targets with limits set
    model_rangeCheck=.true. ! file is ok
    if (.not. associated(css%currentFile)) return ! no current file
    f => css%currentFile  ! file
    if(mod_bdeb)write(*,*)myname,"Checking file '"//&
         & f%fn250(1:f%lenf)//"'"
    LOOP: do ii=1,f%nvar ! loop over file variables
       v => f%var(ii)%ptr ! variable
       if (.not.associated(v)) cycle              ! no variable
       TRG: do itrg=1,css%ctrg ! loop over targets
          if (css%trg_v80(itrg)(1:css%trg_lenv(itrg)).ne.v%var80(1:v%lenv)) then
             !write(*,*)myname,"No match '"//css%trg_v80(itrg)(1:css%trg_lenv(itrg))//&
             !     "' != '"//v%var80(1:v%lenv)//"'"
             cycle TRG      ! no match
          end if
          ff=css%trg_offset(itrg)
          if (css%trg_minset(itrg).or.css%trg_maxset(itrg)) then !check max/min
             ! get variable          
             if (v%mmrange) then ! we have limits
                if (model_variableCheck(css,v,itrg)) then ! target range check
                   if(mod_bdeb)write(*,*)myname,"Passed '"//&
                        & v%var80(1:v%lenv)//"'",&
                        & itrg, v%mmrange,v%mmset,v%minval,v%maxval,&
                        & css%trg_minset(itrg),css%trg_maxset(itrg),&
                        & css%trg_minval(itrg),css%trg_maxval(itrg)
                   css%trg_fok(itrg)=css%trg_fok(itrg)+1
                else ! failed range check
                   if(mod_bdeb)write(*,*)myname,"Failed '"//&
                        & v%var80(1:v%lenv)//"'",&
                        & itrg, v%mmrange,v%mmset,v%minval,v%maxval,&
                        & css%trg_minset(itrg),css%trg_maxset(itrg),&
                        & css%trg_minval(itrg),css%trg_maxval(itrg)
                   model_rangeCheck=.false. 
                   css%trg_frm(itrg)=css%trg_frm(itrg)+1
                   exit LOOP
                end if
             end if
          end if
       end do TRG
    end do LOOP
    !write(*,*)myname,'Running checks...',model_rangeCheck,f%nvar
    if (model_rangeCheck) then
       css%trg_fok(0)=css%trg_fok(0)+1
    else
       css%trg_frm(0)=css%trg_frm(0)+1
    end if
    return
  end function model_rangeCheck
  !
  ! Check that variable max/min is within target limits...
  !
  logical function model_variableCheck(css,v,itrg)
    type(mod_session), pointer :: css !  current session
    type(mod_variable), pointer :: v
    integer :: itrg
    model_variableCheck=.true. ! all ok so far...
    if (v%mmset) then ! range is set
       if (css%trg_minset(itrg)) then
          if (v%maxval.lt.css%trg_minval(itrg)) then
             model_variableCheck=.false.
          end if
       end if
       if (css%trg_maxset(itrg)) then
          if (v%minval.gt.css%trg_maxval(itrg)) then
             model_variableCheck=.false.
          end if
       end if
    end if
    return
  end function model_variableCheck
  !
  ! sort the file stack
  !
  subroutine model_sortStack(css,crc250,irc)
    use sort
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(mod_file), pointer :: currentFile => null()
    integer :: ii,jj
    character*25 :: myname="model_sortStack"
    !
    ! make array of files
    if(mod_bdeb)write(*,*)myname,' Entering.'
    if (associated(css%fileStack)) deallocate(css%fileStack)
    if (allocated(css%fileStackSort)) deallocate(css%fileStackSort)
    if (allocated(css%fileStackInd)) deallocate(css%fileStackInd)
    if (mod_bdeb) write(*,*)myname,'Allocating sort stack:',css%nFileIndexes
    allocate(css%fileStack(max(1,css%nFileIndexes)),css%fileStackSort(max(1,css%nFileIndexes),2),&
         &css%fileStackInd(max(1,css%nFileIndexes),2),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from allocate (")
       call model_errorappendi(crc250,css%nFileIndexes)
       call model_errorappend(crc250,")")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    css%msort=0 ! max number of forecasts
    currentFile => css%firstFile%next
    ii=0
    do while (.not.associated(currentFile, target=css%lastFile))
       css%msort=max(css%msort,currentFile%nsort)
       ii=ii+1
       if (ii.le.css%nFileIndexes) then
          css%fileStack(ii)%ptr => currentFile
          if (currentFile%ind_lim) then
             css%fileStackInd(ii,1)=ii
             css%fileStackInd(ii,2)=ii
             css%fileStackSort(ii,1)=currentFile%ind_start
             css%fileStackSort(ii,2)=currentFile%ind_stop
          else ! no index available for file
             if (mod_bdeb)then
                write(*,*)myname,"Missing index limits in '"//&
                     & currentFile%fn250(1:currentFile%lenf)//&
                     & "', ignoring file."
                write(*,*)myname,'Indexes ',currentFile%ind_lim,&
                     & currentFile%ind_start,currentFile%ind_stop
             end if
             ii=ii-1 ! ignore file...
          end if
       end if
       currentFile => currentFile%next
    end do
    if (ii.ne.css%nFileIndexes) then
       irc=944
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Missing indexes:")
       call model_errorappendi(crc250,css%nFileIndexes)
       call model_errorappend(crc250,"!=")
       call model_errorappendi(crc250,ii)
       call model_errorappend(crc250,"\n")
       return
    end if
    ! make sorted index (chronologically)
    css%nFileSortIndexes=css%nFileIndexes
    css%newnFileSortIndexes(1)=css%nFileIndexes
    css%newnFileSortIndexes(2)=css%nFileIndexes
    call sort_heapsort1r(css%nFileIndexes,css%fileStackSort(1,1),1.0D-5,&
         & css%newnFileSortIndexes(1),css%nFileSortIndexes,css%fileStackInd(1,1),.false.)
    call sort_heapsort1r(css%nFileIndexes,css%fileStackSort(1,2),1.0D-5,&
         & css%newnFileSortIndexes(2),css%nFileSortIndexes,css%fileStackInd(1,2),.false.)
    css%fileReady = .true.
    if(mod_bdeb)then
       if (css%nFileSortIndexes.eq.1) then
          write(*,*)myname,' Done.',css%fileStackSort(1,1),css%fileStackSort(1,2)
       else
          write(*,*)myname,' Done.',css%nFileSortIndexes
       end if
    end if
    
    return
  end subroutine model_sortStack
  !
  subroutine model_findStackLimits(css,ind_lval,ind_minval,ind_maxval,crc250,irc)
    use sort
    type(mod_session), pointer :: css !  current session
    logical :: ind_lval(2)
    real :: ind_minval
    real :: ind_maxval
     character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_findStackLimits"
    integer :: leftmin,rightmin,leftmax,rightmax
    logical :: mod_lval(2)
    real :: mod_minval
    real :: mod_maxval
    if (mod_bdeb)write(*,*)myname,'Entering, Number of files:',css%nFileIndexes
    if (mod_bdeb)write(*,*)myname,'Initial Range:',ind_lval,ind_minval,ind_maxval
    mod_lval(1)=ind_lval(1)
    mod_minval=ind_minval
    if (mod_lval(1).and.css%ind_lval(1)) then
       mod_minval=max(mod_minval,css%ind_minval)
    else if (css%ind_lval(1)) then
       mod_lval(1)=.true.
       mod_minval=css%ind_minval
    end if
    mod_lval(2)=ind_lval(2)
    mod_maxval=ind_maxval
    if (mod_lval(2).and.css%ind_lval(2)) then
       mod_maxval=min(mod_maxval,css%ind_maxval)
    else if (css%ind_lval(2)) then
       mod_lval(2)=.true.
       mod_maxval=css%ind_maxval
    end if
    if (mod_bdeb)write(*,*)myname,'Final Range:  ',mod_lval,mod_minval,mod_maxval
    if (mod_lval(1)) then
       call sort_heapsearch1r(css%nFileIndexes,css%fileStackSort(1,2),1.0D-5, &
            & css%nFileSortIndexes,css%fileStackInd(1,2),mod_minval,leftmin,rightmin)
       rightmin=max(leftmin,rightmin) ! ignore before first entry
       if (mod_bdeb) write(*,*)myname,' Minval:',mod_minval,&
            & css%fileStackSort(1,2),css%fileStackInd(1,2),&
            & leftmin,rightmin
    else
       leftmin=1
       rightmin=1
    end if
    if (mod_lval(2)) then
       call sort_heapsearch1r(css%nFileIndexes,css%fileStackSort(1,1),1.0D-5, &
            & css%nFileSortIndexes,css%fileStackInd(1,1),mod_maxval,leftmax,rightmax)
       leftmax=min(rightmax,leftmax) ! ignore after last entry
       if (mod_bdeb) write(*,*)myname,' Maxval:',mod_maxval,&
            & css%fileStackSort(1,1),css%fileStackInd(1,1),&
            & leftmax,rightmax
    else
       leftmax=css%nFileSortIndexes
       rightmax=css%nFileSortIndexes
    end if
    if (mod_bdeb)write(*,'(X,A,X,A,5(X,I0))')myname,'Limits.', &
         & leftmin,rightmin,leftmax,rightmax,css%nFileSortIndexes
    css%sortLimitsOk= (leftmin.le.css%nFileSortIndexes.and.rightmax.ge.1) ! check for overlap...
    if (css%sortLimitsOk) then
       css%leftFileSortIndex=min(leftmin,rightmin)
       css%rightFileSortIndex=max(leftmax,rightmax)
    else
       css%leftFileSortIndex=0
       css%rightFileSortIndex=0
    end if
    css%currentFileIndex=0
    if (mod_bdeb)write(*,*)myname,' Done.', css%sortLimitsOk,&
         & css%leftFileSortIndex, css%rightFileSortIndex,css%nFileIndexes
    return
  end subroutine model_findStackLimits
  !
  !###############################################################################
  ! CACHE ROUTINES
  !###############################################################################
  !
  subroutine model_makecache(css,path250,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(mod_file), pointer :: currentFile !  current file
    integer, external :: length,ftunit
    integer :: lenp,lenf,lenv,lend,unitr,ii,jj,kk
    character*22 :: myname="model_makeCache"
    character*50 :: minval50,maxval50
    integer :: lenmi,lenma,leno,cnt
    character*250 :: old250
    integer :: ook(10), orm(10)
    real :: pst(10)
    character*80 :: buff80
    if(mod_bdeb)write(*,*) myname,' Entering.',irc
    call chop0(path250,250)
    lenp=length(path250,250,20)
    if(mod_bdeb)write(*,*)myname,' Path.',path250(1:lenp)
    ! open file
    unitr=ftunit(irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," no free unit number for "//path250(1:lenp))
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    lenp=length(path250,250,10)
    open ( unit=unitr, status="unknown", form="formatted", &
         &        access="sequential", &
         &        iostat=irc, file=path250(1:lenp) )
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," unable to open "//path250(1:lenp))
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    call model_makeTargetList(css,crc250,irc) 
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from makeTargetList.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    call model_sortStack(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from sortStack.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    do ii=1,10
       ook(ii)=0
       orm(ii)=0
    end do
    ! write number of files: css%nFileIndexes
    if(mod_bdeb)write(*,*) myname,' Stack entries.',css%nFileIndexes,unitr
    leno=0
    cnt=0
    do ii=1,css%newnFileSortIndexes(1)
       if (css%fileStackInd(ii,1).eq.0) cycle
       currentFile=>css%fileStack(css%fileStackInd(ii,1))%ptr
       if (old250(1:leno).ne.currentFile%fn250(1:currentFile%lenf)) then
          cnt=cnt+1
       end if
       old250=currentFile%fn250
       leno=currentFile%lenf
    end do
    if(mod_bdeb)write(*,*) myname,' Stack cnt.',cnt,&
         & css%newnFileSortIndexes(1),size(css%fileStackInd(:,1))
    write(unitr,'(I0,8(X,I0))',iostat=irc) cnt,css%values
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," unable to write to "//path250(1:lenp))
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    write(*,'(X,A,A,I0,A,I4.4,6(A,I2.2))')myname," Index '"//path250(1:lenp)//&
         & "' contains ",cnt," files. Modified:", &
         & css%values(1),"-",css%values(2),"-",css%values(3),"T",&
         & css%values(5),":",css%values(6),":",css%values(7)
    ! loop over file stack
    leno=0
    cnt=0
    do ii=1,css%newnFileSortIndexes(1)
       !if(mod_bdeb)write(*,*) myname,' Loop.',ii
       if (css%fileStackInd(ii,1).eq.0) cycle
       currentFile=>css%fileStack(css%fileStackInd(ii,1))%ptr
       if (old250(1:leno).ne.currentFile%fn250(1:currentFile%lenf)) then
          cnt=cnt+1
          lenf=currentFile%lenf
          write(unitr,'(L1,5(X,I0),X,A)',iostat=irc) &
               & currentFile%ind_lim,&
               & currentFile%tsort,&
               & currentFile%nsort,&
               & currentFile%ndim,&
               & currentFile%nvar,&
               & currentFile%lenf,&
               & currentFile%fn250(1:LENF)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to read file 01.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          ! write category summary
          do jj=1,currentFile%nsort
             lend=length(currentFile%desc250(jj),250,5)
             write(unitr,'(X,F0.10,X,I0,X,A)',iostat=irc) &
                  & currentFile%sort(jj),&
                  & currentFile%indsort(jj),&
                  & currentFile%desc250(jj)(1:lend)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Unable to read file 02.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
          end do
          do jj=1,currentFile%ndim
             buff80=currentFile%dim80(jj)
             call encode(buff80)
             !call chop0(currentFile%var(jj)%ptr%var80,80)
             lend=length(buff80,80,5)
             write(unitr,'(X,I0,X,A)',iostat=irc) currentFile%istop(jj),&
                  & buff80(1:lend)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Unable to read file 03.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
          end do
          do jj=1,currentFile%nvar
             buff80=currentFile%var(jj)%ptr%var80
             call encode(buff80)
             !call chop0(currentFile%var(jj)%ptr%var80,80)
             lenv=length(buff80,80,5)
             write(unitr,'(I0,X,A)',advance="no",iostat=irc) &
                  & currentFile%var(jj)%ptr%ndim,buff80(1:lenv)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Unable to write to file 01.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             do kk=1,currentFile%var(jj)%ptr%ndim
                write(unitr,'(X,I0)',advance="no",iostat=irc) currentFile%var(jj)%ptr%ind(kk)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Unable to write to file 02.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
             end do
             write(unitr,'(X,L1)',advance="no",iostat=irc) &
                  & currentFile%var(jj)%ptr%mmrange
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Unable to write to file 03.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             if (currentFile%var(jj)%ptr%mmrange) then
                write(unitr,'(X,L1)',advance="no",iostat=irc) &
                     & currentFile%var(jj)%ptr%mmset
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Unable to write to file 04.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
                if (currentFile%var(jj)%ptr%mmset) then
                   call model_wash(currentFile%var(jj)%ptr%minval,minval50,lenmi)
                   call model_wash(currentFile%var(jj)%ptr%maxval,maxval50,lenma)
                   write(unitr,'(X,A,X,A)',iostat=irc) minval50(1:lenmi),maxval50(1:lenma)
                else
                   write(unitr,*,iostat=irc)
                end if
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Unable to write to file 05.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
             else
                write(unitr,*,iostat=irc)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Unable to write to file 06.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
             end if
          end do
          if (currentFile%ind_lim) then
             write(*,'(2X,A," <",F0.1,",",F0.1,">")') currentFile%fn250(1:currentFile%lenf),&
                  & currentFile%ind_start,currentFile%ind_stop
          else
             write(*,'(2X,A," <*,*>")') currentFile%fn250(1:currentFile%lenf)
          end if
       end if
       old250=currentFile%fn250
       leno=currentFile%lenf
    end do
    if(mod_bdeb)write(*,*) myname,' Closing.',cnt,css%newnFileSortIndexes(1)
    ! close file
    close(unitr,iostat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," unable to close "//path250(1:lenp))
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Done, files in stack:',css%nFileIndexes,irc
    if(mod_bdeb)write(*,*)myname,' Done.',irc
  end subroutine model_makecache
  !
  ! load cache file
  !
  subroutine model_loadcache(css,path250,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(mod_file), pointer :: cfile, cfilen
    type(mod_file),pointer :: newFile
    integer, external :: length
    integer :: lenp,lenb,lend,ii,jj,kk,opos,pos,unitr,cnt
    type(mod_variable),pointer :: v     ! variable
    character*250 :: buff250
    character*1 :: c1
    character*22 :: myname="model_loadCache"
    integer :: values(8),yy,mm,dd,hh,mi
    real :: sec, f2000,s2000
    character*250 :: diff250
    logical :: bok
    if(mod_bdeb)write(*,*) myname,' Entering.',irc
    call chop0(path250,250)
    lenp=length(path250,250,20)
    ! clear existing cache
    css%fileReady=.false.
    if (associated(css%firstFile)) then
       cfile => css%firstFile%next
       do while (.not.associated(cfile,target=css%lastFile))
          cfilen => cfile%next
          call model_deleteFile(css,cfile,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from deleteFile.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          cfile  => cfilen
       end do
    end if
    ! open cache file
    if(mod_bdeb)write(*,*)myname," Opening modcache: '",path250(1:lenp)//"'"
    open ( unit=unitr, status="old", form="formatted", &
         &        access="sequential", &
         &        iostat=irc, file=path250(1:lenp) )
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," unable to open "//path250(1:lenp))
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    ! write number of files: css%nFileIndexes
    read(unitr,'(A)',iostat=irc) buff250
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," unable to read "//path250(1:lenp))
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    cnt=0
    read(buff250,*,iostat=irc) css%nFileIndexes,values
    if (irc.ne.0) then
       if (mod_bdeb) write(*,*) myname," Unable to interprt nfileindexes."
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Corrupt index file "//path250(1:lenp))
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    ! loop through cache file
    if (mod_bdeb)write(*,*)myname,'Looking for files:',css%nFileIndexes
    do ii=1,css%nFileIndexes
       !if (mod_bdeb) write(*,*) myname," file loop started.",ii,css%nFileIndexes
       bok=.true.
       allocate(newFile,stat=irc)
       if (irc.ne.0) then
          if (mod_bdeb) write(*,*) myname," Unable to allocate new File item."
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to allocate new File item.")
          call model_errorappend(crc250,"\n")
          return
       end if
       css%fileReady=.false.
       newFile%prev => css%lastFile%prev
       newFile%next => css%lastFile
       newFile%prev%next => newFile
       newFile%next%prev => newFile
       !
       !if (mod_bdeb) write(*,*) myname," reading index.",ii
       read(unitr,'(A)',iostat=irc) buff250
       if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read new line."
       call chop0(buff250,250)
       lenb=length(buff250,250,10)
       pos=0
       opos=pos
       call findDelimiter(buff250(1:lenb)," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%ind_lim
       if(bok)bok=(irc.eq.0)
       if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' ind_lim"
       opos=pos
       call findDelimiter(buff250(1:lenb)," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%tsort
       if(bok)bok=(irc.eq.0)
       if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' tsort"
       opos=pos
       call findDelimiter(buff250(1:lenb)," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%nsort
       if(bok)bok=(irc.eq.0)
       if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' nsort"
       opos=pos
       call findDelimiter(buff250(1:lenb)," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%ndim
       if(bok)bok=(irc.eq.0)
       if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' ndim"
       opos=pos
       call findDelimiter(buff250(1:lenb)," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%nvar 
       if(bok)bok=(irc.eq.0)
       if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' nvar"
       opos=pos
       call findDelimiter(buff250(1:lenb)," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%lenf
       if(bok)bok=(irc.eq.0)
       if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' lenf"
       opos=pos
       pos=251 ! call findDelimiter(buff250(1:lenb)," ",pos)
       newFile%fn250=buff250(opos+1:pos-1)
       !
       allocate(newFile%sort(newFile%nsort),newFile%indsort(newFile%nsort),newFile%desc250(newFile%nsort),stat=irc)
       if (irc.ne.0) then
          if (mod_bdeb) write(*,*) myname," Unable to allocate new Sort item."
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to allocate new Sort item.")
          call model_errorappend(crc250,"\n")
          return
       end if
       !if (mod_bdeb) write(*,*) myname," reading sort."
       do jj=1,newFile%nsort
          read(unitr,'(A)',iostat=irc) buff250
          if(bok)bok=(irc.eq.0)
          if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read new line."
          call chop0(buff250,250)
          lenb=length(buff250,250,10)
          pos=0
          opos=pos
          call findDelimiter(buff250(1:lenb)," ",pos)
          read(buff250(opos+1:pos-1),*,iostat=irc)newFile%sort(jj)
          if(bok)bok=(irc.eq.0)
          if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' sort(",jj,")"
          opos=pos
          call findDelimiter(buff250(1:lenb)," ",pos)
          read(buff250(opos+1:pos-1),*,iostat=irc)newFile%indsort(jj)
          if(bok)bok=(irc.eq.0)
          if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' indsort(",jj,")"
          opos=pos
          pos=251 ! call findDelimiter(buff250(1:lenb)," ",pos)
          newFile%desc250(jj)=buff250(opos+1:pos-1)
          if (jj.eq.1) then
             newFile%ind_start=newFile%sort(jj)
             newFile%ind_stop=newFile%sort(jj)
          else
             newFile%ind_start=min(newFile%ind_start,newFile%sort(jj))
             newFile%ind_stop=max(newFile%ind_stop,newFile%sort(jj))
          end if
       end do
       !
       if (mod_bdeb) then
          if (newFile%ind_lim) then
             write(*,'(X,A,X,A,I0,X,"<",F0.1,",",F0.1,">")') myname,&
                  & "loaded:'"//newFile%fn250(1:newFile%lenf)//"'",ii,newFile%ind_start,newfile%ind_stop
          else
              write(*,'(X,A,X,A,I0,X,"<*,*>")') myname,&
                  & "loaded:'"//newFile%fn250(1:newFile%lenf)//"'",ii
         end if
       end if
          !
       allocate(newFile%istart(newFile%ndim),newFile%istop(newFile%ndim),&
            & newFile%dim80(newFile%ndim),newFile%dim_var(newFile%ndim),&
            & newFile%dim_val(newFile%ndim),newFile%dim_trg(newFile%ndim),&
            & newFile%var80(newFile%nvar),newFile%lenv(newFile%nvar),stat=irc)
       if (irc.ne.0) then
          if (mod_bdeb) write(*,*) myname," Unable to allocate new sort item."
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to allocate new Sort item.")
          call model_errorappend(crc250,"\n")
          return
       end if
       !if (mod_bdeb) write(*,*) myname," reading dims."
       do jj=1,newFile%ndim
          read(unitr,'(A)',iostat=irc) buff250
          if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read new line."
          call chop0(buff250,250)
          lenb=length(buff250,250,10)
          pos=0
          opos=pos
          call findDelimiter(buff250(1:lenb)," ",pos)
          read(buff250(opos+1:pos-1),*,iostat=irc)newFile%istop(jj)
          if(bok)bok=(irc.eq.0)
          if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' istop(",jj,")"
          newFile%istart(jj)=1
          opos=pos
          pos=251 ! call findDelimiter(buff250(1:lenb)," ",pos)
          newFile%dim80(jj)=buff250(opos+1:min(opos+80,pos-1))
          call chop0(newFile%dim80(jj),80)
          call decode(newFile%dim80(jj))
          lend=length(newFile%dim80(jj),80,10)
          newFile%dim_var(jj)=newFile%dim80(jj)(1:lend)
          newFile%dim_val(jj)=real(newFile%istop(jj))
          newFile%dim_trg(jj)=0
       end do
       allocate(newFile%var(newFile%nvar),stat=irc)
       if (irc.ne.0) then
          if (mod_bdeb) write(*,*) myname," Unable to allocate new var item."
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to allocate new Var item.")
          call model_errorappend(crc250,"\n")
          return
       end if
       !if (mod_bdeb) write(*,*) myname," reading vars."
       do jj=1,newFile%nvar
          allocate(newFile%var(jj)%ptr,stat=irc)
          if (irc.ne.0) then
             if (mod_bdeb) write(*,*) myname," Unable to allocate new var ptr."
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to allocate new Var item.")
             call model_errorappend(crc250,"\n")
             return
          end if
          v => newFile%var(jj)%ptr
          read(unitr,'(A)',iostat=irc) buff250
          if(bok)bok=(irc.eq.0)
          if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read new line."
          call chop0(buff250,250)
          lenb=length(buff250,250,10)
          pos=0
          opos=pos
          call findDelimiter(buff250(1:lenb)," ",pos)
          read(buff250(opos+1:pos-1),*,iostat=irc)v%ndim
          if(bok)bok=(irc.eq.0)
          if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' ndim"
          opos=pos
          call findDelimiter(buff250(1:lenb)," ",pos)
          v%var80=buff250(opos+1:min(80+opos,pos-1))
          call chop0(v%var80,80)
          call decode(v%var80)
          v%lenv=length(v%var80,80,pos-opos-1)
          newFile%var80(jj)=v%var80
          newFile%lenv(jj)=v%lenv
          allocate(v%ind(v%ndim),v%istart(v%ndim),v%icount(v%ndim),stat=irc)
          if (irc.ne.0) then
             if (mod_bdeb) write(*,*) myname," Unable to allocate new var dim."
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to allocate new Var dim item.")
             call model_errorappendi(crc250,jj)
             call model_errorappendi(crc250,v%ndim)
             call model_errorappend(crc250,"\n")
             return
          end if
          do kk=1,v%ndim
             opos=pos
             call findDelimiter(buff250(1:lenb)," ",pos)
             read(buff250(opos+1:pos-1),*,iostat=irc) v%ind(kk)
             if(bok)bok=(irc.eq.0)
             if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' ind(",kk,")"
          end do
          opos=pos
          call findDelimiter(buff250(1:lenb)," ",pos)
          c1=buff250(opos+1:max(opos+1,min(opos+2,pos-1)))
          v%mmrange=(c1.eq."T")
          if (v%mmrange) then
             opos=pos
             call findDelimiter(buff250(1:lenb)," ",pos)
             v%mmset=(buff250(opos+1:pos-1).eq."T")
          else
             v%mmset=.false.
          end if
          if (v%mmset) then
             opos=pos
             call findDelimiter(buff250(1:lenb)," ",pos)
             read(buff250(opos+1:pos-1),*,iostat=irc)v%minval
             if(bok)bok=(irc.eq.0)
             if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' minval"
             opos=pos
             call findDelimiter(buff250(1:lenb)," ",pos)
             read(buff250(opos+1:pos-1),*,iostat=irc)v%maxval
             if(bok)bok=(irc.eq.0)
             if(mod_bdeb.and.irc.ne.0)write(*,*)myname,"Unable to read:'"//buff250(opos+1:pos-1)//"' maxval"
          end if
       end do
       if (bok) then
          cnt=cnt+1
          nullify(newFile)
       else
          irc=0
          if (mod_bdeb)write(*,*)myname,'System error! Deleting Invalid entry:',ii
          call model_deleteFile(css,newFile,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from deleteFile.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       end if
       !if (mod_bdeb) write(*,*) myname," file loop ended.",ii,css%nFileIndexes
    end do
    ! close file
    close(unitr,iostat=irc)
    if (irc.ne.0) then
       if (mod_bdeb) write(*,*) myname," Unable to close "//path250(1:lenp)
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," unable to close "//path250(1:lenp))
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    css%nFileIndexes=cnt! should not be necessary...
    yy=css%values(1)
    mm=css%values(2)
    dd=css%values(3)
    hh=css%values(5)
    mi=css%values(6)
    sec=css%values(7)
    call jd2000(s2000,yy,mm,dd,hh,mi,sec)
    yy=values(1)
    mm=values(2)
    dd=values(3)
    hh=values(5)
    mi=values(6)
    sec=values(7)
    call jd2000(f2000,yy,mm,dd,hh,mi,sec)
    diff250=model_diff(s2000-f2000)
    lend=length(diff250,250,10)
    write(*,'(X,A,A,I0,A,I4.4,6(A,I2.2),A)')myname," Index '"//path250(1:lenp)//&
         & "' contains ",css%nFileIndexes," files. Modified:", &
         & values(1),"-",values(2),"-",values(3),"T",&
         & values(5),":",values(6),":",values(7),". Age:"//diff250(1:lend)
    if(mod_bdeb)write(*,*)myname,' Done, files in stack:',css%nFileIndexes,irc
  end subroutine model_loadcache
  !
  !
  !###############################################################################
  ! TARGET ROUTINES (used for slicing fields)
  !###############################################################################
  !
  ! clear the target stack
  !
  subroutine model_cleartargetStack(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(mod_target), pointer :: currentTarget => null() !  current session
    type(mod_target), pointer :: nextTarget => null() !  current session
    character*25 :: myname="model_cleartargetstack"
    currentTarget => css%firstTrg%next
    do while (.not.associated(currentTarget,target=css%lastTrg))
       nextTarget => currentTarget%next
       currentTarget%prev%next =>  currentTarget%next
       currentTarget%next%prev =>  currentTarget%prev
       deallocate(currentTarget,stat=irc)
       css%ntrg=css%ntrg-1
       currentTarget => nextTarget
    end do
    css%trg_set=.false.
    return
  end subroutine model_cleartargetstack
  !
  ! push target to the stack
  !
  subroutine model_pushtarget(css,n80,v80,min80,max80,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*80 :: n80        ! target name
    character*80 :: v80        ! variable
    character*80 :: min80        ! lower value
    character*80 :: max80        ! upper value
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    integer :: lenn
    type(mod_target), pointer :: newTarget !  the new target
    character*25 :: myname="model_pushtarget"
    call chop0(n80,80)
    lenn=length(n80,80,10)
    allocate(newtarget,stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'target'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    newTarget%n80=n80
    newTarget%lenn=lenn
    newTarget%v80=v80
    newTarget%min80=min80
    newTarget%max80=max80
    css%ntrg=css%ntrg+1
    newTarget%prev => css%lastTrg%prev
    newTarget%next => css%lastTrg
    newTarget%prev%next => newTarget
    newTarget%next%prev => newTarget
    css%trg_set=.false.
    if(mod_bdeb)write(*,*)myname,"Target: '"//n80(1:lenn)//"'",css%ntrg
    return
  end subroutine model_pushtarget
  !
  logical function model_loopTarget(css,n80,v80,min80,max80,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    character*80  :: n80       ! target name
    character*80  :: v80       ! variable
    character*80  :: min80      ! min value
    character*80  :: max80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_loopTarget"
    model_looptarget=.false. ! only true if all is ok...
    if (.not.associated(css%currentTrg)) then
       css%currentTrg =>  css%firstTrg%next 
    else
       css%currentTrg =>  css%currentTrg%next
    end if
    if (associated(css%currentTrg,css%lastTrg)) then
       nullify(css%currentTrg)
       model_loopTarget=.false.
    else
       n80=css%currentTrg%n80
       v80=css%currentTrg%v80
       min80=css%currentTrg%min80
       max80=css%currentTrg%max80
       model_looptarget=.true.
    end if
    return
  end function model_loopTarget
  !
  ! make target a slice variable
  !
  subroutine model_settargetslice(css,n80,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*80 :: n80        ! target name
    character*250 :: crc250
    integer :: irc
    type(mod_target), pointer :: ctrg !  the new target
    character*25 :: myname="model_settargetslice"
    integer, external :: length
    integer :: lenn
    lenn=length(n80,80,10)
    if(mod_bdeb)write(*,*)myname,'Make slice of target: ',n80(1:lenn)
    ctrg => css%firstTrg%next
    do while (.not.associated(ctrg,target=css%lastTrg))
       if (ctrg%n80(1:ctrg%lenn).eq.n80(1:lenn)) then
          ctrg%lslice=.true.
          return
       end if
       ctrg=>ctrg%next
    end do
    return
  end subroutine model_settargetslice
  !
  ! get number of targets
  !
  integer function model_targetCount(css,crc250,irc)
    type(mod_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_targetCount "
    model_targetCount=css%ntrg
    return
  end function model_targetCount
  !
  integer function model_trgCount(css,crc250,irc)
    type(mod_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_trgCount "
    model_trgCount=css%otrg
    return
  end function model_trgCount
  !
  ! get number of locations
  !
  integer function model_locationCount(css,crc250,irc)
    type(mod_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_locationCount "
    model_locationCount=css%oloc
    return
  end function model_locationCount
  !
  ! make target list
  !
  subroutine model_getTrg80(css,var80,oo,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*80, allocatable :: var80(:)
    integer :: oo !
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_getTrg80"
    integer ii
    do ii=1,css%ctrg
       var80(ii+oo)=css%trg80(ii)
    end do
    return
  end subroutine model_getTrg80
  !
  ! get output values
  !
  subroutine model_getVal(css,iloc,val,oo,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: iloc
    real, allocatable :: val(:)
    integer :: oo
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_getVal"
    integer ii
    do ii=1,css%otrg
       if (css%oset(ii,iloc)) then
          val(ii+oo)=css%oval(ii,iloc)
       else
          val(ii+oo)=0.0D0
       end if
    end do
    return
  end subroutine model_getVal
  !
  ! update the session list over variables etc. on the target stack
  !
  subroutine model_cleartargetlist(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    if (associated(css%trg80)) deallocate(css%trg80)
    if (associated(css%trg_lent)) deallocate(css%trg_lent)
    if (associated(css%trg_v80)) deallocate(css%trg_v80)
    if (associated(css%trg_lenv)) deallocate(css%trg_lenv)
    if (associated(css%trg_offset)) deallocate(css%trg_offset)
    if (associated(css%trg_dim)) deallocate(css%trg_dim)
    if (associated(css%trg_var)) deallocate(css%trg_var)
    if (associated(css%trg_type)) deallocate(css%trg_type)
    if (associated(css%trg_min80)) deallocate(css%trg_min80)
    if (associated(css%trg_max80)) deallocate(css%trg_max80)
    if (associated(css%trg_minval)) deallocate(css%trg_minval)
    if (associated(css%trg_maxval)) deallocate(css%trg_maxval)
    if (associated(css%trg_sliceset)) deallocate(css%trg_sliceset)
    if (associated(css%trg_valset)) deallocate(css%trg_valset)
    if (associated(css%trg_minset)) deallocate(css%trg_minset)
    if (associated(css%trg_maxset)) deallocate(css%trg_maxset)
    if (associated(css%trg_req)) deallocate(css%trg_req)
    if (associated(css%trg_vok)) deallocate(css%trg_vok)
    if (associated(css%trg_val)) deallocate(css%trg_val)
    if (associated(css%trg_ook)) deallocate(css%trg_ook)
    if (associated(css%trg_orm)) deallocate(css%trg_orm)
    if (associated(css%trg_fok)) deallocate(css%trg_fok)
    if (associated(css%trg_frm)) deallocate(css%trg_frm)
    css%trg_set=.false.
    if (allocated(css%mpo_var)) deallocate(css%mpo_var)
    if (allocated(css%mpo_lenv)) deallocate(css%mpo_lenv)
    if (allocated(css%mpo_req)) deallocate(css%mpo_req)
    if (allocated(css%mpo_vok)) deallocate(css%mpo_vok)
    if (allocated(css%mpo_val)) deallocate(css%mpo_val)
    css%mpo_set=.false.
    return
  end subroutine model_cleartargetlist
  subroutine model_maketargetlist(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_maketargetlist"
    type(mod_target), pointer :: currentTarget
    integer ii,lens,irc2
    integer, external :: length
    type(parse_session),pointer :: plim => null()  ! parse_session pointer must be set to null
    if(mod_bdeb)write(*,*)myname,'Entering.',irc,css%trg_set,css%ntrg
    if ( .not. css%trg_set ) then
       call parse_open(plim,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from parse_open.")
          return
       end if
       css%ctrg=css%ntrg
       if (css%ind_set) css%ctrg=css%ctrg+1
       if(associated(css%trg80)) deallocate(css%trg80)
       if(associated(css%trg_lent)) deallocate(css%trg_lent)
       if(associated(css%trg_v80)) deallocate(css%trg_v80)
       if(associated(css%trg_lenv)) deallocate(css%trg_lenv)
       if(associated(css%trg_offset)) deallocate(css%trg_offset)
       if(associated(css%trg_dim)) deallocate(css%trg_dim)
       if(associated(css%trg_var)) deallocate(css%trg_var)
       if(associated(css%trg_type)) deallocate(css%trg_type)
       if(associated(css%trg_min80)) deallocate(css%trg_min80)
       if(associated(css%trg_max80)) deallocate(css%trg_max80)
       if(associated(css%trg_minval)) deallocate(css%trg_minval)
       if(associated(css%trg_maxval)) deallocate(css%trg_maxval)
       if(associated(css%trg_sliceset)) deallocate(css%trg_sliceset)
       if(associated(css%trg_valset)) deallocate(css%trg_valset)
       if(associated(css%trg_minset)) deallocate(css%trg_minset)
       if(associated(css%trg_maxset)) deallocate(css%trg_maxset)
       if(associated(css%trg_req)) deallocate(css%trg_req)
       if(associated(css%trg_vok)) deallocate(css%trg_vok)
       if(associated(css%trg_val)) deallocate(css%trg_val)
       if(associated(css%trg_ook)) deallocate(css%trg_ook)
       if(associated(css%trg_orm)) deallocate(css%trg_orm)
       if(associated(css%trg_fok)) deallocate(css%trg_fok)
       if(associated(css%trg_frm)) deallocate(css%trg_frm)
       if (css%ctrg.ne.0) then
          allocate(css%trg80(css%ctrg), css%trg_lent(css%ctrg), &
               & css%trg_v80(css%ctrg), css%trg_lenv(css%ctrg), css%trg_offset(0:css%ctrg),  &
               & css%trg_dim(css%ctrg), css%trg_var(css%ctrg), css%trg_type(css%ctrg), &
               & css%trg_min80(css%ctrg), css%trg_max80(css%ctrg),&
               & css%trg_minval(css%ctrg), css%trg_maxval(css%ctrg), &
               & css%trg_sliceset(css%ctrg), css%trg_valset(css%ctrg), &
               & css%trg_minset(css%ctrg), css%trg_maxset(css%ctrg), &
               & css%trg_req(css%ctrg), css%trg_vok(css%ctrg), css%trg_val(css%ctrg), &
               & css%trg_ook(0:css%ctrg), css%trg_orm(0:css%ctrg), &
               & css%trg_fok(0:css%ctrg), css%trg_frm(0:css%ctrg), stat=irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250,"Unable to allocate 'session:n80...'.")
             call model_errorappend(crc250,"\n")
             return
          end if
          ii=0
          css%trg_ook(ii)=0
          css%trg_orm(ii)=0
          css%trg_fok(ii)=0
          css%trg_frm(ii)=0
          currentTarget => css%firstTrg%next
          do while (.not.associated(currentTarget,target=css%lastTrg))
             ii=min(css%ctrg,ii+1)
             !
             css%trg80(ii)=currentTarget%n80
             call chop0(css%trg80(ii),80)
             css%trg_lent(ii)=length(css%trg80(ii),80,10)
             !
             css%trg_v80(ii)=currentTarget%v80
             call chop0(css%trg_v80(ii),80)
             css%trg_lenv(ii)=length(css%trg_v80(ii),80,10)
             css%trg_offset(ii)=0
             !
             css%trg_valset(ii)=.true.
             if (mod_bdeb) write(*,'(2(X,A),X,I0,2(X,A))')myname,'Target:',II,&
                  & css%trg80(ii)(1:css%trg_lent(ii)),&
                  & css%trg_v80(ii)(1:css%trg_lenv(ii))
             !
             css%trg_min80(ii)=currentTarget%min80
             call chop0(css%trg_min80(ii),80)
             lens=length(css%trg_min80(ii),80,10)
             if (lens.ne.0) then
                call parse_parsef(plim,css%trg_min80(ii)(1:lens),css%sys_var,crc250,irc)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Error return from parsef.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
                if (mod_bdeb)write(*,*)myname,' System:',css%sys_val
                css%trg_minval(ii)=parse_evalf(plim,css%sys_val,crc250,irc)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Error return from evalf.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
                css%trg_minset(ii)=.true.
                if (mod_bdeb) write(*,*)myname,'Minval:',css%trg_minval(ii),css%trg_minset(ii)
             else
                css%trg_minset(ii)=.false.
             end if
             !read (css%trg_min80(ii)(1:lens),*,iostat=irc2)
             css%trg_max80(ii)=currentTarget%max80
             call chop0(css%trg_max80(ii),80)
             lens=length(css%trg_max80(ii),80,10)
             if (lens.ne.0) then
                call parse_parsef(plim,css%trg_max80(ii)(1:lens),css%sys_var,crc250,irc)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Error return from parsef.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
                if (mod_bdeb)write(*,*)myname,' System:',css%sys_val
                css%trg_maxval(ii)=parse_evalf(plim,css%sys_val,crc250,irc)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Error return from evalf.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
                css%trg_maxset(ii)=.true.
                if (mod_bdeb) write(*,*)myname,'Maxval:',css%trg_maxval(ii),css%trg_maxset(ii)
             else
                css%trg_maxset(ii)=.false.
             end if
             ! read (css%trg_max80(ii)(1:lens),*,iostat=irc2)css%trg_maxval(ii)
             !css%trg_maxset(ii)=(irc2.eq.0)
             css%trg_sliceset(ii)=currentTarget%lslice
             css%trg_req(ii)=.false.
             css%trg_vok(ii)=.false.
             css%trg_val(ii)=0.0D0
             css%trg_ook(ii)=0
             css%trg_orm(ii)=0
             css%trg_fok(ii)=0
             css%trg_frm(ii)=0
             currentTarget => currentTarget%next
             css%trg_dim(ii)=0
             css%trg_var(ii)=0
             css%trg_type(ii)=0 ! undefined
          end do
          if (css%ind_set) then
             ii=min(css%ctrg,ii+1)
             css%trg80(ii)=css%ind_trg
             css%trg_v80(ii)=css%ind_var
             call chop0(css%trg80(ii),80)
             css%trg_lent(ii)=length(css%trg80(ii),80,10)
             call chop0(css%trg_v80(ii),80)
             css%trg_lenv(ii)=length(css%trg_v80(ii),80,10)
             css%trg_offset(ii)=0
             if (mod_bdeb) write(*,'(2(X,A),X,I0,2(X,A))')myname,'Target:',II,&
                  & css%trg80(ii)(1:css%trg_lent(ii)),&
                  & css%trg_v80(ii)(1:css%trg_lenv(ii))
             !
             css%trg_valset(ii)=.true.
             css%trg_minset(ii)=css%ind_lval(1)
             css%trg_maxset(ii)=css%ind_lval(2)
             css%trg_minval(ii)=css%ind_minval
             css%trg_maxval(ii)=css%ind_maxval
             css%trg_req(ii)=.false.
             css%trg_vok(ii)=.false.
             css%trg_val(ii)=0.0D0
             css%trg_ook(ii)=0
             css%trg_orm(ii)=0
             css%trg_fok(ii)=0
             css%trg_frm(ii)=0
             css%trg_dim(ii)=0
             css%trg_var(ii)=0
             css%trg_type(ii)=0 ! undefined
          end if
       end if
       call parse_close(plim,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from parse_close.")
          return
       end if
       css%trg_set=.true.
   end if 
   if(mod_bdeb)write(*,*)myname,' Done.',irc,css%ctrg
   return
 end subroutine model_maketargetlist
 !
 ! set observation target names
 !
 subroutine model_setObsTrg(css,nn,var,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: nn
    character*80 :: var(nn)
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setObsTrg"
    integer, external :: length
    integer :: ii
    if (css%cobs.ne.nn) then
       if (associated(css%obs_var)) deallocate(css%obs_var)
       if (associated(css%obs_lenv)) deallocate(css%obs_lenv)
       if (associated(css%obs_req)) deallocate(css%obs_req)
       if (associated(css%obs_vok)) deallocate(css%obs_vok)
       if (associated(css%obs_val)) deallocate(css%obs_val)
       css%cobs=nn
       allocate(css%obs_var(css%cobs),css%obs_lenv(css%cobs),&
            & css%obs_req(css%cobs),css%obs_vok(css%cobs),&
            & css%obs_val(css%cobs),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate 'obs'.")
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    do ii=1,css%cobs
       css%obs_var(ii)=var(ii)
       call chop0(css%obs_var(ii),80)
       css%obs_lenv(ii)=length(css%obs_var(ii),80,10)
       css%obs_req(ii)=.false.
    end do
    return
  end subroutine model_setObsTrg
 subroutine model_getObsReq(css,nn,req,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: nn
    logical :: req(nn)
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setObsReq"
    integer, external :: length
    integer :: ii
    do ii=1,min(nn,css%cobs)
       if (css%obs_req(ii))req(ii)=.true.
    end do
    return
  end subroutine model_getObsReq
 !
 ! set observation values
 !
 subroutine model_setObsVal(css,nn,val,vok,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: nn
    real :: val(nn)
    logical :: vok(nn)
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setObsVal"
    integer :: ii
    if (css%cobs.ne.nn) then
       if (associated(css%obs_vok)) deallocate(css%obs_vok)
       if (associated(css%obs_val)) deallocate(css%obs_val)
       irc=844
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Invalid ntrg.")
       call model_errorappendi(crc250,nn)
       call model_errorappendi(crc250,css%cobs)
       call model_errorappend(crc250,"\n")
       return
       !    css%cobs=nn
       !    allocate(css%obs_val(css%cobs),css%obs_vok(css%cobs),stat=irc)
       !    if (irc.ne.0) then
       !       call model_errorappend(crc250,myname)
       !       call model_errorappend(crc250,"Unable to allocate 'obs'.")
       !       call model_errorappend(crc250,"\n")
       !       return
       !    end if
    end if
    do ii=1,css%cobs
       css%obs_val(ii)=val(ii)
       css%obs_vok(ii)=vok(ii)
    end do
    return
  end subroutine model_setObsVal
  !
  ! set location target value
  !
  subroutine model_setLocTrgVal(css,loc,itrg,val,crc250,irc)
    implicit none
    type(mod_session), pointer :: css  ! current session
    type(mod_location), pointer :: loc ! current location
    integer :: itrg                    ! target position
    real :: val                        ! output value
    character*250 :: crc250            ! error message string
    integer :: irc                     ! error return code(0=ok)
    integer :: ii,jj
    character*25 :: myname="model_setLocTrgVal"
    if (itrg.le.0.or.itrg.gt.css%otrg) then
       irc=944
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Invalid itrg.")
       call model_errorappendi(crc250,itrg)
       call model_errorappendi(crc250,css%otrg)
       call model_errorappend(crc250,"\n")
       return
    end if
    loc%trg_vok(itrg)=.true.
    loc%trg_val(itrg)=val
    loc%trg_set(itrg)=.true.
    if (mod_bdeb)write(*,'(X,A,X,A,X,I0,X,I0,X,A,F0.1,X,L1)')myname,' Assigned:',loc%locid,itrg,&
         & "'"//css%trg80(itrg)(1:css%trg_lent(itrg))//"' = ",loc%trg_val(itrg),loc%trg_vok(itrg)

    return
  end subroutine model_setLocTrgVal
  !
  subroutine model_locRposToTrg(css,loc,ff,ninn,inn,ind,crc250,irc)
    implicit none
    type(mod_session), pointer :: css  ! current session
    type(mod_location), pointer :: loc ! current location
    integer :: ff                      ! offset
    integer :: ninn                    ! number of search dimensions
    integer :: inn(ninn)               ! search dimension index
    integer :: ind(ninn)               ! target index
    character*250 :: crc250            ! error message string
    integer :: irc                     ! error return code(0=ok)
    integer :: ii,jj
    character*25 :: myname="model_locRposToTrg"
    do jj=1,ninn
       if (ind(jj).gt.0.and.ind(jj).le.loc%ctrg) then
          loc%trg_vok(ind(jj))=.true.
          loc%trg_val(ind(jj))=loc%rpos(inn(jj),ff)
          loc%trg_set(ind(jj))=.true.
       else if (ind(jj).ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Invalid index.")
          call model_errorappendi(crc250,ind(jj))
          call model_errorappendi(crc250,loc%ctrg)
          call model_errorappend(crc250,"\n")
          return
       end if
    end do
    return
  end subroutine model_locRposToTrg
  !
 !
 ! set target values given match values
 !
 subroutine model_setTargetVal(css,nn,ind,val,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: nn
    integer :: ind(nn)
    real :: val(nn)
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setTargetVal"
    integer :: ii
    do ii=1,nn
       if (ind(ii).gt.css%ctrg) then
          irc=457
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Target-n mismatch .")
          call model_errorappendi(crc250,ii)
          call model_errorappendi(crc250,css%ctrg)
          call model_errorappendi(crc250,ind(ii))
          call model_errorappend(crc250,"\n")
          return
       end if
       if (css%trg_valset(ind(ii))) then
          css%trg_vok(ind(ii))=.true.
          css%trg_val(ind(ii))=val(ii)
       else
          css%trg_vok(ind(ii))=.false.
          css%trg_val(ind(ii))=0.0D0
       end if
    end do
    return
  end subroutine model_setTargetVal
 !
 ! set target values given match values
 !
 subroutine model_setTargetDVal(css,nn,vset,val,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: nn
    logical :: vset(nn)
    real :: val(nn)
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setTargetDVal"
    integer :: ii
    if(mod_bdeb)write(*,*)myname,' Entering.',nn,css%ctrg
    if (nn.ne.css%ctrg) then
       if(mod_bdeb)write(*,*)myname,' Target mismatch.',nn,css%ctrg
       irc=457
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Target-n mismatch .")
       call model_errorappendi(crc250,css%ctrg)
       call model_errorappendi(crc250,nn)
       call model_errorappend(crc250,"\n")
       return
    end if
    do ii=1,nn
       css%trg_valset(ii)=vset(ii)
       if (vset(ii)) then
          css%trg_vok(ii)=.true.
          css%trg_val(ii)=val(ii)
       else
          css%trg_vok(ii)=.false.
          css%trg_val(ii)=0.0D0
       end if
    end do
    if(mod_bdeb)write(*,*)myname,' Done.',nn,css%ctrg
    return
  end subroutine model_setTargetDVal
  !
  subroutine model_setTarget(css,nn,ind,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: nn                     ! number of indexes
    integer :: ind(nn)                ! target index
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setTarget"
    integer :: ii
    do ii=1,nn
       css%trg_valset(ind(ii))=.true. ! target is set in search
       css%trg_req(ind(ii))=.true.    ! target variable is required (can not be undefined)
    end do
    return
  end subroutine model_setTarget
  !
  subroutine model_checkTargetVal(css,locid,bok,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: locid
    logical :: bok
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_checkTargetVal"
    type(mod_location), pointer :: loc
    real :: val
    integer :: pos,ii
    if (bok.and.css%locReady) then
       pos=locid-css%locoo
       if (pos.gt.css%nloc) then
          if(mod_bdeb)write(*,*)myname,'Location pos out of range.',pos,'->',css%nloc,&
               & locid,css%locoo
          bok=.false.
          irc=945
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Locid out of range:")
          call model_errorappendi(crc250,locid)
          call model_errorappend(crc250,"<>")
          call model_errorappendi(crc250,css%nloc)
          call model_errorappendi(crc250,css%locoo)
          call model_errorappend(crc250,"\n")
          return
       end if
       if (bok) then
          loc => css%locData(pos)%ptr
          if (.not.associated(loc)) then
             if(mod_bdeb)write(*,*)myname,'Location invalid location at ',pos,'->',css%nloc
             bok=.false.
          end if
       end if
       if (bok) then
          bok=(loc%bok)
          if (bok) then
             css%currentFile%ook(1)=css%currentFile%ook(1)+1
          else
             if (mod_bdeb)write(*,*)myname,'Loc fail:',loc%bok
             css%currentFile%orm(1)=css%currentFile%orm(1)+1 ! failed to qualify
          end if
       end if
       if (bok) then
          do ii=1,loc%ctrg
             if (bok) then
                if (loc%trg_set(ii)) then
                   if (css%trg_minset(ii)) then
                      if (loc%trg_val(ii).lt.css%trg_minval(ii)) bok=.false.
                   end if
                   if (css%trg_maxset(ii)) then
                      if (loc%trg_val(ii).gt.css%trg_maxval(ii)) bok=.false.
                   end if
                   if (bok) then
                      css%trg_ook(ii)=css%trg_ook(ii)+1
                   else
                      css%trg_orm(ii)=css%trg_orm(ii)+1
                   end if
                end if
                if (.not.bok.and.mod_bdeb)write(*,*)myname,'Rejected:',&
                     & ii,css%trg80(ii)(1:css%trg_lent(ii)), &
                     & loc%trg_val(ii),css%trg_minval(ii),css%trg_maxval(ii),&
                     & loc%trg_set(ii),css%trg_minset(ii),css%trg_maxset(ii)
             end if
          end do
          if (bok) then
             css%currentFile%ook(2)=css%currentFile%ook(2)+1
             css%trg_ook(0)=css%trg_ook(0)+1
          else
             css%currentFile%orm(2)=css%currentFile%orm(2)+1 ! target error
             css%trg_orm(0)=css%trg_orm(0)+1
          end if
       end if
    end if
    return
  end subroutine model_checkTargetVal
  !
  subroutine model_checkFilter(css,locid,bok,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: locid
    logical :: bok
    character*250 :: crc250
    integer :: irc
    integer :: pos, ii
    character*25 :: myname="model_checkFilter"
    type(mod_location), pointer :: loc
    real :: val
    logical :: bdeb
    if (bok.and.css%locReady) then
       pos=locid-css%locoo
       if (pos.gt.css%nloc) then
          if(mod_bdeb)write(*,*)myname,'Location pos out of range.',pos,'->',css%nloc,&
               & locid,css%locoo
          bok=.false.
          irc=944
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Locid out of range:")
          call model_errorappendi(crc250,locid)
          call model_errorappend(crc250,"<>")
          call model_errorappendi(crc250,css%nloc)
          call model_errorappendi(crc250,css%locoo)
          call model_errorappend(crc250,"\n")
          return
       end if
       if (bok) then
          loc => css%locData(pos)%ptr
          if (.not.associated(loc)) then
             if(mod_bdeb)write(*,*)myname,'Location invalid location at ',pos,'->',css%nloc
             bok=.false.
          end if
       end if
       if (bok) then
          bok=(loc%bok)
       end if
       if (bok) then
          bok=(loc%search(0).eq.0)
          if (bok) then
             css%currentFile%ook(3)=css%currentFile%ook(3)+1
          else
             if (mod_bdeb)write(*,*)myname,'Search fail:',loc%search(0)
             css%currentFile%orm(3)=css%currentFile%orm(3)+1 ! field search failed
          end if
       end if
       if (bok) then
          ! evaluate filter
          if (css%mpo_set) then
             if (mod_bdeb)write(*,*)myname,'Evaluating filter:',ii,&
                  & associated(css%psf),css%cmpo
             do ii=1,loc%ctrg
                css%mpo_val(ii)=loc%trg_val(ii)
                css%mpo_vok(ii)=loc%trg_vok(ii)
             end do
             do ii=1,loc%cobs
                css%mpo_val(ii+css%ctrg)=loc%obs_val(ii)
                css%mpo_vok(ii+css%ctrg)=loc%obs_vok(ii)
             end do
             if (mod_bdeb)write(*,*)myname,' MPO:',css%mpo_val
             val=parse_evalf(css%psf,css%mpo_val,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from evalf.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             bok=(nint(val).ne.0) ! NB bok is local, reject obs using trg_set->.false.
             if (mod_bdeb)write(*,*)myname,'Returned:',val,bok
          else
             if (mod_bdeb)write(*,*)myname,'MPO fail:',css%mpo_set
             bok=.false.
          end if
          if (bok) then
             css%currentFile%ook(4)=css%currentFile%ook(4)+1
          else
             if (mod_bdeb)write(*,*)myname,'Filter fail:',loc%bok
             css%currentFile%orm(4)=css%currentFile%orm(4)+1 ! model filter failed
          end if
       end if
    else
       if (mod_bdeb)write(*,*)myname,'Failed to qualify, locready=',css%locReady
       bok=.false.
    end if
    if (bok) then
       if (mod_bdeb)write(*,*)myname,'Obs OK:',locid,bok
    else
       if (mod_bdeb)write(*,*)myname,'Obs FAIL:',locid,bok,css%mpo_set
    end if
    return
  end subroutine model_checkFilter
  !
  ! delete target from stack
  !
  subroutine model_deleteTarget (css,trg, crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    type(mod_target), pointer :: trg
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    character*25 :: myname="model_deleteTarget"
    if (associated(trg)) then
       css%ntrg = css%ntrg - 1
       trg%next%prev => trg%prev
       trg%prev%next => trg%next
       deallocate(trg)
    end if
    css%trg_set=.false.
    return
  end subroutine model_deleteTarget
  !
  ! Set the target index in a file
  subroutine model_setTargetIndex(css,file,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    type(mod_file), pointer :: file
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    type(mod_variable), pointer :: var
    character*25 :: myname="model_setTargetIndex"
    integer, external :: length
    integer :: lend, leng, lenv
    integer ii,jj
    if(mod_bdeb)write(*,*)myname,' Entering.',file%nvar
    if (mod_bdeb) then
       do ii=1, css%ctrg
          write(*,*)myname," Target ",ii," '"//css%trg80(ii)(1:css%trg_lent(ii)),&
               & "' -> '"//css%trg_v80(ii)(1:css%trg_lenv(ii))//"'"
       end do
    end if
    if(mod_bdeb)write(*,*)myname,' Setting dims.',file%ndim
    do jj=1,file%ndim
       file%dim_trg(jj)=0
    end do
    if(mod_bdeb)write(*,*)myname,' Looping targets.',css%ctrg
    do ii=1,css%ctrg
       css%trg_var(ii)=0 ! global variable index
       css%trg_dim(ii)=0 ! global dimension index
       leng=css%trg_lenv(ii)
       if(mod_bdeb)write(*,*)myname," Checking for dimension '"//css%trg_v80(ii)(1:leng)//"'",file%ndim
       if (css%trg_type(ii).eq.2) then ! variable
          jj=model_getDimIndex(file,css%trg_v80(ii)(1:css%trg_lenv(ii)))
          if (jj.ne.0) then
             css%trg_dim(ii)=jj ! global dimension index
             file%dim_trg(jj)=ii
          end if
       else if (css%trg_type(ii).eq.1) then ! variable
          jj=model_getVarIndex(file,css%trg_v80(ii)(1:leng))
          if (jj.ne.0) then
             css%trg_var(ii)=jj
             if(mod_bdeb)write(*,'(X,A,A,I3,A,I3,A)') myname,&
                  & 'Target variable: ',&
                  & ii,' -> ',jj,&
                  & "  '"//css%trg_v80(ii)(1:leng)//"'"
          end if
       end if
       if (css%trg_dim(ii).eq.0.and.css%trg_var(ii).eq.0) then ! not dimension nor variable...
          if(mod_bdeb)write(*,*) myname,'Unrecognised target ignored:',&
               & css%trg_v80(ii)(1:leng)
       end if
    end do
    !
    if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_setTargetIndex
  !
  subroutine model_parseTargets(css,crc250,irc)
    implicit none
    type(mod_session),pointer :: css  !  session
    character*250 :: crc250
    integer :: irc
    type(mod_variable), pointer :: var
    character*25 :: myname="model_parseTargets"
    integer, external :: length
    integer ii,jj
    if(mod_bdeb)write(*,*)myname,' Entering.'
    do ii=1,css%ctrg
       css%trg_type(ii)=0 ! undefined
       css%trg_var(ii)=0 ! global variable index
       css%trg_dim(ii)=0 ! global dimension index
       if(mod_bdeb)write(*,*)myname," Checking '"//&
            & css%trg_v80(ii)(1:css%trg_lenv(ii))//"'"
       if (css%trg_v80(ii)(1:1).eq."(".and.&
            & css%trg_v80(ii)(css%trg_lenv(ii):css%trg_lenv(ii)).eq.")") then
          css%trg_v80(ii)=css%trg_v80(ii)(2:css%trg_lenv(ii)-1)
          call chop0(css%trg_v80(ii),80)
          css%trg_lenv(ii)=length(css%trg_v80(ii),80,10)
          css%trg_offset(ii)=model_getOffset(css,css%trg_v80(ii),&
               & css%trg_lenv(ii),crc250,irc) ! adjusts length
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from getOffset.")
             call model_errorappend(crc250,"\n")
             return
          end if
          css%trg_type(ii)=2 ! dimension
       else ! must be a variable
          css%trg_offset(ii)=model_getOffset(css,css%trg_v80(ii),&
               & css%trg_lenv(ii),crc250,irc) ! adjusts length
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from getOffset.")
             call model_errorappend(crc250,"\n")
             return
          end if
          css%trg_type(ii)=1 ! variable
       end if
    end do
    if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_parseTargets
  !
  ! parse the offset-strings in the offset chain
  !
  subroutine model_parseOffset(css,crc250,irc)
    implicit none
    type(mod_session),pointer :: css  !  session
    character*250 :: crc250
    integer :: irc
    type(mod_offset), pointer :: off
    character*25 :: myname="model_parseOffset"
    integer, external :: length
    integer :: lenv, leno, lene, lens
    integer ii,jj,ojj,tjj,kk,mode
    character*80 :: sli80, exp80
    if(mod_bdeb)write(*,*)myname,' Entering.',css%nOffsetIndexes,irc
    ! allocate offset list
    if (associated(css%offset)) deallocate(css%offset)
    allocate(css%offset(0:css%nOffsetIndexes),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'offset'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    allocate(css%offset(0)%ptr,stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'offset(0)'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Make list.',css%nOffsetIndexes
    ! make list from chain
    ii=0
    off=>css%firstOffset%next
    do while (.not.associated(off,target=css%lastOffset))
       ii=ii+1
       css%offset(ii)%ptr => off
       off => off%next
    end do
    ! loop through list
    do ii=0,css%noffsetIndexes
       !if(mod_bdeb)write(*,*)myname,' Looping.',ii,associated(css%offset)
       off => css%offset(ii)%ptr
       !if(mod_bdeb)write(*,*)myname,' Offset.',ii,associated(off)
       ! allocate slice arrays
       off%csli=css%csli
       if (associated(off%sli_set)) deallocate(off%sli_set)
       allocate(off%sli_set(off%csli),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate 'sli_set'.")
          call model_errorappend(crc250,"\n")
          return
       end if
       do jj=1,off%csli
          off%sli_set(jj)=.false.
       end do
       !if(mod_bdeb)write(*,*)myname,' InitPSP.',ii,off%csli
       call model_initPSP(off%csli,off%sli_psp,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from initPSP.")
          call model_errorappend(crc250,"\n")
          return
       end if
       ojj=0
       tjj=0
       jj=0
       mode=0 ! expect slice variable terminated by "="
       if(mod_bdeb)write(*,*)myname," Parsing '"//off%off80(1:off%leno)//"'"
       do while (jj.lt.off%leno)
          jj=jj+1
          if (off%off80(jj:jj).eq."=".or.off%off80(jj:jj).eq.":") then ! 
             if (mode.eq.0) then !
                if (ojj+1.lt.jj-1) then ! non-zero size
                   tjj=jj-1
                   mode=1 ! extract slice variable
                else ! zero-size slice variable
                   irc=145
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250,"Zero size slice variable in '"//&
                        & off%off80(1:off%leno)//"'")
                   return
                end if
             else ! unexpected "="
                irc=146
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250,"Unexpected '"//off%off80(jj:jj)//"' in '"//&
                     & off%off80(1:off%leno)//"'")
                return
             end if
          elseif (off%off80(jj:jj).eq.";".or.off%off80(jj:jj).eq."&") then
             if (mode.eq.2) then
                if (ojj+1.lt.jj-1) then ! non-zero size
                   tjj=jj-1
                   mode=3 ! extract expression
                else ! zero-size expression
                   irc=147
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250,"Zero size expression in '"//&
                        & off%off80(1:off%leno)//"'")
                   return
                end if
             else
                irc=148
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250,"Unexpected '"//off%off80(jj:jj)//"' in '"//&
                     & off%off80(1:off%leno)//"'")
                return
             end if
          elseif (jj.eq.off%leno) then  ! end of line
             if (mode.eq.2) then
                if (ojj+1.lt.jj) then ! non-zero size
                   tjj=jj
                   mode=3 ! extract expressions
                else ! zero-size expression
                   irc=149
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250,"Zero size expression in '"//&
                        & off%off80(1:off%leno)//"'")
                   return
                end if
             else if (ojj+1.lt.jj) then
                if(mod_bdeb)write(*,'(X,A,A,4(X,I0))')myname,&
                     & " EOL:",mode,ojj,jj,off%leno
                irc=150
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250,"Unexpected EOL in '"//&
                     & off%off80(1:off%leno)//"'")
                return
             end if
          else
          end if
          if (mode.eq.1) then ! extract slice variable
             sli80=off%off80(ojj+1:tjj)
             call chop0(sli80,80)
             lens=length(sli80,80,5)
             !if(mod_bdeb)write(*,'(X,A,A,3(X,I0))')myname,&
             !     & " Slice:'"//sli80(1:lens)//"'",ojj,jj,lens
             mode=2 ! look for expression
             ojj=jj
          else if (mode.eq.3) then ! extract slice expression
             exp80=off%off80(ojj+1:tjj)
             call chop0(exp80,80)
             lene=length(exp80,80,5)
             ! add element
             kk=model_getSliceIndex(css,sli80(1:lens),crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from getSliceIndex.")
                call model_errorappend(crc250,"\n")
                return
             end if
             if(mod_bdeb)write(*,'(X,A,A,I0)')myname,&
                  & " Found:'"//sli80(1:lens)&
                  & //"' '"//exp80(1:lene)//"' -> ",kk
             if (kk.eq.0) then
                irc=364
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250,"Not a slice variable: '"//sli80(1:lens)//"'.")
                call model_errorappend(crc250,"\n")
                return
             end if
             off%sli_set(kk)=.true.
             ! parse item
             call parse_parsef(off%sli_psp(kk)%ptr,exp80(1:lene),css%sli_v80,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from parsef.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             mode=0 ! look for next slice variable
             ojj=jj
          end if
          !if (mod_bdeb) write(*,*)myname,"Pos:",jj,mode,"'"//off%off80(jj:jj)//"'"
       end do
    end do
    if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_parseOffset
  !
  integer function model_getDimIndex(file,dim)
    implicit none
    type(mod_file), pointer :: file
    character*(*) :: dim
    integer :: jj,lend
    integer, external :: length
    character*25 :: myname="model_getDimIndex"
    do jj=1,file%ndim
       lend=length(file%dim80(jj),80,10)
       if (dim.eq.file%dim80(jj)(1:lend)) then
          if(mod_bdeb)write(*,*) myname,'Dim: "'//dim//&
               & '"  "'//file%dim80(jj)(1:lend)//'"',jj
          model_getDimIndex=jj
          return
       end if
    end do
    model_getDimIndex=0
    return
  end function model_getDimIndex
  !
  integer function model_getVarIndex(file,var)
    implicit none
    type(mod_file), pointer :: file
    character*(*) :: var
    integer :: jj,lenv
    integer, external :: length
    character*25 :: myname="model_getVarIndex"
    do jj=1,file%nvar ! global variable index
       lenv=length(file%var80(jj),80,10)
       !if(mod_bdeb)write(*,*)myname,jj," Variable '"//file%var80(jj)(1:lenv)//"'"
       if (var.eq.file%var80(jj)(1:lenv)) then
          model_getVarIndex=jj
          return
       end if
    end do
    model_getVarIndex=0
    return    
  end function model_getVarIndex
  !
  ! look for "<variable>[<offset>]"
  !
  integer function model_getOffset(css,var80,lenv,crc250,irc)
    implicit none
    type(mod_session), pointer :: css
    character*80 :: var80 ! variable string
    integer :: lenv      ! start and end of string
    character*250 :: crc250
    integer :: irc
    integer :: ii,is,ie
    integer, external :: length
    character*25 :: myname="model_getOffset"
    is=0
    ie=0
    do ii=1,lenv
       if (is.eq.0.and.var80(ii:ii).eq."[") then
          is=ii
       else if (var80(ii:ii).eq."]") then
          ie=ii
       end if
    end do
    if (is.ne.0.and.ie.ne.0.and.ie-is.gt.2) then
       model_getOffset=model_checkOffset(css,var80(is+1:ie-1),crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from checkOffset.")
          call model_errorappend(crc250,"\n")
          return
       end if
       lenv=is-1
       var80=var80(1:lenv)
       call chop0(var80,80)
       lenv=length(var80,80,lenv)
    else
       model_getOffset=0
    end if
    return
  end function model_getOffset
  !
  integer function model_checkOffset(css,offset,crc250,irc)
    implicit none
    type(mod_session), pointer :: css
    character*(*) :: offset             ! offset string
    character*250 :: crc250
    integer :: irc
    type(mod_offset), pointer :: off
    integer, external :: length
    character*25 :: myname="model_checkOffset"
    off => css%firstOffset%next
    do while (.not.associated(off,target=css%lastOffset))
       if (off%off80(1:off%leno).eq.offset)then
          model_checkOffset=off%index
          return
       end if
       off=>off%next
    end do
    ! not found, create new
    nullify(off)
    allocate(off,stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate offset.")
       call model_errorappend(crc250,"\n")
       return
    end if
    off%off80=offset
    call chop0(off%off80,80)
    off%leno=length(off%off80,80,10)
    off%prev=>css%lastOffset%prev
    off%next=>css%lastOffset
    off%prev%next=>off
    off%next%prev=>off
    css%noffsetindexes=css%noffsetindexes+1
    if (mod_bdeb)write(*,*)myname,"Found offset '"//offset//"'",&
         & css%noffsetindexes
    off%index=css%noffsetindexes
    model_checkOffset=off%index
    nullify(off)
    return
  end function model_checkOffset
  !
  !###############################################################################
  ! LOCATION ROUTINES
  !###############################################################################
  ! initialise the MODEL location
  !
  subroutine model_initLocStack(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_initLocStack"
    ! initialise chain
    if (.not.associated(css%firstLoc)) then
       allocate(css%firstLoc,css%lastLoc, stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate 'firstLoc/lastLoc'.")
          call model_errorappend(crc250,"\n")
          return
       end if
       css%firstLoc%next => css%lastLoc
       css%lastLoc%prev => css%firstLoc
       css%nloc=0
       css%locReady=.false.
       if(mod_bdeb)write(*,*)myname,' WARNING: locready=F'
    end if
  end subroutine model_initLocStack
  !
  ! clear the MODEL POS
  !
  subroutine model_sliceVariables(css,nslice,slice80,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: nslice
    character*80 :: slice80(nslice)
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_sliceVariables"
    integer :: ii, lens
    integer, external :: length
    if(mod_bdeb)write(*,*)myname,' Entering.'
    ! store slice variables/dimensions
    css%csli=0
    do ii=1,nslice
       call chop0(slice80(ii),80)
       lens=length(slice80(ii),80,10)
       if(mod_bdeb)write(*,*)myname,'Slice variable:', ii,slice80(ii)(1:lens)
       if (lens.ne.0) then
          css%csli=min(nslice,css%csli+1)
       end if
    end do
    if (allocated(css%sli80)) deallocate(css%sli80)
    if (allocated(css%sli_lens)) deallocate(css%sli_lens)
    if (allocated(css%sli_v80)) deallocate(css%sli_v80)
    if (allocated(css%sli_lenv)) deallocate(css%sli_lenv)
    if (allocated(css%sli_2trg)) deallocate(css%sli_2trg)
    allocate(css%sli80(css%csli),css%sli_v80(css%csli),&
         & css%sli_lenv(css%csli),css%sli_2trg(css%csli),&
         & stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'gslice'.")
       call model_errorappendi(crc250,css%csli)
       call model_errorappend(crc250,"\n")
       return
    end if
    css%csli=0
    do ii=1,nslice
       lens=length(slice80(ii),80,10)
       if(mod_bdeb)write(*,*)myname,' **** Slice variable:', ii,slice80(ii)(1:lens)
       if (lens.ne.0) then
          css%csli=min(nslice,css%csli+1)
          css%sli80(css%csli)=""
          css%sli_lens(css%csli)=0
          css%sli_v80(css%csli)=slice80(ii)
          css%sli_lenv(css%csli)=lens
          css%sli_2trg(css%csli)=ii
       end if
    end do
    if(mod_bdeb)write(*,*)myname,' Done.',css%csli
  end subroutine model_sliceVariables
  !
  subroutine model_setSliceIndex(css,nslice,ind,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: nslice
    integer :: ind(nslice)
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setSliceIndex"
    integer :: ii
    if(mod_bdeb)write(*,*)myname,' Entering.',nslice
    ! process offset and target type
    call model_parseTargets(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from parseTargets.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    ! store slice variables/dimensions
    css%csli=nslice
    if (allocated(css%sli80)) deallocate(css%sli80)
    if (allocated(css%sli_lens)) deallocate(css%sli_lens)
    if (allocated(css%sli_v80)) deallocate(css%sli_v80)
    if (allocated(css%sli_lenv)) deallocate(css%sli_lenv)
    if (allocated(css%sli_2trg)) deallocate(css%sli_2trg)
    allocate(css%sli80(css%csli),css%sli_lens(css%csli),css%sli_v80(css%csli),&
         & css%sli_lenv(css%csli),css%sli_2trg(css%csli),&
         & stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'gslice'.")
       call model_errorappendi(crc250,css%csli)
       call model_errorappend(crc250,"\n")
       return
    end if
    do ii=1,nslice
       css%sli_2trg(ii)=ind(ii)
       css%sli80(ii)=css%trg80(ind(ii))
       css%sli_lens(ii)=css%trg_lent(ind(ii))
       css%sli_v80(ii)=css%trg_v80(ind(ii))
       css%sli_lenv(ii)=css%trg_lenv(ind(ii))
       if (mod_bdeb) write(*,'(X,A,X,A,X,I0,A,I0,X,A)') myname,'Slice index:',ii," -> ",ind(ii), &
            & "'"//css%trg_v80(ind(ii))(1:css%trg_lenv(ind(ii)))//"'"
       if (css%trg_offset(ind(ii)).ne.0) then
          irc=458
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Can not offset slice variable '"// &
               & css%sli_v80(ii)(1:css%sli_lenv(ii))//"'")
          call model_errorappendi(crc250,ii)
          call model_errorappend(crc250,"\n")
          return
       end if
    end do
    call model_parseOffset(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from parseOffset.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Done.',css%csli
    return
  end subroutine model_setSliceIndex
  !
  integer function model_getSliceIndex(css,var,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*(*) :: var
    character*250 :: crc250
    integer :: irc
    integer :: ii
    model_getSliceIndex=0
    do ii=1,css%csli
       if (var.eq.css%sli80(ii)(1:css%sli_lens(ii))) then
          model_getSliceIndex=ii
          return
       end if
    end do
    return
  end function model_getSliceIndex
  !
  ! Use marked target variables as slice variables
  subroutine model_sliceTrgVal(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_sliceTrgVal"
    integer :: ii, jj, lens
    integer, external :: length
    if(mod_bdeb)write(*,*)myname,' Entering.'
    ! store slice variables/dimensions
    css%csli=0
    if (allocated(css%sli80)) deallocate(css%sli80)
    if (allocated(css%sli_lens)) deallocate(css%sli_lens)
    if (allocated(css%sli_v80)) deallocate(css%sli_v80)
    if (allocated(css%sli_lenv)) deallocate(css%sli_lenv)
    if (allocated(css%sli_2trg)) deallocate(css%sli_2trg)
    ! count number of slice variables (for allocation)
    do ii=1,css%ctrg
       if (css%trg_sliceset(ii).and.css%trg_valset(ii)) then
          css%csli=css%csli+1
          if (mod_bdeb) then
             write(*,*)myname,' *** Slice variable: ',&
                  & css%trg_v80(ii)(1:css%trg_lenv(ii)),css%csli
          end if
       else
          if (mod_bdeb) then
             write(*,*)myname,' *** Not sliced    : ',&
                  & css%trg_v80(ii)(1:css%trg_lenv(ii)),&
                  & css%trg_sliceset(ii),css%trg_valset(ii)
          end if
       end if
    end do
    allocate(css%sli80(css%csli),css%sli_lens(css%csli),&
         & css%sli_v80(css%csli),css%sli_lenv(css%csli),&
         & css%sli_2trg(css%csli),&
         & stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'gslice'.")
       call model_errorappendi(crc250,css%csli)
       call model_errorappend(crc250,"\n")
       return
    end if
    css%csli=0
    do ii=1,css%ctrg
       if (css%trg_sliceset(ii).and.css%trg_valset(ii)) then
          css%csli=css%csli+1
          css%sli80(css%csli)=css%trg80(ii)
          css%sli_lens(css%csli)=css%trg_lent(ii)
          css%sli_v80(css%csli)=css%trg_v80(ii)
          css%sli_lenv(css%csli)=css%trg_lenv(ii)
          css%sli_2trg(css%csli)=ii
          if (mod_bdeb) write(*,*) myname,'Slice index:',css%csli,ii
          if (css%trg_offset(ii).ne.0) then
             irc=459
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250,"Can not offset slice variable '"// &
                  & css%sli_v80(css%csli)(1:css%sli_lenv(css%csli))//"'")
             call model_errorappendi(crc250,css%csli)
             call model_errorappend(crc250,"\n")
             return
          end if
       end if
    end do
    if(mod_bdeb)write(*,*)myname,' Done.',css%csli
  end subroutine model_sliceTrgVal
  !
  subroutine model_clearLocStack(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(mod_location), pointer :: currentLoc => null()
    type(mod_location), pointer :: locNext => null()
    character*25 :: myname="model_clearLocStack"
    integer :: ii, lens
    integer, external :: length
    if(mod_bdeb)write(*,*)myname,' Entering.'
    call model_initLocStack(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from locinit.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    ! delete any existing location-entries
    currentLoc => css%firstLoc%next
    do while (.not.associated(currentLoc,target=css%lastLoc))
       locNext => currentLoc%next
       call model_deleteLoc(css,currentLoc,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from locrmitem.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       currentLoc => locNext
    end do
    if (css%nloc .ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," System error:")
       call model_errorappendi(crc250,css%nloc)
       call model_errorappend(crc250,"\n")
       irc=940
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Done.'
  end subroutine model_clearLocStack
  !
  ! Add a "location", specified by slice variables...
  !
  subroutine model_locpushVariables(css,locid,csli,sli_val,bok,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: locid
    integer :: csli
    real:: sli_val(csli)
    logical :: bok
    character*250 :: crc250
    integer :: irc
    type(mod_location),pointer :: newLoc
    character*80 :: var80
    integer :: ii,yy,mm,dd,hh,mi
    real:: sec
    integer :: lenc
    integer, external :: length
    character*25 :: myname="model_locpushvariables"
    if(mod_bdeb)write(*,*)myname,' Entering. Loc%bok=',bok
    if(mod_bdeb)write(*,*)myname,' data.',csli,css%csli
    ! check number of slice-variables
    if(mod_bdeb)write(*,*)myname,'Slices:',csli,css%csli
    do ii=1,csli
       if(mod_bdeb)write(*,*) myname,'Slice:',ii,sli_val(ii)
    end do
    if (csli.ne.css%csli) then
       irc=346
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,":Location:")
       call model_errorappendi(crc250,locid)
       call model_errorappend(crc250,":Wrong number of slice-variables, expected:")
       call model_errorappendi(crc250,css%csli)
       call model_errorappend(crc250," got:")
       call model_errorappendi(crc250,csli)
       call model_errorappend(crc250,"\n")
       return
    end if
    ! initialise location stack
    if (css%nloc.eq.0) then
       css%locoo=locid-1
    end if
    !
    call model_initLocStack(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from locinit.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    ! create new location-item
    allocate(newLoc,stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate new location.")
       call model_errorappend(crc250,"\n")
       return
    end if
    newLoc%csli=csli
    allocate(newLoc%sli_val(newLoc%csli),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate newLoc%sli_val.")
       call model_errorappendi(crc250,newLoc%csli)
       call model_errorappend(crc250,"\n")
       return
    end if
    newLoc%locid=locid
    do ii=1,newLoc%csli
       if(mod_bdeb)write(*,*)myname,'Slice target:',ii,sli_val(ii)
       newLoc%sli_val(ii)=sli_val(ii)
    end do
    newLoc%bok=bok
    ! push onto stack
    css%nloc=css%nloc + 1
    newLoc%prev => css%lastLoc%prev
    newLoc%next => css%lastLoc
    newLoc%prev%next => newLoc
    newLoc%next%prev => newLoc
    css%locReady=.false.
    if (css%nloc+css%locoo .ne. locid) then
       irc=346
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Non-sequential locid:")
       call model_errorappendi(crc250,locid)
       call model_errorappend(crc250,"<>")
       call model_errorappendi(crc250,css%nloc+css%locoo)
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine model_locpushVariables
  !
  ! Add a "location", specified by slice variables...
  !
  subroutine model_locpushTarget(css,locid,bok,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: locid
    logical :: bok
    character*250 :: crc250
    integer :: irc
    type(mod_location),pointer :: newLoc
    character*80 :: var80
    integer :: ii,jj,yy,mm,dd,hh,mi
    real:: sec
    integer :: lenc
    integer, external :: length
    character*25 :: myname="model_locpushTarget"
    if(mod_bdeb.and.locid.lt.10)write(*,*)myname,' Entering, csli:',&
         & css%csli," Loc%bok=",bok,css%sli_2trg
    ! initialise location stack
    if (css%nloc.eq.0) then
       css%locoo=locid-1
    end if
    !
    call model_initLocStack(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from locinit.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    ! create new location-item
    allocate(newLoc,stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate new location.")
       call model_errorappend(crc250,"\n")
       return
    end if
    newLoc%locid=locid
    newLoc%bok=bok
    newLoc%csli=css%csli
    allocate(newLoc%sli_val(newLoc%csli),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate newLoc%sli_val.")
       call model_errorappendi(crc250,newLoc%csli)
       call model_errorappend(crc250,"\n")
       return
    end if
    do ii=1,newLoc%csli
       if (css%sli_2trg(ii).le.0) then
          if (mod_bdeb) then
             write(*,*)myname,'Invalid index:',css%csli,ii
             do jj=1,css%csli
                write(*,*)myname,'   index:',jj,css%sli_2trg(jj)
             end do
          end if
          irc=344
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Invalid index.")
          call model_errorappendi(crc250,css%sli_2trg(ii))
          call model_errorappend(crc250,"\n")
          return
       end if
       if(mod_bdeb.and.locid.lt.10)write(*,*)myname,'Slice target:',&
            & ii,css%trg_val(css%sli_2trg(ii)),css%sli_2trg(ii)
       newLoc%sli_val(ii)=css%trg_val(css%sli_2trg(ii))
    end do
    newLoc%cobs=css%cobs
    allocate(newLoc%obs_val(newLoc%cobs),newLoc%obs_vok(newLoc%cobs),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate newLoc%obs_val.")
       call model_errorappendi(crc250,newLoc%cobs)
       call model_errorappend(crc250,"\n")
       return
    end if
    do ii=1,newLoc%cobs
       if(mod_bdeb.and.locid.lt.10)write(*,*)myname,'Obs target:',ii,css%obs_val(ii)
       newLoc%obs_val(ii)=css%obs_val(ii)
       newLoc%obs_vok(ii)=css%obs_vok(ii)
    end do
    newLoc%ctrg=css%ctrg
    allocate(newLoc%trg_val(newLoc%ctrg),&
         & newLoc%trg_vok(newLoc%ctrg),&
         & newLoc%trg_set(newLoc%ctrg),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate newLoc%trg_val.")
       call model_errorappendi(crc250,newLoc%csli)
       call model_errorappend(crc250,"\n")
       return
    end if
    do ii=1,newLoc%ctrg
       newLoc%trg_val(ii)=0.0D0
       newLoc%trg_set(ii)=.false.
    end do
    ! push onto stack
    css%nloc=css%nloc + 1
    newLoc%prev => css%lastLoc%prev
    newLoc%next => css%lastLoc
    newLoc%prev%next => newLoc
    newLoc%next%prev => newLoc
    css%locReady=.false.
    if (css%nloc+css%locoo .ne. locid) then
       irc=346
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Non-sequential locid:")
       call model_errorappendi(crc250,locid)
       call model_errorappend(crc250,"<>")
       call model_errorappendi(crc250,css%nloc+css%locoo)
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb.and.locid.lt.10)write(*,*)myname,' Done.'
    return
  end subroutine model_locpushTarget
  !
  subroutine model_setfilter(css,flt,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    character*(*) :: flt
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    character*22 :: myname="model_setfilter"
    !if(mod_bdeb)write(*,*)myname,' Entering.',irc
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       css%flt250=trim(flt)
       call chop0(css%flt250,250)
       css%lenf=length(css%flt250,250,10)
       if(mod_bdeb)write(*,*)myname,"Filter:'"//css%flt250(1:css%lenf)//"'",irc
    end if
  end subroutine model_setfilter
  !
  subroutine model_compileFilter(css,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_compileFilter"
    integer :: ii
    if (css%lenf.ne.0) then
       call parse_open(css%psf,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from parse_open.")
          return
       end if
       call model_setMPO(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from setMPO.")
          return
       end if
       call parse_parsef(css%psf,css%flt250(1:css%lenf),css%mpo_var,crc250,irc)
       if (irc.ne.0) then
          if(mod_bdeb)then
             write(*,*)myname,"Unable to parse:'"//css%flt250(1:css%lenf)//"'"
             ! write(*,*)myname,'nvar:',css%ntrg
             ! do jj=1,css%ntrg
             ! write(*,*) myname,'var:',jj,css%mpo_var(jj)(1:css%mpo_lenv(jj))
             ! end do
          end if
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from parsef.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       call parse_used(css%psf,css%mpo_req)
       call model_getMPO(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from getMPO.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    return
  end subroutine model_compileFilter
  !
  ! compile expressions
  !
  subroutine model_compileExpr(css,nexp,exp250,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    integer :: nexp
    character*250,allocatable :: exp250(:)
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_compileExpr"
    integer :: ii,lene
    integer, external :: length
    if(mod_bdeb)write(*,*)myname,' Entering.',irc,nexp,size(exp250)
    call model_setMPO(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from setMPO.")
       return
    end if
    if(mod_bdeb)write(*,*)myname,'InitPSP.'
    css%cpsp=nexp
    call model_initPSP(css%cpsp,css%psp,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from initPSP.")
       return
    end if
    if(mod_bdeb)write(*,*)myname,'Checking.',associated(css),allocated(exp250)
    if(mod_bdeb)write(*,*)myname,'Checking.',css%cpsp,size(exp250)
    if (css%cpsp > size(exp250)) then
       irc=944
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"System error.")
       call model_errorappendi(crc250,nexp)
       call model_errorappendi(crc250,css%cpsp)
       call model_errorappendi(crc250,size(exp250))
       return
    end if
    if (mod_bdeb) then
       do ii=1,css%cmpo
          write(*,'(X,A,A,I0,A)') myname,"      var(",ii,")='"//&
               & css%mpo_var(ii)(1:css%mpo_lenv(ii))//"'"
       end do
    end if
    if(mod_bdeb)write(*,*)myname,'Parse.',css%cpsp,size(css%mpo_var)
    do ii=1,css%cpsp
       lene=length(exp250(ii),250,10)
       if(mod_bdeb)write(*,*)myname,'Parse:',ii,exp250(ii)(1:lene)
       call parse_parsef(css%psp(ii)%ptr,exp250(ii)(1:lene),css%mpo_var,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,"parse_parsef")
          return
       end if
       call parse_used(css%psp(ii)%ptr,css%mpo_req)
    end do
    call model_getMPO(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from getMPO.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_compileExpr
  !
  ! evaluate expressions
  !
  subroutine model_evalExpr(css,nexp,cval50,clen,crc250,irc)
    use parse
    implicit none
    type(mod_session), pointer :: css !  current session
    integer :: nexp
    character*50 :: cval50(nexp)
    integer :: clen(nexp)
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_evalExpr"
    real :: val(nexp)
    logical :: set(nexp)
    character(len=:), allocatable :: cbuff   ! parse string buffer
    integer :: ii
    do ii=1,css%cpsp
       call parse_evals(css%psp(ii)%ptr,css%mpo_val,css%mpo_vok,&
            & val(ii),set(ii),crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from evals.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       if (set(ii)) then
          if (parse_string(css%psp(ii)%ptr,cbuff)) then
             cval50(ii)=cbuff
             clen(ii)=len_trim(cbuff)
             deallocate(cbuff)
          else
             call model_wash(val(ii),cval50(ii),clen(ii))
          end if
       else
          cval50(ii)="NA"
          clen(ii)=2
       end if
    end do
    return
  end subroutine model_evalExpr
  !
  ! initialise expression-parsing array (PSP)
  !
  subroutine model_initPSP(npsp,psp,crc250,irc)
    implicit none
    integer :: npsp
    type(parse_pointer), pointer :: psp(:) ! parsepointer
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_initPSP"
    integer :: ii
    call model_clearPSP(psp,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,"clearPSP.")
       return
    end if
    allocate(psp(npsp),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,"allocate PSP error.")
       return
    end if
    do ii=1,npsp
       call parse_open (psp(ii)%ptr,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,"parse_open")
          return
       end if
    end do
  end subroutine model_initPSP
  !
  ! clear PSP array
  !
  subroutine model_clearPSP(psp,crc250,irc)
    implicit none
    type(parse_pointer), pointer :: psp(:) !  current session
    character*250 :: crc250
    integer :: irc
    integer :: ii
    character*22 :: myname="model_clearPSP"
    if(mod_bdeb)write(*,*)myname,' Entering.',irc,associated(psp)
    if (associated(psp)) then
       do ii=1,size(psp)
          if (associated(psp(ii)%ptr)) then
             call parse_close (psp(ii)%ptr,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,"parse_close")
                return
             end if
          end if
       end do
       deallocate(psp)
    end if
  end subroutine model_clearPSP
  !
  ! set Model- + Observation- variables (used for parsing)
  !
  subroutine model_setMPO(css,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_setMPO"
    integer :: ii
    if (css%mpo_set) return ! filter-variables is already set
    css%cmpo=css%ctrg+css%cobs
    if(mod_bdeb)write(*,*)myname,"Parsing: '"//css%flt250(1:css%lenf)//"'",&
         & css%cmpo,css%ctrg,css%cobs
    if (allocated(css%mpo_var)) deallocate(css%mpo_var)
    if (allocated(css%mpo_lenv)) deallocate(css%mpo_lenv)
    if (allocated(css%mpo_req)) deallocate(css%mpo_req)
    if (allocated(css%mpo_vok)) deallocate(css%mpo_vok)
    if (allocated(css%mpo_val)) deallocate(css%mpo_val)
    allocate(css%mpo_var(css%cmpo),css%mpo_lenv(css%cmpo),&
         & css%mpo_req(css%cmpo),css%mpo_vok(css%cmpo),&
         & css%mpo_val(css%cmpo),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'filter'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    do ii=1,css%ctrg
       css%mpo_var(ii)=css%trg80(ii)(1:css%trg_lent(ii))
       css%mpo_lenv(ii)=css%trg_lent(ii)
       css%mpo_req(ii)=.false.
       css%mpo_vok(ii)=.false.
    end do
    do ii=1,css%cobs
       css%mpo_var(ii+css%ctrg)=css%obs_var(ii)(1:css%obs_lenv(ii))
       css%mpo_lenv(ii+css%ctrg)=css%obs_lenv(ii)
       css%mpo_req(ii+css%ctrg)=.false.
       css%mpo_vok(ii+css%ctrg)=.false.
    end do
    css%mpo_set=.true.
    if(mod_bdeb)write(*,*)myname,"Done.",css%ctrg,css%cobs,css%cmpo
    return
  end subroutine model_setMPO
  !
  subroutine model_getMPO(css,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_getMPO"
    integer :: ii
    do ii=1,css%ctrg
       if (css%mpo_req(ii)) then
          !write(*,'(X,A,X,A,X,I0,A)')myname,&
          !     & "Used: trg_mod(",ii,")->'"//css%trg80(ii)(1:css%trg_lent(ii))//"'"
          css%trg_req(ii)=.true.
       end if
    end do
    do ii=1,css%cobs
       if (css%mpo_req(ii+css%ctrg)) then
          !write(*,'(X,A,X,A,X,I0,A)')myname,&
          !     & "Used: trg_obs(",ii,")->'"//css%obs_var(ii)(1:css%obs_lenv(ii))//"'"
          css%obs_req(ii)=.true.
       end if
    end do
    if(mod_bdeb)write(*,*)myname,"Done.",css%ctrg,css%cobs,css%cmpo
    return
  end subroutine model_getMPO
  !
  subroutine model_getfilter(css,flt,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    character*(*) :: flt
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_getfilter"
    if(mod_bdeb)write(*,*)myname,' Entering.',irc
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       flt=css%flt250(1:css%lenf)
       if(mod_bdeb)write(*,*)myname,"Filter:'"//css%flt250(1:css%lenf)//"'",irc
    end if
    !if(mod_bdeb)write(*,*)myname,'Exiting.',irc
  end subroutine model_getfilter
  !
  ! Get arrays from MODEL POS
  !
  subroutine model_locprint(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(mod_location), pointer :: currentLoc => null()
    integer, external :: length
    integer :: lenn,lenb,leng,ii
    integer :: cnt=0
    character*250 :: buff250
    character*50 :: num50
    character*25 :: myname="model_locprint"
    if(mod_bdeb)write(*,*)myname,' Entering.'
    if (associated(css%firstLoc).and.css%nloc.gt.0) then
       currentLoc => css%firstLoc%next
       do while (.not.associated(currentLoc,target=css%lastLoc))
          cnt=cnt+1
          buff250=""
          lenb=0
          do ii=1,currentLoc%csli
             write(num50,*)currentLoc%sli_val(ii)
             call chop0(num50,50)
             lenn=length(num50,50,10)
             leng=css%sli_lenv(ii)
             buff250=buff250(1:lenb)//" "//css%sli_v80(ii)(1:leng)//"="//num50(1:lenn)
             call chop0(buff250,250)
             lenb=length(buff250,250,10)
          end do
          write(*,'(X,A,I0,X,A)') &
               & myname, &
               & currentLoc%locid, &
               & buff250(1:lenb)
          currentLoc => currentLoc%next
       end do
    end if
    if(mod_bdeb)write(*,*)myname,' Number of locations:',cnt
    if(mod_bdeb)write(*,*)myname,' Done.'
  end subroutine model_locprint
  !
  ! delete loc froms stack
  !
  subroutine model_deleteLoc (css,loc, crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_location), pointer :: loc
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    character*25 :: myname="model_deleteLoc"
    if (associated(loc)) then
       css%nloc = css%nloc - 1
       loc%next%prev => loc%prev
       loc%prev%next => loc%next
       if (allocated(loc%sli_val))  deallocate(loc%sli_val)
       if (allocated(loc%trg_val))  deallocate(loc%trg_val)
       if (allocated(loc%trg_vok))  deallocate(loc%trg_vok)
       if (allocated(loc%trg_set)) deallocate(loc%trg_set)
       if (allocated(loc%obs_val))  deallocate(loc%obs_val)
       if (allocated(loc%obs_vok))  deallocate(loc%obs_vok)
       if (allocated(loc%pos))      deallocate(loc%pos)
       if (allocated(loc%rpos))     deallocate(loc%rpos)
       if (allocated(loc%intpf))    deallocate(loc%intpf)
       if (allocated(loc%lstart))   deallocate(loc%lstart)
       if (allocated(loc%lstop))    deallocate(loc%lstop)
       if (allocated(loc%search))    deallocate(loc%search)
       deallocate(loc)
    end if
    return
  end subroutine model_deleteLoc
  !
  subroutine model_makeLocList(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(mod_location), pointer :: currentLoc => null()
    character*25 :: myname="model_makeLocList"
    integer :: ii
    if(mod_bdeb)write(*,*)myname,' Entering:',irc
    if (associated(css%firstLoc).and..not.css%locready.and.css%nloc.gt.0) then
       if (allocated(css%locdata)) deallocate(css%locdata)
       allocate(css%locdata(css%nloc),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to allocate locid,lat,lon.")
          call model_errorappendi(crc250,css%nloc)
          call model_errorappend(crc250," , ")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       ii=0
       currentLoc => css%firstLoc%next
       do while (.not.associated(currentLoc,target=css%lastLoc))
          ii=ii+1
          css%locdata(ii)%ptr=>currentLoc
          css%locdata(ii)%ptr%iloc=ii
          currentLoc => currentLoc%next
       end do
       css%locReady=.true.
    end if
    if(mod_bdeb)write(*,*)myname,' Done:',css%locReady,irc
    return
  end subroutine model_makeLocList
  !
  !###############################################################################
  ! OUTPUT ROUTINES
  !###############################################################################
  ! allocate output
  !
  subroutine model_allocateTable(css,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250  ! error message string
    integer :: irc        ! error return code(0=ok)
    integer :: ii,jj
    character*25 :: myname="model_allocateTable"
    ! remove output variables
    if (associated(css%oval)) deallocate(css%oval)
    if (associated(css%oset)) deallocate(css%oset)
    css%oloc=css%nloc
    css%otrg=css%ctrg
    allocate(css%oval(css%otrg,css%oloc),css%oset(css%otrg,css%oloc),stat=irc)
    do ii=1,css%oloc
       do jj=1,css%otrg
          css%oset(jj,ii)=.false.
       end do
    end do
    return
  end subroutine model_allocateTable
  !
  subroutine model_deallocateTable(css,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250  ! error message string
    integer :: irc        ! error return code(0=ok)
    integer :: ii,jj
    character*25 :: myname="model_allocateTable"
    ! remove output variables
    if (associated(css%oval)) deallocate(css%oval)
    if (associated(css%oset)) deallocate(css%oset)
    css%oloc=0
    css%otrg=0
    return
  end subroutine model_deallocateTable
  !
  subroutine model_setOutVal(css,val,itrg,iloc,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    real :: val           ! output value
    integer :: itrg       ! output target position
    integer :: iloc       ! output location position
    character*250 :: crc250  ! error message string
    integer :: irc        ! error return code(0=ok)
    integer :: ii,jj
    character*25 :: myname="model_setOutVal"
    if (.not.associated(css%oval).or..not.associated(css%oset)) then
       irc=946
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Output not allocated.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if (iloc.le.0.or.iloc.gt.css%oloc) then
       irc=945
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Invalid iloc.")
       call model_errorappendi(crc250,iloc)
       call model_errorappendi(crc250,css%oloc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if (itrg.le.0.or.itrg.gt.css%otrg) then
       irc=944
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Invalid itrg.")
       call model_errorappendi(crc250,itrg)
       call model_errorappendi(crc250,css%otrg)
       call model_errorappend(crc250,"\n")
       return
    end if
    css%oval(itrg,iloc)=val
    css%oset(itrg,iloc)=.true.
    return
  end subroutine model_setOutVal
  !
  logical function model_getOutput(css,val,itrg,iloc,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    real :: val           ! output value
    integer :: itrg       ! output target position
    integer :: iloc       ! output location position
    character*250 :: crc250  ! error message string
    integer :: irc        ! error return code(0=ok)
    integer :: ii,jj
    character*25 :: myname="model_getOutput"
    model_getOutput=.false.
    if (.not.associated(css%oval).or..not.associated(css%oset)) then
       irc=943
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Output not allocated.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if (iloc.le.0.or.iloc.gt.css%oloc) then
       irc=942
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Invalid iloc.")
       call model_errorappendi(crc250,iloc)
       call model_errorappendi(crc250,css%oloc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if (itrg.le.0.or.itrg.gt.css%otrg) then
       irc=941
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Invalid itrg.")
       call model_errorappendi(crc250,itrg)
       call model_errorappendi(crc250,css%otrg)
       call model_errorappend(crc250,"\n")
       return
    end if
    val=css%oval(itrg,iloc)
    model_getOutput=.true.
    return
  end function model_getOutput
  !
  !
  !###############################################################################
  ! STRING ROUTINES FOR REPORTING
  !###############################################################################
  ! get description of indexes
  !
  character*250 function model_getdesc250(fpos,f,v,crc250,irc)
    integer :: fpos                   ! current dimension index 
    type(mod_file),pointer :: f
    type(mod_variable),pointer :: v
    character*250 :: crc250  ! error message string
    integer :: irc        ! error return code(0=ok)
    integer, external :: length
    integer :: leni,lenc,lenb,lend,lens
    integer :: cpos,xsize
    integer :: ii,jj
    character*250 :: buff250
    character*10 :: ccdim10
    logical :: bok
    integer, allocatable :: cdim(:)
    character*25 :: myname="model_getdesc250"

    allocate(cdim(max(1,v%ndim)),stat=irc)
    cpos= (fpos-1)
    buff250=""
    lenb=0
    if (fpos.ne.-1) then
       do ii=1,v%ndim
          cdim(ii)=1+v%istart(ii)+mod(cpos,max(1,v%icount(ii)))
          cpos=int(cpos/max(1,(v%icount(ii))))
       end do
       ! print other dimensions
       do ii=1,v%ndim
          write(ccdim10,'(I10)')cdim(ii)
          call chop0(ccdim10,10)
          lenc=length(ccdim10,10,10)
          lend=length(f%dim80(v%ind(ii)),80,10)
          buff250=sep//f%dim80(v%ind(ii))(1:lend)//sep//ccdim10(1:lenc)//buff250(1:lenb)
          call chop0(buff250,250)
          lenb=length(buff250,250,max(1,min(250,lenb)))
       end do
    end if
    !write(*,*)myname,"DESC:",buff250(1:lenb),nslice
    call chop0(buff250,250)
    model_getdesc250=buff250
    if (allocated(cdim)) deallocate(cdim)
  end function model_getdesc250
  !
  ! get value and attributes
  !
  character*250 function model_getGrid250(f,v,loc,ff,val,wgt,crc250,irc)
    type(mod_file),pointer :: f   ! file
    type(mod_variable),pointer :: v     ! variable
    type(mod_location),pointer :: loc   ! location
    integer :: ff                       ! current offset
    real :: val                         ! value
    real :: wgt                         ! weight
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_getGrid250"
    integer ::lenp,lenv,lenw,ii
    character*250 :: pos250
    character*50 :: val50
    character*50  :: wgt50
    character*10 :: pos10
    integer, external :: length
    ! <value pos="1,21,100" val="3499.2"/>
    ! make dimension string

    pos250=model_getPos50(v,loc,ff)
    call chop0(pos250,250)
    lenp=length(pos250,250,10)
    if (lenp.ne.0) then
       pos250=' pos="'//pos250(1:lenp)//'"'
       lenp=lenp+7
    end if
    !
    ! make value string
    if (val.eq.nf_fill_double) then
       if(mod_bdeb)write(*,*)myname,'Match:',val,nf_fill_double,&
            & val.eq.nf_fill_double,val-nf_fill_double
       val50=""
       lenv=0
    else
       if(mod_bdeb)write(*,*)myname,'No match:',val,nf_fill_double,&
            & val.eq.nf_fill_double,val-nf_fill_double
       call model_wash(val,val50,lenv)
       val50=' val="'//val50(1:lenv)//'"'
       lenv=lenv+7
    end if
    if (.false. .and. wgt.ge.0.0D0) then
       call model_wash(wgt,wgt50,lenw)
       wgt50=' wgt="'//wgt50(1:lenw)//"'"
       lenw=lenw+7
    else
       lenw=0
    end if

    !
    model_getGrid250='<grid '//pos250(1:lenp)//val50(1:lenv)//wgt50(1:lenw)//'/>'
    return
  end function model_getGrid250
  !
  ! write interpolated value
  !
  character*250 function model_getInt250(f,v,loc,val,crc250,irc)
    type(mod_file),pointer :: f   ! file
    type(mod_variable),pointer :: v     ! variable
    type(mod_location),pointer :: loc   ! location
    real :: val                         ! interpolated value
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_getInt250"
    integer ::lenv,ii
    character*50 :: val50
    character*10 :: pos10
    integer, external :: length
    ! <value val="3499.2"/>
    ! make dimension string

    ! make value string
    if (val.eq.nf_fill_double) then
       if(mod_bdeb)write(*,*)myname,'Match:',val,nf_fill_double,&
            & val.eq.nf_fill_double,val-nf_fill_double
       val50=""
       lenv=0
    else
       if(mod_bdeb)write(*,*)myname,'No match:',val,nf_fill_double,&
            & val.eq.nf_fill_double,val-nf_fill_double
       call model_wash(val,val50,lenv)
       val50=' val="'//val50(1:lenv)//'"'
       lenv=lenv+7
    end if
    !
    if (lenv.eq.0) then
       model_getInt250=''
    else
       model_getInt250='<interpolated'//val50(1:lenv)//'/>'
    end if
    return
  end function model_getInt250
  !
  ! get location attributes
  !
  subroutine model_getTarget50(trg,lent,trg50)
    real :: trg
    integer :: lent
    character*50 :: trg50
    integer, external :: length
    ! make target string
    call model_wash(trg,trg50,lent)
    trg50="val='"//trg50(1:lent)//"'"
    lent=lent+8
    return
  end subroutine model_getTarget50
  !
  ! get position string
  !
  character*50 function model_getPos50(v,loc,ff)
    type(mod_variable), pointer :: v
    type(mod_location), pointer :: loc
    integer ::                     ff   ! offset
    character*50 :: buff50
    character*10 :: item10
    integer :: lenb,leni
    integer, external :: length
    integer :: ii,jj,xx
    character*25 :: myname="model_writePos"
    buff50=""
    lenb=0
    do ii=1,v%ndim
       write(item10,'(I10)') loc%pos(v%ind(ii),ff)
       call chop0(item10,10)
       leni=length(item10,10,3)
       if (lenb.eq.0) then
          buff50=item10(1:leni)
          lenb=leni
       else
          buff50=buff50(1:lenb)//","//item10(1:leni)
          lenb=lenb+leni+1
       end if
    end do
    model_getPos50=buff50
    return
  end function model_getPos50
  !
  ! get position string with weights
  !
  character*50 function model_getPosWgt50(css,v,loc,ff)
    type(mod_session), pointer :: css   ! current session
    type(mod_variable),pointer :: v     ! variable
    type(mod_location),pointer :: loc   ! location
    integer :: ff
    character*50 :: buff50
    character*20 :: pos20
    integer :: lenb,lenp
    integer, external :: length
    integer :: ii,jj,xx
    character*25 :: myname="model_getPosWgt50"
    buff50=""
    lenb=0
    do ii=1,v%ndim
       if (loc%intpf(v%ind(ii),ff).lt.0.0D0.or.loc%intpf(v%ind(ii),ff).gt.1.0D0) then
          if (loc%lstart(v%ind(ii),ff).ne.loc%lstop(v%ind(ii),ff)) then
             write(pos20,'(I0,"..",I0)') loc%lstart(v%ind(ii),ff),loc%lstop(v%ind(ii),ff)
          else
             write(pos20,'(I0)') loc%lstart(v%ind(ii),ff)
          end if
       else
          write(pos20,'(F20.4)') real(loc%lstart(v%ind(ii),ff))+loc%intpf(v%ind(ii),ff)
       end if
       call chop0(pos20,20)
       lenp=length(pos20,20,3)
       if (lenb.eq.0) then
          buff50=pos20(1:lenp)
          lenb=lenp
       else
          buff50=buff50(1:lenb)//","//pos20(1:lenp)
          lenb=lenb+lenp+1
       end if
    end do
    model_getPosWgt50=buff50
    return
  end function model_getPosWgt50
  !
  ! set location rpos
  !
  subroutine model_setLocRpos(file,varid,loc,ff)
    type(mod_file), pointer :: file     ! file
    integer :: varid                    ! variable id
    type(mod_location),pointer :: loc   ! location
    integer :: ff ! offset
    character*50 :: buff50
    character*20 :: pos20
    integer :: lenb,lenp
    integer, external :: length
    integer :: ii, itrg
    type(mod_variable),pointer :: v     ! variable
    character*25 :: myname="model_getPosWgt50"
    v => file%var(varid)%ptr
    do ii=1,v%ndim
       itrg=file%dim_trg(v%ind(ii))
       if (itrg.ne.0) then ! dimension is a target
          if (loc%intpf(v%ind(ii),ff).lt.0.0D0.or.loc%intpf(v%ind(ii),ff).gt.1.0D0) then
             loc%rpos(v%ind(ii),ff)=loc%lstart(v%ind(ii),ff)
          else
             loc%rpos(v%ind(ii),ff)=real(loc%lstart(v%ind(ii),ff))+&
                  & loc%intpf(v%ind(ii),ff)
          end if
          if (mod_bdeb)write(*,*)myname,"VVariable '"//&
               & v%var80(1:v%lenv)//"' dim:",ii," dim_trg=",&
               & itrg,loc%rpos(v%ind(ii),ff)
       elseif (mod_bdeb) then
          write(*,*)myname,"VVariable '"//&
               & v%var80(1:v%lenv)//"' dim:",ii,' no dim target.'
       end if
    end do
    return
  end subroutine model_setLocRpos
  !
  ! returns time as character-string
  !
  character*21 function model_gettime(j2000) 
    implicit none
    real :: j2000
    integer :: yy,mm,dd,hh,mi
    real :: sec
    character*4 :: csec
    integer, external :: length
    integer :: lenp,lenc
    character*25 :: myname="model_gettime"
    call dj2000(j2000,yy,mm,dd,hh,mi,sec)
    write(csec,'(F4.1)') sec
    call chop0(csec,4)
    lenc=length(csec,4,4)
    if (sec.lt.10.0D0)  csec="0"//csec(1:lenc)
    write(model_gettime,'(I4.4,"/",I2.2,"/",I2.2," ",I2.2,":",I2.2,":",A4)') &
         & yy,mm,dd,hh,mi,csec
!!!!! write(*,*) myname,j2000,model_gettime
  end function model_gettime

  real function  model_getj2000(time50,crc250,irc) 
    implicit none
    character*50 :: time50
    character*250 :: crc250
    integer :: irc
    real :: j2000
    integer, external :: length
    integer :: lenp,lent
    character*25 :: myname="model_getj2000"
    integer :: yy,mm,dd,hh,mi
    real :: sec
    ! first try to read as formatted time
    read(time50,'(I4,X,I2,X,I2,X,I2,X,I2,X,F4.1)',iostat=irc)yy,mm,dd,hh,mi,sec
    if (irc.eq.0) then
       call jd2000(j2000,yy,mm,dd,hh,mi,sec)
    else
       read(time50,*,iostat=irc)j2000
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to determine time from:")
          call model_errorappend(crc250,time50)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    model_getj2000=j2000
    !lent=length(time50,50,10)
    if(mod_bdeb)write(*,*)myname,' Time:',time50(1:lent)," Found:",j2000
  end function model_getj2000
  !
  character*250 function model_getvar250(f,varid)
    implicit none
    type(mod_file),pointer :: f
    integer :: varid
    character*50 :: dim50
    integer :: lend
    integer, external :: length
    character*25 :: myname="model_getVar250"
    if (associated(f)) then
       if (associated(f%var(varid)%ptr)) then
          dim50=model_getDim(f,f%var(varid)%ptr)
          call chop0(dim50,50)
          lend=length(dim50,50,10)
          if (lend.eq.0) then
             model_getvar250="variable='"// &
                  & f%var(varid)%ptr%var80(1:f%var(varid)%ptr%lenv)//"'"
          else
             model_getvar250="variable='"// &
                  & f%var(varid)%ptr%var80(1:f%var(varid)%ptr%lenv)&
                  & //"' dim='"//dim50(1:lend)//"'"
          end if
       else
          if(mod_bdeb)write(*,*)myname,'Invalid varid:',varid,associated(f%var)
          model_getvar250="Ivalid varid."
       end if
    else
       if(mod_bdeb)write(*,*)myname,'Invalid f:',varid,associated(f)
       model_getvar250="Ivalid f."
    end if
    call chop0(model_getvar250,250)
    return
  end function model_getvar250
  !
  !###############################################################################
  ! ROUTINES FOR LOCATION SEARCH
  !###############################################################################
  ! location position
  !
  subroutine model_initLocPos(css,f,p,b,loc,crc250,irc)
    type(mod_session), pointer :: css   ! current session
    type(mod_file),pointer :: f   ! current file
    type(mod_batch), pointer :: b       ! current batch
    type(mod_location),pointer :: loc   ! location
    type(mod_plan),pointer :: p
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_initLocPos"
    integer :: ii,ff
    logical :: changed
    !
    ! loc
    !
    if (allocated(loc%pos)) deallocate(loc%pos)
    if (allocated(loc%rpos)) deallocate(loc%rpos)
    if (allocated(loc%intpf)) deallocate(loc%intpf)
    if (allocated(loc%lstart)) deallocate(loc%lstart)
    if (allocated(loc%lstop)) deallocate(loc%lstop)
    if (allocated(loc%search)) deallocate(loc%search)
    loc%ndim=f%ndim
    allocate(loc%pos(loc%ndim,0:css%noffsetIndexes),&
         & loc%rpos(loc%ndim,0:css%noffsetIndexes),&
         & loc%intpf(loc%ndim,0:css%noffsetIndexes),&
         & loc%lstart(loc%ndim,0:css%noffsetIndexes),&
         & loc%lstop(loc%ndim,0:css%noffsetIndexes),&
         & loc%search(0:css%noffsetIndexes),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate 'loc%pos/istop/ff'.")
       call model_errorappend(crc250,"\n")
       return
    end if
    do ff=0,css%noffsetIndexes
       do ii=1,loc%ndim
          loc%pos(ii,ff)=1
          loc%rpos(ii,ff)=0.0D0
          loc%intpf(ii,ff)=-1.0D0
          loc%lstart(ii,ff)=1
          loc%lstop(ii,ff)=f%istop(ii)
       end do
       loc%search(ff)=0
    end do
    return
  end subroutine model_initLocPos
  !
  subroutine model_clearLocList(css,crc250,irc)
    type(mod_session), pointer :: css   ! current session
    type(mod_location),pointer :: loc   ! location
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_clearLocList"
    integer :: ii
    logical :: changed
    if (allocated(css%locData)) then
       do ii=1,css%nloc
          loc => css%locData(ii)%ptr
          call model_deleteLoc(css,loc,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,"model_deleteLoc")
             return
          end if
       end do
       css%nloc=0 ! should not be necessary
       deallocate(css%locData)
    end if
    css%locReady=.false.
    return
  end subroutine model_clearLocList
  !
  subroutine model_search(css,f,p,b,loc,crc250,irc)
    type(mod_session), pointer :: css   ! current session
    type(mod_file),pointer :: f   ! current file
    type(mod_batch), pointer :: b       ! current batch
    type(mod_location),pointer :: loc   ! location
    type(mod_plan),pointer :: p
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_search"
    integer :: ii
    logical :: changed
    integer :: ff ! offset
    !
    ! make position, variable and target vector
    !
    do ff=0,css%noffsetIndexes ! loop over offset
       !
       do ii=1,b%ndim
          loc%pos(b%ind(ii),ff)=1  ! initialise position
       end do
       !
       call model_getTarget(css,f,p,b,loc,ff,crc250,irc) ! set slice targets with offset
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from getTarget.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       !
       ! print searched dimensions
       !
       if(mod_bdeb)then
          write(*,*) myname,"Vars:",(" "//&
               & f%var80(b%var(ii))(1:f%lenv(b%var(ii))),ii=1,b%nvar)
          write(*,*) myname,"Dims:",(" "//&
               & f%dim80(b%ind(ii))(1:f%lend(b%ind(ii))),ii=1,b%ndim)
       end if
       !
       ! loop until position vector does not change
       !
       changed=.true.
       do while(changed)
          ! get increment vectors
          if (mod_bdeb) write(*,*)myname,'Looking for increments.'
          call model_getIncrements(f,b,loc,ff,changed,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from getIncrements.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       end do
       if (mod_bdeb) write(*,*)myname,'Setting search flags.'
       call model_setSearchFlag(f,b,loc,0,crc250,irc) ! search flag depends only on 0-offset
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from setSearchFlag.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       if (mod_bdeb) then
          do ii=1,b%ndim
             write(*,*)myname,"Search limits='"//&
                  & f%dim80(b%ind(ii))(1:f%lend(b%ind(ii)))//"'",&
                  & loc%lstart(b%ind(ii),ff),loc%lstop(b%ind(ii),ff),&
                  & ' intp=',loc%intpf(b%ind(ii),ff)
          end do
          write(*,*)myname,' Done.',loc%search(0)
       end if
    end do
    return
  end subroutine model_search
  !
     ! set the batch target
  !
  subroutine model_getTarget(css,f,p,b,loc,ff,crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_file),pointer :: f       ! current file
    type(mod_batch), pointer :: b     ! current batch
    type(mod_location),pointer :: loc ! location
    type(mod_plan),pointer :: p
    integer :: ff ! offset
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_getTarget"
    type(mod_offset),pointer :: off
    real :: val
    integer :: ii
    ! if target is a dimension, set pos, else set target
    if (mod_bdeb) write(*,*)myname,'Offset:',ff, associated(css%offset)
    off => css%offset(ff)%ptr
    do ii=1,b%nvar
       if (b%var2sli(ii).ne.0) then
          if (off%sli_set(b%var2sli(ii))) then ! add variable offset
             b%trgvar(ii)=loc%sli_val(b%var2sli(ii))  + &
               & parse_evalf(off%sli_psp(b%var2sli(ii))%ptr,loc%sli_val,crc250,irc)
          else
             b%trgvar(ii)=loc%sli_val(b%var2sli(ii))
          end if 
          p%trgvar(b%var(ii))=b%trgvar(ii)
       else
          irc=347
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Missing target variable:"//&
               & f%var80(b%var(ii)) )
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end do
    do ii=1,b%ndim
       if (b%dim2sli(ii).ne.0) then
          val=loc%sli_val(b%dim2sli(ii))
          if (off%sli_set(b%dim2sli(ii))) then ! add dimension offset
             val=val + parse_evalf(off%sli_psp(b%dim2sli(ii))%ptr,loc%sli_val,crc250,irc)
          end if
          loc%pos(b%ind(ii),ff) =  floor(val)
          loc%intpf(b%ind(ii),ff) =  val-floor(val)
          loc%lstart(b%ind(ii),ff) =  floor(val)
          loc%lstop(b%ind(ii),ff) = ceiling(val)
          if(mod_bdeb)write(*,*) myname,">>>>>>>Loc:",ii,&
               & loc%pos(b%ind(ii),ff),loc%lstart(b%ind(ii),ff),loc%lstop(b%ind(ii),ff)
       end if
    end do
    return
  end subroutine model_getTarget
  !
  ! get increment vectors (how much variables increase in each dimension)
  !
  subroutine model_getIncrements(f,b,loc,ff,changed,crc250,irc)
    type(mod_file),pointer :: f   ! current file
    type(mod_batch), pointer :: b       ! current batch
    type(mod_location), pointer :: loc       ! current location
    integer :: ff ! offset
    logical :: changed              ! did the grid cell change?
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_getIncrements"
    integer :: ii,jj,buff
    real :: nv(max(1,b%ndim),0:b%ndim)     ! normalised vector, 0=unperturbed
    call model_getIncrement(f,b,loc,ff,nv(1,0),crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from getIncrement.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    do jj=1,b%ndim
       if (b%dim2sli(jj).eq.0) then  ! this is a variable
          buff=loc%pos(b%ind(jj),ff)
          loc%pos(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)+b%inc(jj)
          b%inc(jj)=-b%inc(jj)
          !b%inc(jj)=-1
          call model_getIncrement(f,b,loc,ff,nv(1,jj),crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from getIncrement.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          b%inc(jj)=-b%inc(jj)
          !b%inc(jj)=1
          loc%pos(b%ind(jj),ff)=buff
       else                         ! this is a defined dimension
          do ii=1,b%ndim
             nv(ii,jj)=0.0D0
          end do
       end if
    end do
    call model_useIncrements(f,b,loc,ff,nv,changed,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from useIncrement.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
  end subroutine model_getIncrements
  !
  ! calculate increments in each dimension
  !
  subroutine model_getIncrement(f,b,loc,ff,nv,crc250,irc)
    type(mod_file),pointer :: f   ! current file
    type(mod_batch), pointer :: b       ! current batch
    type(mod_location),pointer :: loc   ! location
    integer :: ff ! offset
    real :: nv(b%ndim)                  ! normalised vector
    character*250 :: crc250             ! error message
    integer :: irc                      ! error return code (0=ok)
    character*25 :: myname="model_getIncrement"
    integer :: ii,jj,kk,buff
    real :: t(b%nvar)        ! target departure (using pos as origo)
    real :: v(b%nvar,b%ndim) ! value departure in grid dimension directions (gdd)
    real :: n(b%nvar,b%ndim) ! target departure projected to gdd
    real :: dot_nv, dot_vv   ! dot-products
    !
    ! get 0-value
    !
    call model_setBatchValue(f,b,loc,ff,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from setBatchValue.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    dot_nv=0.0D0
    do ii=1,b%nvar
       t(ii)=b%trgvar(ii) - b%val(ii)
       do jj=1,b%ndim
          v(ii,jj)=b%val(ii)
       end do
       dot_nv=dot_nv+t(ii)*t(ii)
    end do
    !
    ! get perturbed values (at other grid points)
    !
    dot_vv=0.0D0
    do jj=1,b%ndim
       if (b%dim2sli(jj).eq.0) then 
          buff=loc%pos(b%ind(jj),ff)
          loc%pos(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)+b%inc(jj)
          call model_setBatchValue(f,b,loc,ff,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from setBatchValue.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          loc%pos(b%ind(jj),ff)=buff
          do ii=1,b%nvar
             v(ii,jj)=b%val(ii)-v(ii,jj)
             dot_vv=dot_vv+v(ii,jj)*v(ii,jj)
          end do

          if(mod_bdeb)write(*,*)myname,'D(var)=',(v(ii,jj),ii=1,b%nvar)

       end if
    end do
    !
    ! v = grid increment (variable, dimension)
    ! n = target relative to grid and along desired dimension
    ! loop over dimensions and make normalised variable vector increments
    ! ...n(ii,jj)=n(ii,jj)-(n(,jj).v(,kk))*v(ii,kk)/(v(,kk)*v(,kk))...
    !
    if (dot_vv.le.1.0D-10) then
       if (dot_nv.lt.1.0D-10) then ! match target matches single value array
          do jj=1,b%ndim  ! desired dimension
             nv(jj)=0.0D0 ! initial value matches...
          end do
       else                        ! no match between target and variable (with dim=1)
          do jj=1,b%ndim   ! desired dimension
             nv(jj)=-1.0D0 ! out of bounds... (below)
          end do
       end if
    else
       do jj=1,b%ndim ! desired dimension
          if (b%dim2sli(jj).eq.0) then 
             do ii=1,b%nvar ! variable loop
                n(ii,jj)=t(ii)
             end do
             do kk=1,b%ndim ! remove projection along other dimensions than the desired one
                if (kk.eq.jj) cycle
                dot_nv=0.0D0
                dot_vv=0.0D0
                do ii=1,b%nvar
                   dot_nv=dot_nv+n(ii,jj)*v(ii,kk)
                   dot_vv=dot_vv+v(ii,kk)*v(ii,kk)
                end do
                do ii=1,b%nvar ! variable loop
                   n(ii,jj)=n(ii,jj)-v(ii,kk)*dot_nv/dot_vv
                end do
             end do
             !
             ! calculate n . v and v . v
             !
             dot_nv=0.0D0
             dot_vv=0.0D0
             do ii=1,b%nvar
                dot_nv=dot_nv + n(ii,jj)*v(ii,jj)
                dot_vv=dot_vv + v(ii,jj)*v(ii,jj)
             end do
             ! 
             ! increment (nn) == n . v / v . v, or = |n|/|v| 

             if(mod_bdeb)write(*,*)myname,'N(dim)=',jj,dot_nv,dot_vv,dot_nv/dot_vv


             nv(jj)=dot_nv/dot_vv ! extrapolation factor for reciprocal grid point...
             ! if factor is negative, target is outside grid cell in current direction
          else
             nv(jj)=0.0D0
          end if
       end do
    end if
    return
  end subroutine model_getIncrement
  !
  ! use increments in batch job
  !
  subroutine model_useIncrements(f,b,loc,ff,nv,changed,crc250,irc)
    type(mod_file),pointer :: f   ! current file
    type(mod_batch), pointer :: b       ! current batch
    type(mod_location),pointer :: loc   ! location
    integer :: ff ! offset
    real :: nv(b%ndim,0:b%ndim) ! extrapolation factors
    logical :: changed
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_useIncrements"
    integer :: jj
    real :: sum
    changed=.false.
    do jj=1,b%ndim
       if(mod_bdeb)write(*,*)myname,'Flags:',jj,(b%dim2sli(jj).ne.0),nv(jj,0),nv(jj,jj)
       if (b%dim2sli(jj).ne.0) cycle ! target is already set...
       if (nv(jj,0) .lt. 0) then ! decrement
          if (loc%pos(b%ind(jj),ff).gt.1) then
             loc%pos(b%ind(jj),ff)=max(1,loc%pos(b%ind(jj),ff)-&
                  & max(1,nint(-nv(jj,0)*0.61803399D0+0.5D0)))! -1
             changed=.true.
          end if
       else if (nv(jj,jj) .lt. 0) then ! increment
          if (loc%pos(b%ind(jj),ff).lt.f%istop(b%ind(jj))-1) then
             loc%pos(b%ind(jj),ff)=min(f%istop(b%ind(jj))-1,&
                  & loc%pos(b%ind(jj),ff)+max(1,-nint(nv(jj,jj)*0.61803399D0+0.5D0))) ! +1
             changed=.true.
          end if
       else
          sum=nv(jj,0)+nv(jj,jj)
          if (sum.gt.1.0D-10) then
             if (nv(jj,0).lt.1.0D-10) then ! target at initial grid point
                loc%intpf(b%ind(jj),ff)=nv(jj,0)/sum
                loc%lstart(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)
                loc%lstop(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)
             else if(nv(jj,jj).lt.1.0D-10) then ! target at incremential grid point
                loc%intpf(b%ind(jj),ff)=nv(jj,jj)/sum
                loc%lstart(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)+1
                loc%lstop(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)+1
             else ! target between initial and incremental grid points
                loc%intpf(b%ind(jj),ff)=nv(jj,0)/sum
                loc%lstart(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)
                loc%lstop(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)+1
             end if
             ! write(*,*)myname,'FF:',loc%intpf(b%ind(jj)),nv(jj,0),nv(jj,jj),sum
          else ! grid points and target all coincide
             loc%intpf(b%ind(jj),ff)=0.0D0
             loc%lstart(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)
             loc%lstop(b%ind(jj),ff)=loc%pos(b%ind(jj),ff)
          end if
       end if
    end do
    return
  end subroutine model_useIncrements
  !
  subroutine model_setSearchFlag(f,b,loc,ff,crc250,irc)
    type(mod_file),pointer :: f         ! current file
    type(mod_batch), pointer :: b       ! current batch
    type(mod_location),pointer :: loc   ! location
    integer :: ff                       ! offset
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setSearchFlag"
    integer :: jj
    real :: sum
    if (loc%bok) then
       loc%search(ff)=0
       do jj=1,b%ndim
          if (loc%lstart(b%ind(jj),ff).ne.loc%lstop(b%ind(jj),ff) .and. &
               & loc%lstart(b%ind(jj),ff)+1.ne.loc%lstop(b%ind(jj),ff) .and. &
               & (loc%intpf(b%ind(jj),ff).lt.0.0D0.or.loc%intpf(b%ind(jj),ff).gt.1.0D0)) then
             loc%search(ff)=b%ind(jj)
          end if
       end do
    else
       loc%search(ff)=-1
    end if
    return
  end subroutine model_setSearchFlag
  !
  ! get current batch values
  !
  subroutine model_setBatchValue(f,b,loc,ff,crc250,irc)
    type(mod_file),pointer :: f   ! current file
    type(mod_batch), pointer :: b       ! current batch
    type(mod_location), pointer :: loc       ! current batch
    integer :: ff ! offset
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setBatchValue"
    integer :: ii,kk,ll
    logical :: set
    type(mod_variable), pointer :: v
    do ii=1,b%nvar
       v => f%var(b%var(ii))%ptr
       set=.true.
       if (.not.model_getLocValue(v,loc,ff,b%val(ii),crc250,irc)) then
          b%val(ii)=nf_fill_double
       end if
    end do
    return
  end subroutine model_setBatchValue
  !
  ! get current batch values
  !
  logical function model_getLocValue(v,loc,ff,val,crc250,irc)
    type(mod_variable), pointer :: v       ! variable
    type(mod_location), pointer :: loc       ! current batch
    integer :: ff ! offset
    real :: val
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_getLocValue"
    integer :: ii
    character*50 :: pos50,loc50,val50
    integer :: lenp,lenl,lenv
    integer, external :: length
    if(mod_bdeb)write(*,*)myname,"Entering.",v%ndim,associated(loc)
    if (v%ndim.gt.0) then
       ii=model_getLoc(v,loc,ff)
    else 
       ii=1
    end if
    if(mod_bdeb)write(*,*)myname,"Past getLoc.",ii
    if (mod_bdeb) then
       write(loc50,'(I10)') ii
       call chop0(loc50,50,10)
       lenl=length(loc50,50,10)
       pos50=model_getPos50(v,loc,ff)
       call chop0(pos50,50,10)
       lenp=length(pos50,50,10)
       if (ii.lt.1.or.ii.gt.v%len) then
          write(*,*)myname," *** Invalid pos: '"&
               & //v%var80(1:v%lenv)//"("//pos50(1:lenp)//&
               & ")' loc=",ii,"(max=",v%len,")"
       end if
    end if
    if (ii.eq.0) then
       model_getLocValue=.false.
    else
       model_getLocValue=model_getValue(v,ii,val,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from getValue.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    if(mod_bdeb)then
       write(val50,*)model_getLocValue
       call chop0(val50,50,10)
       lenv=length(val50,50,10)
       write(*,*)myname,"Pos="//pos50(1:lenp)//&
            & " ll="//loc50(1:lenl)//" val="//val50(1:lenv),&
            & " set=",model_getLocValue
    end if
    return
  end function model_getLocValue
  !
  subroutine model_checkVariable(v,crc250,irc)
    type(mod_variable), pointer :: v       ! variable
    integer :: ii
    real :: val
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_checkValue"
    if (v%len.gt.0) then
       select case (v%type)
       case (nf_char)
       case (nf_int1)
          if (.not.allocated(v%f1)) then
             irc=941
             if (mod_bdeb) write(*,*)myname,'Invalid variable 1.'
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Invalid variable 1.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
          end if
       case (nf_int2)
          if (.not.allocated(v%f2)) then
             irc=942
             if (mod_bdeb) write(*,*)myname,'Invalid variable 2.'
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Invalid variable 2.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
          end if
       case (nf_int)
          if (.not.allocated(v%f4)) then
             irc=943
             if (mod_bdeb) write(*,*)myname,'Invalid variable 4.'
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Invalid variable 4.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
          end if
       case (nf_real)
          if (.not.allocated(v%fr)) then
             irc=944
             if (mod_bdeb) write(*,*)myname,'Invalid variable r.'
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Invalid variable r.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
          end if
       case (nf_double)
          if (.not.allocated(v%fd)) then
             irc=945
             if (mod_bdeb) write(*,*)myname,'Invalid variable d.'
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Invalid variable d.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
          end if
       case DEFAULT
          irc=946
          if (mod_bdeb) write(*,*)myname,'Invalid variable type.'
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Invalid variable type.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
       end select
    end if
    return
  end subroutine model_checkVariable
  !
  logical function model_getValue(v,ii,val,crc250,irc)
    type(mod_variable), pointer :: v       ! variable
    integer :: ii
    real :: val
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_getValue"
    if(mod_bdeb)write(*,*)myname,"Entering.",v%type,&
         & allocated(v%f1),&
         & allocated(v%f2),&
         & allocated(v%f4),&
         & allocated(v%fr),&
         & allocated(v%fd), &
         & v%var80(1:v%lenv)
    if (ii.lt.1.or.ii.gt.v%len) then
       model_getValue=.false.
    else
       model_getValue=.true.
       select case (v%type)
       case (nf_char)
          model_getValue=.false.
       case (nf_int1)
          if (.not.allocated(v%f1)) then
             irc=993
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Un-allocated field f1:"//v%var80(1:v%lenv))
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          else if (v%f1(ii).eq.v%m1) then
             model_getValue=.false.
          else
             val=(v%f1(ii)*v%scale)+v%offset
          end if
       case (nf_int2)
          if (.not.allocated(v%f2)) then
             irc=993
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Un-allocated field f2:"//v%var80(1:v%lenv))
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          else if (v%f2(ii).eq.v%m2) then
             model_getValue=.false.
          else
             val=(v%f2(ii)*v%scale)+v%offset
          end if
       case (nf_int)
          if (.not.allocated(v%f4)) then
             irc=993
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Un-allocated field f4:"//v%var80(1:v%lenv))
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          else if (v%f4(ii).eq.v%m4) then
             model_getValue=.false.
          else
             val=(v%f4(ii)*v%scale)+v%offset
          end if
       case (nf_real)
          if (.not.allocated(v%fr)) then
             irc=993
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Un-allocated field fr:"//v%var80(1:v%lenv))
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          else if (v%fr(ii).eq.v%mr) then
             model_getValue=.false.
          else
             val=(v%fr(ii)*v%scale)+v%offset
          end if
       case (nf_double)
          if (.not.allocated(v%fd)) then
             irc=993
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Un-allocated field fd:"//v%var80(1:v%lenv))
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          else if (v%fd(ii).eq.v%md) then
             model_getValue=.false.
          else
             val=(v%fd(ii)*v%scale)+v%offset
          end if
       case DEFAULT
          model_getValue=.false.
       end select
    end if
    return
  end function model_getValue
  !
  integer function model_getLoc(v,loc,ff)
    type(mod_variable),pointer :: v
    type(mod_location),pointer :: loc
    integer :: ff
    integer ii,ll
    character*25 :: myname="model_getLoc"
    model_getLoc=0
    !if(mod_bdeb)write(*,*)myname,"Entering.",allocated(loc%pos),&
    !     & allocated(v%ind),allocated(v%istart),allocated(v%icount),v%ndim
    !if(mod_bdeb)write(*,*)myname,"Sizes.",size(loc%pos),&
    !     & size(v%ind),size(v%istart),size(v%icount)
    !if(mod_bdeb)write(*,*)myname,"Index.",v%ind
    do ii=v%ndim,1,-1 ! do ii=1,n
       !if(mod_bdeb)write(*,*)myname,"Loop:",ii
       !if(mod_bdeb)write(*,*)myname,"Var:",ii,v%ind(ii),v%istart(ii),v%icount(ii)
       if (loc%pos(v%ind(ii),ff).lt.v%istart(ii).or.&
            & (loc%pos(v%ind(ii),ff)-v%istart(ii)).ge.v%icount(ii)) return
       model_getLoc=model_getLoc*v%icount(ii) + (loc%pos(v%ind(ii),ff)-v%istart(ii))
    end do
    model_getLoc=model_getLoc+1
    if(mod_bdeb)write(*,*)myname,"Done.",model_getLoc
    return
  end function model_getLoc
  !
  ! set position
  !
  subroutine model_resetPos(n,ind,loc,ff,crc250,irc)
    integer :: n          ! selected dimensions
    integer :: ind(n)
    type(mod_location), pointer :: loc
    integer :: ff ! offset
    character*250 :: crc250
    integer :: irc
    integer :: jj
    character*25 :: myname="model_resetPos"
    if (allocated(loc%pos)) then
       do jj=1,n
          loc%pos(ind(jj),ff)=loc%lstart(ind(jj),ff)
       end do
    else
       irc=945
       if (mod_bdeb) write(*,*)myname,'Invalid pos.'
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Invalid pos.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    return
  end subroutine model_resetPos
  !
  ! increment position
  !
  integer function model_incrementPos(n,ind,loc,ff)
    integer :: n          ! selected dimensions
    integer :: ind(n)     ! global dimension index
    type(mod_location), pointer :: loc
    integer :: ff         ! offset
    logical :: bdone
    integer :: jj
    model_incrementPos=0
    bdone=.false.
    jj=0
    do while (.not.bdone)
       jj=jj+1
       if (jj.le.n) then
          loc%pos(ind(jj),ff)=loc%pos(ind(jj),ff)+1
          if (loc%pos(ind(jj),ff).gt.loc%lstop(ind(jj),ff)) then
             loc%pos(ind(jj),ff)=loc%lstart(ind(jj),ff)
          else
             model_incrementPos=jj
             bdone=.true.
          end if
       else
          bdone=.true.
       end if
    end do
    return
  end function model_incrementPos
  !
  ! get accumulated weight
  !
  real function model_getWeight(n,ind,loc,ff)
    integer :: n          ! selected dimensions
    integer :: ind(n)
    type(mod_location), pointer :: loc
    integer :: ff ! offset
    logical :: bdone
    integer :: ii,di
    real :: ww
    character*25 :: myname="model_getWeight"

    bdone=.false.
    model_getWeight=1.0
    do ii=1,n
       di=loc%lstop(ind(ii),ff)-loc%lstart(ind(ii),ff)
       if (di.gt.0) then
          if (loc%pos(ind(ii),ff).eq.loc%lstart(ind(ii),ff)) then
             ww=(1.0D0-loc%intpf(ind(ii),ff))
          else if (di.ge.1) then
             ww=(loc%intpf(ind(ii),ff))/real(di)
          else
             ww=1.0D0
          end if
          if(mod_bdeb)write(*,*)myname,'Weight:',ii,ww,&
               & loc%intpf(ind(ii),ff),loc%pos(ind(ii),ff),loc%lstart(ind(ii),ff)
          model_getWeight=model_getWeight*ww
       end if
    end do
    return
  end function model_getWeight
  !
  !
  !###############################################################################
  ! PLAN/BATCH ROUTINES
  !###############################################################################
  ! make plan for target selection, find variables with overlapping dimensions
  !
  subroutine model_planBatch(css,f,p,crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_file),pointer :: f
    type(mod_plan),pointer  :: p
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_planBatch"
    integer :: ii,jj,kk,leng,lenv,lend
    integer, external :: length
    integer :: nslc2var
    type(mod_variable),pointer :: var
    type(mod_batch), pointer :: b
    logical, allocatable :: sliceProcessed(:)  ! is slice variable sliceProcesseded 
    logical, allocatable :: innerDim(:)  ! is inner dimension
    integer, allocatable :: slc2var(:)  ! index to global variable
    integer, allocatable :: slc2dim(:)  ! index to global dimension
    integer, allocatable :: var2sli(:)  ! index to slice variable
    integer, allocatable :: dim2sli(:)  ! index to slice dimension
    logical :: changed
    !
    ! make slice -- variable/dimension indexes
    !
    if(mod_bdeb)write(*,*)myname,' Entering.',css%csli,f%nvar
    call model_initPlan(p,css,f,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from initPlan.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    ! find batch jobs...
    ! ...batch job variables must be searched together
    if(mod_bdeb)write(*,*)myname,'Find batch jobs.',css%csli
    !
    allocate(sliceProcessed(css%csli),slc2var(css%csli),var2sli(css%csli),&
         & innerDim(f%ndim),slc2dim(f%ndim),dim2sli(f%ndim),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate slc2var....")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if    
    do ii=1,css%csli ! initialise
       sliceProcessed(ii)=.false.
       slc2var(ii)=0 ! index to global variable array
       var2sli(ii)=0 ! index to slice array
    end do
    do ii=1,css%csli
       if(mod_bdeb)write(*,*)myname,'Processing slice.',ii,css%csli,sliceProcessed(ii)
       if (.not.sliceProcessed(ii)) then ! slice not searched yet
          allocate(b,stat=irc)
          b%nvar=0                ! variables in batch job
          b%ndim=0                ! dimensions in batch job
          do jj=1,f%ndim    ! initialise
             innerDim(jj)=.false. ! marked dimension in global array
             dim2sli(jj)=0        ! position in slice array
          end do
          !
          if (p%slc2var(ii).ne.0) then ! this is a variable

             if(mod_bdeb)write(*,*)myname,'Found Var:',ii,&
                  & "'"//f%var80(p%slc2var(ii))(1:&
                  & f%lenv(p%slc2var(ii)))//"'"

             var => f%var(p%slc2var(ii))%ptr
             ! mark all variables
             do kk=1,var%ndim
                if (.not. innerDim(var%ind(kk))) then
                   innerDim(var%ind(kk))=.true.
                   p%innerDim(var%ind(kk))=.true.
                   if(mod_bdeb)write(*,*)myname,'Mark Dim: ',ii,&
                        & "'"//f%dim80(var%ind(kk))(1:&
                        & f%lend(var%ind(kk)))//"'"
                   b%ndim=b%ndim+1
                   slc2dim(b%ndim)=var%ind(kk)
                   dim2sli(kk)=0
                end if
             end do
             b%nvar=b%nvar+1 ! this is the first variable
             slc2var(b%nvar)= p%slc2var(ii) ! index to global variable
             var2sli(b%nvar)= ii ! index to slice variable
             sliceProcessed(ii)=.true.
          else if (p%slc2dim(ii).ne.0) then ! this is a dimension

             if(mod_bdeb)write(*,*)myname,'Found Dim:',ii,&
                  & "'"//f%dim80(p%slc2dim(ii))(1:&
                  & f%lend(p%slc2dim(ii)))//"'",&
                  & p%slc2dim(ii),b%ndim

             innerDim(p%slc2dim(ii))=.true.
             p%innerDim(p%slc2dim(ii))=.true.
             b%ndim=b%ndim+1
             slc2dim(b%ndim)=p%slc2dim(ii)
             dim2sli(p%slc2dim(ii))= ii  ! f%dim( p%slc2dim(ii) )
             sliceProcessed(ii)=.true.
          end if
          ! model_add(innerDim,p%slc2var(ii))
          changed=(b%ndim .gt. b%nvar)
          if(mod_bdeb)write(*,*)myname,'Cross-checking.',changed,b%ndim,b%nvar
          LOOP: do while (changed)
             changed=.false.
             do jj=ii+1,css%csli
                if (.not.sliceProcessed(jj)) then ! not processed yet
                   if (p%slc2var(jj).ne.0) then ! is a variable

                      if(mod_bdeb)write(*,*)myname,'>>Found Var:',ii,&
                           & "'"//f%var80(p%slc2var(jj))(1:&
                           & f%lenv(p%slc2var(jj)))//"'"

                      var => f%var(p%slc2var(jj))%ptr
                      if (model_overlaps(f%ndim,innerDim,var)) then
                         do kk=1,var%ndim
                            if (.not. innerDim(var%ind(kk))) then
                               innerDim(var%ind(kk))=.true.
                               p%innerDim(var%ind(kk))=.true.
                               if(mod_bdeb)write(*,*)myname,'>>Mark Dim: ',ii,&
                                    & f%dim80(var%ind(kk))(1:10)
                               b%ndim=b%ndim+1
                               slc2dim(b%ndim)=var%ind(kk)
                               dim2sli(kk)=0
                            end if
                         end do
                         b%nvar=b%nvar+1
                         slc2var(b%nvar)=p%slc2var(jj) ! index to global variable
                         var2sli(b%nvar)=jj    ! index to slice variable
                         sliceProcessed(jj)=.true.
                         changed=.true.
                      end if
                   else if (p%slc2dim(jj).ne.0) then ! is a dimension
                      if (.not. innerDim(p%slc2dim(jj))) then

                         if(mod_bdeb)write(*,*)myname,'Found Dim:',ii,&
                              & "'"//f%dim80(p%slc2dim(jj))(1:&
                              & f%lend(p%slc2dim(jj)))//"'",&
                              & p%slc2dim(jj),b%ndim

                         innerDim(p%slc2dim(jj))=.true.
                         p%innerDim(p%slc2dim(jj))=.true.
                         b%ndim=b%ndim+1
                         slc2dim(b%ndim)=p%slc2dim(jj)
                         dim2sli(b%ndim)= jj
                         sliceProcessed(jj)=.true.
                         changed=.true.
                      end if
                   end if
                end if
                if (b%ndim .le. b%nvar) exit LOOP ! we have enough variables
             end do
          end do LOOP
          ! add batch jobb...
          if(mod_bdeb)write(*,'(X,A,4(A,I0))')myname,&
               & 'Allocating ndim=',b%ndim,&
               & ', nvar=',b%nvar,', batch=',ii,', csli=',css%csli
          allocate(b%ind(b%ndim),b%inc(b%ndim),b%dim2sli(b%ndim),&
               & b%trgdim(b%ndim),b%dim80(b%ndim),&
               & b%var(b%nvar),b%val(b%nvar),b%proc(b%nvar),&
               & b%var2sli(b%nvar),b%trgvar(b%nvar),b%var80(b%nvar),&
               & stat=irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to allocate batch dimensions.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          !if(mod_bdeb)write(*,*)myname,'Store variables.',&
          !     & b%ndim,b%nvar,allocated(f%var80)
          do jj=1,b%nvar
             b%var(jj)=slc2var(jj)     ! position in global array
             b%proc(jj)=sliceProcessed(jj)
             b%var2sli(jj)=var2sli(jj) ! index to slice variable
             b%trgvar(jj)=0.0D0
             b%var80(jj)=f%var80(b%var(jj))
          end do
          !if(mod_bdeb)write(*,*)myname,'Store dimensions.',&
          !     & b%ndim,b%nvar,allocated(f%dim80)
          do jj=1,b%ndim
             b%ind(jj)=slc2dim(jj)
             if (b%ind(jj).eq.0) then ! insane dimension index
                if(mod_bdeb)write(*,'(X,A,A,I0)')myname,&
                     & 'Insane dimension index, batch index: ',jj
             end if
             !write(*,*)myname,'Debug:',jj,b%ind(jj),b%ndim
             if (f%istart(b%ind(jj)).eq.f%istop(b%ind(jj))) then
                b%inc(jj)=0                 ! no valid increment
             else
                b%inc(jj)=1                 ! increment
             end if
             b%dim2sli(jj)=dim2sli(jj)     ! position in slice target array, 0 if none
             b%trgdim(jj)=0.0D0
             !if(mod_bdeb)write(*,*)myname,'Store dimension loop.',jj,slc2dim(jj)

             if(mod_bdeb)write(*,'(X,A,A,I0,A,I0,A)')myname,&
                  & 'Slice dimension: ',&
                  & jj," -> ",b%ind(jj),"   '"//&
                  & f%dim80(b%ind(jj))(1:&
                  & f%lend(b%ind(jj)))//"'"

             b%dim80(jj)=f%dim80(b%ind(jj))
          end do
          !if(mod_bdeb)write(*,*)myname,'Store in plan chain.'
          ! store in plan....
          b%prev => p%last%prev
          p%last%prev%next => b
          b%next => p%last
          p%last%prev => b

          if (b%ndim.eq.0) then
             if (mod_bdeb) then
                write(*,*)myname,'Invalid batch.'
                call model_printBatch(b,crc250,irc)
             end if
             irc=845
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to determine search dimensions.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if

          b => null() ! release pointer
       else
          if(mod_bdeb)write(*,*)myname,'Already sliced...'
       end if
    end do
    if (allocated(sliceProcessed)) deallocate(sliceProcessed)
    if (allocated(slc2var)) deallocate(slc2var)
    if (allocated(slc2dim)) deallocate(slc2dim)
    if (allocated(innerDim)) deallocate(innerDim)
    if (allocated(var2sli)) deallocate(var2sli)
    if (allocated(dim2sli)) deallocate(dim2sli)
    if(mod_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine model_planBatch
  !
  !
  !
  subroutine model_deleteBatch(b,crc250,irc)
    type(mod_batch), pointer :: b
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_deleteBatch"
    if (.not.associated(b)) return
    if (allocated(b%ind)) deallocate(b%ind)
    if (allocated(b%inc)) deallocate(b%inc)
    if (allocated(b%dim2sli)) deallocate(b%dim2sli)
    if (allocated(b%trgdim)) deallocate(b%trgdim)
    if (allocated(b%var)) deallocate(b%var)
    if (allocated(b%val)) deallocate(b%val)
    if (allocated(b%proc)) deallocate(b%proc)
    if (allocated(b%var2sli)) deallocate(b%var2sli)
    if (allocated(b%trgvar)) deallocate(b%trgvar)
    b%ndim=0
    b%nvar=0
    b%prev%next => b%next
    b%next%prev => b%prev
    deallocate(b)
    return
  end subroutine model_deleteBatch
  !
  !
  !
  subroutine model_clearPlan(p,crc250,irc)
    type(mod_plan),pointer  :: p
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_clearPlan"
    type(mod_batch), pointer :: b,nb
    if(mod_bdeb)write(*,*)myname,' Entering.',associated(p)
    if (associated(p)) then
       if (allocated(p%innerDim)) deallocate(p%innerDim)
       if (allocated(p%trgvar)) deallocate(p%trgvar)
       if (allocated(p%slc2var)) deallocate(p%slc2var)
       if (allocated(p%slc2dim)) deallocate(p%slc2dim)
       if (allocated(p%proc)) deallocate(p%proc)
       !
       if(mod_bdeb)write(*,*)myname,'Deleting batch jobs.',associated(p%first)
       b => p%first%next
       do while ( .not.associated(b,target=p%last))
          nb=>b%next
          call model_deleteBatch(b,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from deleteBatch.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          b => nb
       end do
    end if
    if(mod_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine model_clearPlan
  !
  !
  subroutine model_printPlan(p,crc250,irc)
    type(mod_plan),pointer  :: p
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_printPlan"
    type(mod_batch), pointer :: b,nb
    if(mod_bdeb)write(*,*)myname,' Entering.',associated(p)
    if (associated(p)) then
       b => p%first%next
       do while ( .not.associated(b,target=p%last))
          nb=>b%next
          call model_printBatch(b,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from printBatch.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          b => nb
       end do
    end if
    if(mod_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine model_printPlan
  !
  subroutine model_printBatch(b,crc250,irc)
    type(mod_batch), pointer :: b
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_printBatch"
    integer :: ndim,ii
    character*250 :: buff250, nuff250
    integer :: lenb,lenn,lend,lenv
    integer, external :: length
    !
    if(mod_bdeb)write(*,*)myname,' Entering.',irc,b%ndim,b%nvar
    buff250="Dims=("
    call chop0(buff250,250)
    lenb=length(buff250,250,lenb)
    do ii=1,b%ndim
       call chop0(b%dim80(ii),80)
       lend=length(b%dim80(ii),80,10)
       nuff250=b%dim80(ii)(1:lend)
       call chop0(nuff250,250)
       lenn=length(nuff250,250,10)
       buff250=buff250(1:lenb)//nuff250(1:lenn)//":"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end do
    buff250=buff250(1:lenb)//") Vars=("
    call chop0(buff250,250)
    lenb=length(buff250,250,lenb)
    do ii=1,b%nvar
       call chop0(b%var80(ii),80)
       lenv=length(b%var80(ii),80,10)
       nuff250="("//b%var80(ii)(1:lenv)//")"
       call chop0(nuff250,250)
       lenn=length(nuff250,250,10)
       buff250=buff250(1:lenb)//nuff250(1:lenn)//":"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end do
    buff250=buff250(1:lenb)//")"
    call chop0(buff250,250)
    lenb=length(buff250,250,lenb)
    write(*,'(A)') buff250(1:lenb)
    if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_printBatch
  !
  !
  subroutine model_initPlan(p,css,f,crc250,irc)
    type(mod_plan),pointer  :: p
    type(mod_session), pointer :: css   ! current session
    type(mod_file),pointer :: f   ! current file
    character*250 :: crc250
    integer :: ii, jj
    integer :: leng, lenv, lend
    integer, external :: length
    logical :: lmd
    integer :: irc
    character*25 :: myname="model_initPlan"
    !
    if(mod_bdeb)write(*,*)myname,' Entering.',associated(p),&
               & allocated(p%slc2dim),associated(p%last),irc
    p%nvar=f%nvar
    p%ndim=f%ndim
    allocate(p%innerDim(p%ndim),p%trgvar(f%nvar),&
         & p%slc2var(css%csli),&
         & p%slc2dim(css%csli),p%proc(p%nvar),p%first,p%last,stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate batch contents.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    p%first%next => p%last
    p%last%prev => p%first
    !
    lmd=(css%csli.eq.0)  ! all dimensions are inner if no slice variables are defined...
    do ii=1,f%ndim
       p%innerDim(ii)=lmd
    end do
    !
 ! global dimension is used?
    do ii=1,f%nvar
       p%proc(ii)=.false.
       p%trgvar(ii)=0.0D0
    end do
    !
    if(mod_bdeb)write(*,*)myname,'Analysing slice variables.',lmd,css%csli
    do ii=1,css%csli
       p%slc2var(ii)=0 ! global variable index
       p%slc2dim(ii)=0 ! global dimension index
       leng=css%sli_lenv(ii)
       if (leng.gt.2) then
          if (css%sli_v80(ii)(1:1).eq."(".and.css%sli_v80(ii)(leng:leng).eq.")") then
             do jj=1,f%ndim
                lend=length(f%dim80(jj),80,10)
                if (css%sli_v80(ii)(2:leng-1).eq.f%dim80(jj)(1:lend)) then
                   
                   if(mod_bdeb)write(*,*) myname,'Dim: "'//css%sli_v80(ii)(2:leng-1)//&
                        & '"  "'//f%dim80(jj)(1:lend)//'"',ii,jj

                   p%slc2dim(ii)=jj ! global dimension index
                end if
             end do
          end if
       end if
       if (p%slc2dim(ii).eq.0) then ! not a dimension, must be a variable
          do jj=1,f%nvar ! global variable index
             lenv=length(f%var80(jj),80,10)
             if (css%sli_v80(ii)(1:leng).eq.f%var80(jj)(1:lenv)) then
                p%slc2var(ii)=jj
                if(mod_bdeb)write(*,'(X,A,A,I3,A,I3,A)') myname,&
                     & 'Slice variable: ',&
                     & ii,' -> ',jj,&
                     & "  '"//css%sli_v80(ii)(1:leng)//"'"
             end if
          end do
       end if
       if (p%slc2dim(ii).eq.0.and.p%slc2var(ii).eq.0) then ! not dimension nor variable...
          if(mod_bdeb)write(*,*) myname,'Unrecognised slice ignored:',&
               & css%sli_v80(ii)(1:leng)
       end if
    end do
    !
    if(mod_bdeb)write(*,*)myname,'done.',irc
    RETURN
  END subroutine model_initPlan
  !
  !
  !
  logical function model_overlaps(ndim,batch,var)
    integer :: ndim
    logical batch(ndim)
    type(mod_variable), pointer :: var
    integer ii
    model_overlaps=.false.
    do ii=1,var%ndim
       if (batch(var%ind(ii))) then
          model_overlaps=.true.
       end if
    end do
  end function model_overlaps
  !
  !
  !###############################################################################
  ! SLICE ROUTINES
  !###############################################################################
  ! slice current file
  !
  subroutine model_sliceTable(css,bok,crc250,irc)
    type(mod_session), pointer :: css !  current session
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*25 :: myname="model_sliceTable"
    logical :: bdone
    if(mod_bdeb)write(*,*)myname,' Entering.',&
         & associated(css%currentFile),css%locready
    bok=.false.
    if (.not.associated(css%currentFile)) return
    ! make location array
    call model_makeLocList(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from model_makeLocList.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    call model_allocateTable(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from allocateTable.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Locating.',css%locready
    call model_colocateTable(css,css%nloc,css%locData,css%currentFile,bok,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from colocateTable.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Done.',bok
    return
  end subroutine model_sliceTable
  !
  subroutine model_openCurrentFile(css,crc250,irc)
    type(mod_session), pointer :: css   !  current session
    character*250 :: crc250
    integer :: irc
    logical :: bok
    character*25 :: myname="model_openCurrentFile"
    type(mod_file),pointer :: f ! stack item to process
    type(mod_plan),pointer :: p => null()
    f => css%currentFile
    if (associated(f)) then
       call model_openFile(css,f,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from openFile.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       call model_readInventory(css,f,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from readInventory.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    return
  end subroutine model_openCurrentFile
  !
  subroutine model_closeCurrentFile(css,crc250,irc)
    type(mod_session), pointer :: css   !  current session
    character*250 :: crc250
    integer :: irc
    logical :: bok
    character*25 :: myname="model_closeCurrentFile"
    type(mod_file),pointer :: f ! stack item to process
    type(mod_plan),pointer :: p => null()
    f => css%currentFile
    if (associated(f)) then
       call model_closeFile(css,f,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from openFile.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    return
  end subroutine model_closeCurrentFile
  !
  subroutine model_colocateTable(css,nloc,loc,f,bok,crc250,irc)
    type(mod_session), pointer :: css   !  current session
    integer :: nloc                 ! number of locations
    type(mod_locPointer) :: loc(nloc)   !  location pointer
    type(mod_file),pointer :: f ! stack item to process
    character*250 :: crc250
    integer :: irc
    logical :: bok
    character*25 :: myname="model_colocateTable"
    type(mod_plan),pointer :: p => null()
    !
    if(mod_bdeb)write(*,*)myname,' Entering.',irc
    bok=.true.
    !
    ! Connect file-variables => target-variables
    !
    if (bok) then
       call model_setTargetIndex(css,f,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from fileTargetIndex.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    !
    ! analyse slice
    !
    if (bok) then
       call model_clearPlan(p,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from clearPlan.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       allocate(p,stat=irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to allocate plan.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       call model_planBatch(css,f,p,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from planBatch.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    !
    ! dump results
    !
    if (bok) then
       !nloc=min(1,nloc) ! debug
       call model_makeTable(css,nloc,loc,f,p,bok,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from makeTable.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    if (bok) then
       call model_clearPlan(p,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from clearPlan.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    if(mod_bdeb)write(*,*)myname,' Done.',bok
    return
  end subroutine model_colocateTable

  !XXXXXXXXXXXXXXXXXX slicetable generates oval(:,:), oset(:,:)- gives value of targets at all locations...
  ! Store oval(:,:) and oset(:,:) in model_session, to be retrieved later...
  ! call model_getSlice(css,nloc,ntrg,oval,oset)
  !
  !###############################################################################
  ! GRID SECTION ROUTINES (WHEN VARIABLE GRID IS TOO LARGE FOR MEMORY)
  !###############################################################################
  !
  logical function  model_locOffGrid(v,loc,ff) ! is location outside grid section?
    type(mod_variable), pointer :: v
    type(mod_location), pointer :: loc
    integer :: ff  ! offset
    character*25 :: myname="model_locOffGrid"
    integer :: ii
    model_locOffGrid=.false.
    do ii=1,v%ndim
       if (loc%lstart(v%ind(ii),ff).lt.v%istart(ii).or.&
            & (loc%lstop(v%ind(ii),ff)-v%istart(ii)).ge.v%icount(ii)) then
          if (mod_bdeb) write(*,*)myname,'Grid.',&
               & loc%lstart(v%ind(ii),ff),loc%lstop(v%ind(ii),ff),&
               & v%istart(ii),v%istart(ii)+v%icount(ii)-1
          model_locOffGrid=.true.
       end if
    end do
    return
  end function model_locOffGrid
  !
  ! set variable grid to the search-cell...
  !
  logical function model_setLocGrid(v,loc,ff,p)
    type(mod_variable), pointer :: v
    type(mod_location), pointer :: loc
    integer :: ff
    type(mod_plan), pointer :: p
    character*25 :: myname="model_setLocGrid"
    integer :: jj
    if (loc%bok.and.loc%search(ff).eq.0) then
       do jj=1,v%ndim
          if (p%innerDim(v%ind(jj))) then
             v%istart(jj)=loc%lstart(v%ind(jj),ff)
             v%icount(jj)=loc%lstop(v%ind(jj),ff)-loc%lstart(v%ind(jj),ff)+1
          end if
       end do
       if (mod_bdeb)then
          do jj=1,v%ndim
             write(*,*)myname,'Dim:',jj,v%istart(jj),v%istart(jj)+v%icount(jj)-1,&
                  & p%innerDim(v%ind(jj)),&
                  & nint(loc%rpos(v%ind(jj),ff)),loc%lstart(v%ind(jj),ff),&
                  & loc%lstop(v%ind(jj),ff),&
                  & loc%intpf(v%ind(jj),ff)
          end do
          write(*,*)myname,"Valid location at '"//v%var80(1:v%lenv)//"' dimlen=",model_varLen(v)," ndims=",v%ndim
       end if
       model_setLocGrid=.true.
    else
       model_setLocGrid=.false.
       if (mod_bdeb)write(*,*)myname,"Invalid location at '"//v%var80(1:v%lenv)//"'"
    end if
    return
  end function model_setLocGrid
  !
  ! set variable grid to the search-cell...
  !
  subroutine model_resetGrid(f,v)
    type(mod_file), pointer :: f
    type(mod_variable), pointer :: v
    type(mod_plan), pointer :: p
    character*25 :: myname="model_resetGrid"
    integer :: jj
    do jj=1,v%ndim
       v%istart(jj)=f%istart(v%ind(jj))
       v%icount(jj)=f%istop(v%ind(jj))-f%istart(v%ind(jj))+1
    end do
    if (mod_bdeb)then
       do jj=1,v%ndim
          write(*,*)myname,'Dim:',jj,v%istart(jj),v%istart(jj)+v%icount(jj)-1
       end do
    end if
    return
  end subroutine model_resetGrid
  !
  integer*8 function model_varLen(v)
    type(mod_variable), pointer :: v
    integer :: jj
    character*25 :: myname="model_varLen"
    if (associated(v)) then
       model_varLen=1
       do jj=1,v%ndim
          model_varLen=model_varLen*(v%icount(jj))
       end do
    else
       if (mod_bdeb)write(*,*)myname,"Invalid v-pointer."
       model_varLen=0
    end if
    return
  end function model_varLen
  !
  integer*8 function model_fileLen(f,v)
    type(mod_file), pointer :: f
    type(mod_variable), pointer :: v
    integer :: jj
    model_fileLen=1
    do jj=1,v%ndim
       model_fileLen=model_fileLen*(f%istop(v%ind(jj))-f%istart(v%ind(jj))+1)
    end do
    return
  end function model_fileLen
  !
  !###############################################################################
  ! TABLE ROUTINES
  !###############################################################################
  !
  subroutine model_makeTable(css,nloc,lp,f,p,bok,crc250,irc)
    type(mod_session), pointer :: css ! current session
    integer :: nloc                   ! number of locations
    type(mod_locPointer) :: lp(nloc) ! location pointer
    type(mod_file),pointer :: f
    type(mod_plan),pointer :: p
    logical :: bok ! was any data printed
    character*250 :: crc250
    integer :: irc
    type(mod_batch), pointer :: b
    character*25 :: myname="model_makeTable"
    integer :: ii,ll,varid
    character*250 :: var250
    character*50 :: sval50
    character*80 :: trg80
    integer :: lenv, lend, lent, lens
    integer, external :: length
    type(mod_variable),pointer :: v
    type(mod_location), pointer :: loc
    !integer*8, parameter :: maxlen=2147483647
    integer*8, parameter :: maxlen=100000000 ! hundred million
    integer*8 :: dimlen
    integer :: ff, itrg
    logical :: first,bdeb
    if(mod_bdeb)write(*,*)myname,' Entering.',nloc
    write(*,*)myname,"Processing: '",f%fn250(1:f%lenf)//"'"
    !
    ! initialise location positions
    !
    if (nloc.eq.0) then
       bok=.false.
       return
    end if
    do ll=1,nloc
       !
       ! initialise location position
       !
       call model_initLocPos(css,f,p,b,lp(ll)%ptr,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from initLocPos.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end do
    !
    ! mark all variables as not-processed
    !
    do varid = 1, p%nvar
       p%proc(varid)=.false.
    end do
    !
    ! loop over batch-jobs
    !
    if(mod_bdeb)write(*,*)myname,'Batch job loop.'
    b=>p%first%next
    do while ( .not.associated(b,target=p%last))
       !
       ! read batch-variables into memory
       !
       do ii = 1, b%nvar
          varid=b%var(ii)
          call model_readVariable(css,f,varid,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from readVariable.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       end do
       !
       ! loop over locations and determine slice indexes
       !
       if(mod_bdeb)write(*,*)myname,'Location loop.',nloc,b%nvar
       bdeb=mod_bdeb
       mod_bdeb=.false.
       do ll=1,nloc
          loc => lp(ll)%ptr
          if (loc%bok.and.loc%search(0) .eq. 0) then
             !
             ! search for batch-dimension values
             !
             call model_search(css,f,p,b,loc,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from search.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
          end if
       end do
       mod_bdeb=bdeb
       b=>b%next
    end do
    !
    ! clear batch-variables from memory
    !
    b=>p%first%next
    do while ( .not.associated(b,target=p%last))
       if(mod_bdeb)write(*,*)myname,'Variable loop.',b%nvar
       do ii = 1, b%nvar 
          varid=b%var(ii)
          p%proc(varid)=.true.
          var250=model_getVar250(f,varid)
          lenv=length(var250,250,10)
          if(mod_bdeb)write(*,*)myname,"Processed "//var250(1:lenv),&
               & varid,p%proc(varid)
          do itrg=1,css%ctrg ! loop over targets
             if (css%trg_var(itrg).ne.varid) cycle ! target is not this variable
             ff=css%trg_offset(itrg)
             !
             do ll=1,nloc
                if (lp(ll)%ptr%bok) then
                   call model_getTarget50(lp(ll)%ptr%sli_val(b%var2sli(ii)),lens,sval50)
                   call model_setLocVal(css,f,varid,lp(ll)%ptr,itrg,ff,p,bok,crc250,irc)
                   if (irc.ne.0) then
                      call model_errorappend(crc250,myname)
                      call model_errorappend(crc250," Error return from setLoc.")
                      call model_errorappendi(crc250,irc)
                      call model_errorappend(crc250,"\n")
                      return
                   end if
                end if
             end do
          end do
          varid=b%var(ii)
          call model_clearVariable(f%var(b%var(ii))%ptr,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from clearVariable.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          if(mod_bdeb)write(*,*)myname,'Processed done:',p%proc(1)
       end do
       !
       ! end loop over batch jobs
       !
       b=>b%next
    end do
    !
    if(mod_bdeb)write(*,*)myname,'Looping over remaining variables.',f%nvar, p%nvar
    !
    ! loop over remaining variables
    !
    VAR: do varid = 1, f%nvar
       v => f%var(varid)%ptr
       if (p%proc(varid)) then
          if(mod_bdeb)write(*,*)myname,'Already processed:',v%var80(1:v%lenv)
          cycle VAR ! already processed
       end if
       if(mod_bdeb)write(*,*)myname," ** Processing: '"//v%var80(1:v%lenv)//"'",v%ndim
       !
       var250=model_getvar250(f,varid)
       lenv=length(var250,250,10)
       dimlen=model_varLen(v)
       if(mod_bdeb)write(*,'(X,A,X,A,X,A,"(",I0,")")')myname,' Target variable:',&
            & v%var80(1:v%lenv),dimlen
       !
       if (dimlen.gt.maxlen) then ! read variable in segments
          do itrg=1,css%ctrg ! loop over targets
             if (css%trg_var(itrg).ne.varid) cycle ! target is not this variable
             ff=css%trg_offset(itrg)
             trg80=css%trg80(itrg)
             lent=css%trg_lent(itrg)
             !
             if(mod_bdeb)write(*,*)myname,"A Resetting grid for '"//v%var80(1:v%lenv)//"' (segments)",dimlen
             call model_resetGrid(f,v) ! reset grid in case earlier call to setLocGrid
             do ll=1,nloc
                loc=>lp(ll)%ptr
                if (model_setLocGrid(v,loc,ff,p)) then
                   !
                   ! read variable into memory
                   !
                   call model_readVariable(css,f,varid,crc250,irc)
                   if (irc.ne.0) then
                      call model_errorappend(crc250,myname)
                      call model_errorappend(crc250," Error return from readVariable.")
                      call model_errorappendi(crc250,irc)
                      call model_errorappend(crc250,"\n")
                      return
                   end if
                   !
                   ! make output for variables at location
                   !
                   lens=0
                   call model_setLocVal(css,f,varid,lp(ll)%ptr,itrg,ff,p,bok,crc250,irc)
                   if (irc.ne.0) then
                      call model_errorappend(crc250,myname)
                      call model_errorappend(crc250," Error return from setLoc.")
                      call model_errorappendi(crc250,irc)
                      call model_errorappend(crc250,"\n")
                      return
                   end if
                end if
                !
                ! clear variable from memory
                !
                call model_clearVariable(v,crc250,irc)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Error return from clearVariable.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
             end do ! locations
             !
          end do
       else ! read variables once...
          !
          if(mod_bdeb)write(*,*)myname,"B Resetting grid '"//v%var80(1:v%lenv)//"' (a)",dimlen
          call model_resetGrid(f,v) ! reset grid in case earlier call to setLocGrid
          !
          first=.true. ! variable not yet read into memory
          do itrg=1,css%ctrg ! loop over targets
             if (css%trg_var(itrg).ne.varid) cycle ! target is variable
             ff=css%trg_offset(itrg)
             trg80=css%trg80(itrg)
             lent=css%trg_lent(itrg)
             if (first) then ! read variable into memory
                call model_readVariable(css,f,varid,crc250,irc)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Error return from readVariable.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
                first=.false.
             end if
             !if(mod_bdeb)write(*,*)myname,"Here: ",itrg,css%ctrg
             ff=css%trg_offset(itrg)
             trg80=css%trg80(itrg)
             lent=css%trg_lent(itrg)
             !if(mod_bdeb)write(*,*)myname,"There: ",itrg,css%ctrg
             !
             ! loop over locations
             if(mod_bdeb)write(*,*)myname,"Starting inner loop: ",nloc
             do ll=1,nloc
                loc => lp(ll)%ptr
                if(mod_bdeb)write(*,*)myname,"Inner loop: ",ll,nloc,loc%bok
                if (loc%bok) then
                   !
                   ! make output for variables at location
                   !
                   lens=0
                   call model_setLocVal(css,f,varid,loc,itrg,ff,p,bok,crc250,irc)
                   if (irc.ne.0) then
                      call model_errorappend(crc250,myname)
                      call model_errorappend(crc250," Error return from setLoc.")
                      call model_errorappendi(crc250,irc)
                      call model_errorappend(crc250,"\n")
                      return
                   end if
                end if
                !
                ! end loop over locations
                !
             end do
          end do
          !
          ! clear variable from memory
          !
          if (.not.first) then
             call model_clearVariable(v,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from clearVariable.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
          end if
       end if
       !
       ! end loop over remaining variables
       !
    end do VAR
    ! !
    ! ! clear location positions
    ! !
    ! do ll=1,nloc
    !    !
    !    ! clear location position
    !    !
    !    call model_initLocPos(css,f,p,b,lp(ll)%ptr,crc250,irc)
    !    if (irc.ne.0) then
    !       call model_errorappend(crc250,myname)
    !       call model_errorappend(crc250," Error return from initLocPos.")
    !       call model_errorappendi(crc250,irc)
    !       call model_errorappend(crc250,"\n")
    !       return
    !    end if
    ! end do
    if(mod_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine model_makeTable
  !
  ! set target values for current variable
  !
  subroutine model_setLocVal(css,f,varid,loc,itrg,ff,p,bok,crc250,irc)
    type(mod_session), pointer :: css   ! current session
    type(mod_file),pointer :: f   ! current file
    integer :: varid                    ! current variable
    type(mod_location),pointer :: loc   ! location
    integer :: itrg ! target
    integer :: ff   ! offset
    type(mod_plan),pointer :: p         ! pointer to the current plan
    logical :: bok                      ! was any data printed?
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setLocVal"
    real :: val
    logical :: bout, binn
    integer ::lenb,lenp,len1
    character*50 :: s1
    integer, external :: length
    character*250 :: buff250, loc250,pos250
    type(mod_variable),pointer :: v   ! variable pointer
    integer :: ninn, nout, pinn,cinn,cout
    real :: sum,tsum,wgt,twgt,tval
    integer, allocatable :: inn(:), out(:), ind(:)
    integer ::cnt,cval,ctot,jj
    logical :: first,set
    !
    ! check if location is ok
    if(mod_bdeb)write(*,*)myname,"Entering ",itrg,ff
    
    v => f%var(varid)%ptr
    if (.not.loc%bok) then
       if (mod_bdeb) write(*,*)myname,'Ignoring loc:',loc%bok
       return
    end if
    !
    ! get outer and inner loop indexes
    !
    if(allocated(out)) deallocate(out)
    if(allocated(inn)) deallocate(inn)
    if(allocated(ind)) deallocate(ind)
    allocate(out(p%ndim),inn(p%ndim),ind(p%ndim))
    !
    ! Split dimensions into inner and outer based on plan...
    !
    if(mod_bdeb)write(*,*)myname,"Planning loop. ",itrg,ff
    call model_planLoop(v,p,nout,out,ninn,inn,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from planLoop.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    ! make target dimension index...
    !
    if(mod_bdeb)write(*,*)myname,"Planning target index. ",itrg,ff
    call model_planTrgInd(css,ninn,inn,ind,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from planTrgInd.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    if (mod_bdeb) then
       write(*,'(X,A,3(A,I0))')myname,&
            & " Loc:",loc%iloc,", ninn=",ninn,", nout=",nout
       do jj=1,ninn
          write(*,*)myname,'Inner:',jj,inn(jj), &
               & css%currentFile%dim80(inn(jj))(1:css%currentFile%lend(inn(jj)))
       end do
       do jj=1,nout
          write(*,*)myname,'Outer:',jj,out(jj), &
               & css%currentFile%dim80(out(jj))(1:css%currentFile%lend(out(jj)))
       end do
    end if
    !
    ! loop over offset
    !
    if (loc%search(ff) .ne. 0) then
       if (mod_bdeb) write(*,*)myname,'Skipping offset:',ff,loc%search(ff)
       return
    end if
    !
    ! Check if location is off grid section
    if (model_locOffGrid(v,loc,ff)) then
       if (mod_bdeb) write(*,*)myname,'Loc off grid.',ff,loc%locid
       return
    end if
    !
    ! write value information
    !
    if(mod_bdeb)write(*,*)myname,"Calculating ",itrg,ff,associated(loc),associated(v)
    twgt=0.0D0
    tsum=0.0D0
    cnt=0
    call model_resetPos(nout,out,loc,ff,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from resetPos.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    bout=.false.
    do while (.not. bout) ! OUTER DIMENSION LOOP
       pinn=0   ! previous  dimension index
       call model_resetPos(ninn,inn,loc,ff,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from resetPos.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       ctot=0 ! total number of grid points
       cval=0 ! number of valid grid points
       binn=.false.
       do while (.not. binn) ! INNER SEARCH LOOP
          if(mod_bdeb)write(*,*)myname,"Calling getLocValue."
          set = model_getLocValue(v,loc,ff,val,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from getLocValue.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          if(mod_bdeb)write(*,*)myname," Loc:",loc%iloc, "Value:",val
          cnt=cnt+1
          ctot=ctot+1
          if(mod_bdeb)write(*,*)myname," Loc:",loc%iloc,"Calling Incrementing position."
          if (set) then ! val.ne.nf_fill_double
             wgt=model_getWeight(ninn,inn,loc,ff) ! current weight
             tsum=tsum+wgt*val
             twgt=twgt+wgt
             cval=cval+1
          end if
          !if(mod_bdeb)write(*,*) myname,'Weight:',wgt,twgt,val
          cinn=model_incrementPos(ninn,inn,loc,ff) ! current inn
          binn=((cnt.gt.250).or.(cinn.eq.0))
          if(mod_bdeb)write(*,'(X,A,3(A,I0),A,L1,2(A,F15.3))')myname," Loc:",loc%iloc,&
               & ' Count inner A newLoc=',cinn,' cnt=',cnt,' done=',binn,' wgt=',wgt,' vsum=',tsum
       end do
       if (twgt.gt.1.0D-10.and.ctot.eq.cval.and.ctot.ge.1) then
          tval=tsum/twgt
          call model_setLocTrgVal(css,loc,itrg,tval,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from setLocTrgVal.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          call model_locRposToTrg(css,loc,ff,ninn,inn,ind,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from setLocTrgInd.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          call model_setOutVal(css,tval,itrg,loc%iloc,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from setOutVal.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       end if
       cout=model_incrementPos(nout,out,loc,ff)
       bout=(cnt.gt.32.or.(cout.eq.0))
       if(mod_bdeb)write(*,*)myname," Loc:",loc%iloc,'Count outer:',cout,cnt,bout
    end do
    if(allocated(out)) deallocate(out)
    if(allocated(inn)) deallocate(inn)
    if(allocated(ind)) deallocate(ind)
    if(mod_bdeb)write(*,*)myname,"Done ",itrg
    return
  end subroutine model_setLocVal
  !
  !###############################################################################
  ! OUTPUT-XML ROUTINES
  !###############################################################################
  subroutine model_sliceXML(css,ounit,bok,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: ounit
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*25 :: myname="sliceXML"
    logical :: bdone
    if(mod_bdeb)write(*,*)myname,' Entering.',&
         & associated(css%currentFile),' locready=',css%locready
    bok=.false.
    if (.not.associated(css%currentFile)) then
       if(mod_bdeb)write(*,*)myname,' No file specified, returning.'
       return
    end if
    ! make location array
    call model_makeLocList(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from model_makeLocList.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    call model_allocateTable(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from allocateTable.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if 
    if(mod_bdeb)write(*,*)myname,' locready=',css%locready
    call model_colocateXML(css,ounit,css%nloc,css%locData,css%currentFile,bok,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from colocateXML.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Done.',bok,' locready=',css%locready
    return
  end subroutine model_sliceXML
  !
  subroutine model_colocateXML(css,ounit,nloc,lp,f,bok,crc250,irc)
    type(mod_session), pointer :: css   !  current session
    integer :: ounit
    integer :: nloc                 ! number of locations
    type(mod_locPointer) :: lp(nloc)   !  location pointer
    type(mod_file),pointer :: f ! stack item to process
    character*250 :: crc250
    integer :: irc
    logical :: bok
    character*25 :: myname="model_colocateXML"
    type(mod_plan),pointer :: p => null()
    !
    if(mod_bdeb)write(*,*)myname,' Entering.',irc,' locready=',css%locready
    bok=.true.
    !
    ! Connect file-variables => target-variables
    !
    if(mod_bdeb)write(*,*)myname,' D locready=',css%locready
    if (bok) then
       call model_setTargetIndex(css,f,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from fileTargetIndex.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    !
    ! analyse slice
    !
    if(mod_bdeb)write(*,*)myname,' E locready=',css%locready
    if (bok) then
       call model_clearPlan(p,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from clearPlan.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       allocate(p,stat=irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to allocate plan.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       call model_planBatch(css,f,p,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from planBatch.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    !
    ! dump results
    !
    if(mod_bdeb)write(*,*)myname,' Making XML. locready=',css%locready
    if (bok) then
       !nloc=min(1,nloc) ! debug
       call model_makeXML(css,ounit,nloc,lp,f,p,bok,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from makeTable.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    if(mod_bdeb)write(*,*)myname,' F locready=',css%locready
    if (bok) then
       call model_clearPlan(p,crc250,irc)
       if (irc.ne.0) then
          bok=.false.
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from clearPlan.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    if(mod_bdeb)write(*,*)myname,' Done. locready=',css%locready
    return
  end subroutine model_colocateXML
  !
  ! colocate fields together with locations and write xml to standard output
  !
  subroutine model_makeXML(css,ounit,nloc,lp,f,p,bok,crc250,irc)
    type(mod_session), pointer :: css ! current session
    integer :: ounit                  ! output unit
    integer :: nloc                   ! number of locations
    type(mod_locPointer) :: lp(nloc) ! location pointer
    type(mod_file),pointer :: f
    type(mod_plan),pointer :: p
    logical :: bok ! was any data printed
    character*250 :: crc250
    integer :: irc
    type(mod_batch), pointer :: b
    character*25 :: myname="model_makeXML"
    integer :: ii,ll,varid
    character*250 :: var250
    character*50 :: sval50
    character*80 :: trg80
    integer :: lenv, lend, lens, lent, itrg
    type(mod_location), pointer :: loc
    type(mod_variable), pointer :: v
    !integer*8, parameter :: maxlen=2147483647
    integer*8, parameter :: maxlen=1000
    integer*8 :: dimlen
    integer :: ff
    integer, external :: length
    logical :: first
    if(mod_bdeb)write(*,*)myname,' Entering. locready=',css%locready,nloc
    !
    ! initialise location positions
    !
    do ll=1,nloc
       !
       ! initialise location position
       !
       call model_initLocPos(css,f,p,b,lp(ll)%ptr,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from initLocPos.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end do
    !
    if(mod_bdeb)write(*,*)myname,'G locready=',css%locready
    ! start xml output
    !
    if (nloc.eq.0) then
       write(ounit,'(3X,A,I0,A)',iostat=irc)"<model loc='",nloc,"'/>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 07.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    else
       write(ounit,'(3X,A,I0,A)',iostat=irc)"<model loc='",nloc,"'>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 08.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       !
       ! mark all variables as not-processed
       !
       do varid = 1, p%nvar
          p%proc(varid)=.false.
       end do
       !
       ! loop over batch-jobs
       !
       if(mod_bdeb)write(*,*)myname,'Batch job loop.'
       b=>p%first%next
       do while ( .not.associated(b,target=p%last))
          !
          ! read batch-variables into memory
          !
          if(mod_bdeb)write(*,*)myname,'H locready=',css%locready
          do ii = 1, b%nvar
             varid=b%var(ii)
             call model_readVariable(css,f,varid,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from readVariable.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
          end do
          !
          ! loop over locations and determine slice indexes
          !
          if(mod_bdeb)write(*,*)myname,'I locready=',css%locready,nloc,b%nvar
          do ll=1,nloc
             loc => lp(ll)%ptr
             if (loc%bok.and.loc%search(0) .eq. 0) then
                !
                ! search for batch-dimension values
                !
                call model_search(css,f,p,b,loc,crc250,irc)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Error return from search.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
                if (mod_bdeb) then
                   call model_writeIgnoredLocXML(css,ounit,f,loc,p,crc250,irc)
                   if (irc.ne.0) then
                      call model_errorappend(crc250,myname)
                      call model_errorappend(crc250," Error return from writeSummaryXML.")
                      call model_errorappendi(crc250,irc)
                      call model_errorappend(crc250,"\n")
                      return
                   end if
                end if
             end if
          end do
          b=>b%next
       end do
       !
       ! clear batch-variables from memory
       !
       b=>p%first%next
       do while ( .not.associated(b,target=p%last))
          if(mod_bdeb)write(*,*)myname,'K locready=',css%locready,b%nvar
          do ii = 1, b%nvar 
             varid=b%var(ii)
             p%proc(varid)=.true.
             if(mod_bdeb)write(*,*)myname,'Processed:',varid,p%proc(varid)
             var250=model_getVar250(f,varid)
             lenv=length(var250,250,10)
             if(mod_bdeb)write(*,*)myname,'Variable:'//var250(1:lenv)
             !
             do itrg=1,css%ctrg ! loop over targets
                if (css%trg_var(itrg).ne.varid) cycle ! target is variable
                ff=css%trg_offset(itrg)
                trg80=css%trg80(itrg)
                lent=css%trg_lent(itrg)
                !
                do ll=1,nloc
                   !
                   if (lp(ll)%ptr%bok) then
                      call model_getTarget50(lp(ll)%ptr%sli_val(b%var2sli(ii)),lens,sval50)
                      call model_setLocValXML(css,ounit,f,varid,lenv,var250,&
                           & lent,trg80,lens,sval50,lp(ll)%ptr,itrg,ff,p,bok,crc250,irc)
                      if (irc.ne.0) then
                         call model_errorappend(crc250,myname)
                         call model_errorappend(crc250," Error return from setLocValXML.")
                         call model_errorappendi(crc250,irc)
                         call model_errorappend(crc250,"\n")
                         return
                      end if
                      !
                      call model_setLocRpos(f,varid,lp(ll)%ptr,ff)
                      !
                   end if
                end do
             end do
             varid=b%var(ii)
             call model_clearVariable(f%var(b%var(ii))%ptr,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from clearVariable.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             if(mod_bdeb)write(*,*)myname,'Processed done:',p%proc(1)
          end do
          !
          ! end loop over batch jobs
          !
          b=>b%next
       end do
       !
       if(mod_bdeb)write(*,*)myname,'K locready=',css%locready,f%nvar, p%nvar
       !
       ! loop over remaining variables
       !
       VAR: do varid = 1, f%nvar
          v => f%var(varid)%ptr
          if (p%proc(varid)) then
             if(mod_bdeb)write(*,*)myname,'Already processed:',v%var80(1:v%lenv)
             cycle VAR ! already processed
          end if
          var250=model_getvar250(f,varid)
          lenv=length(var250,250,10)
          dimlen=model_varLen(v)
          if(mod_bdeb)write(*,'(X,A,X,A,X,A,"(",I0,")")')myname,' Target variable:',v%var80(1:v%lenv),dimlen
          if (dimlen.gt.maxlen) then ! read variable in segments
             do itrg=1,css%ctrg ! loop over targets
                if (css%trg_var(itrg).ne.varid) cycle ! not our target
                ff=css%trg_offset(itrg)
                trg80=css%trg80(itrg)
                lent=css%trg_lent(itrg)
                if(mod_bdeb)write(*,*)myname,"C Resetting grid for '"//v%var80(1:v%lenv)//"'"
                call model_resetGrid(f,v) ! reset grid in case earlier call to setLocGrid
                do ll=1,nloc
                   loc=>lp(ll)%ptr
                   if (model_setLocGrid(v,loc,ff,p)) then
                      !
                      ! read variable into memory
                      !
                      call model_readVariable(css,f,varid,crc250,irc)
                      if (irc.ne.0) then
                         call model_errorappend(crc250,myname)
                         call model_errorappend(crc250," Error return from readVariable.")
                         call model_errorappendi(crc250,irc)
                         call model_errorappend(crc250,"\n")
                         return
                      end if
                      !
                      ! make XML for variables at location
                      !
                      lens=0
                      call model_setLocValXML(css,ounit,f,varid,lenv,var250,&
                           & lent,trg80,lens,sval50,lp(ll)%ptr,itrg,ff,p,bok,crc250,irc)
                      if (irc.ne.0) then
                         call model_errorappend(crc250,myname)
                         call model_errorappend(crc250," Error return from setLocValXML.")
                         call model_errorappendi(crc250,irc)
                         call model_errorappend(crc250,"\n")
                         return
                      end if
                   end if
                   !
                   ! clear variable from memory
                   !
                   call model_clearVariable(v,crc250,irc)
                   if (irc.ne.0) then
                      call model_errorappend(crc250,myname)
                      call model_errorappend(crc250," Error return from clearVariable.")
                      call model_errorappendi(crc250,irc)
                      call model_errorappend(crc250,"\n")
                      return
                   end if
                   !
                   ! end loop over locations
                   !
                end do
             end do
          else ! read variables once
             !
             if(mod_bdeb)write(*,*)myname,"D Resetting grid '"//v%var80(1:v%lenv)//"' (a)"
             call model_resetGrid(f,v) ! reset grid in case earlier call to setLocGrid
             !
             first=.true.
             do itrg=1,css%ctrg ! loop over targets
                if (css%trg_var(itrg).ne.varid) cycle ! not our target
                ff=css%trg_offset(itrg)
                trg80=css%trg80(itrg)
                lent=css%trg_lent(itrg)
                if (first) then ! read variable into memory
                   call model_readVariable(css,f,varid,crc250,irc)
                   if (irc.ne.0) then
                      call model_errorappend(crc250,myname)
                      call model_errorappend(crc250," Error return from readVariable.")
                      call model_errorappendi(crc250,irc)
                      call model_errorappend(crc250,"\n")
                      return
                   end if
                   first=.false.
                end if
                do ll=1,nloc
                   loc => lp(ll)%ptr
                   if (loc%bok) then
                      !
                      ! make XML for variables at location
                      !
                      lens=0
                      call model_setLocValXML(css,ounit,f,varid,lenv,var250,&
                           & lent,trg80,lens,sval50,loc,itrg,ff,p,bok,crc250,irc)
                      if (irc.ne.0) then
                         call model_errorappend(crc250,myname)
                         call model_errorappend(crc250," Error return from setLocValXML.")
                         call model_errorappendi(crc250,irc)
                         call model_errorappend(crc250,"\n")
                         return
                      end if
                   end if
                   !
                   ! end loop over locations
                   !
                end do
             end do
             !
             ! clear variable from memory
             !
             if (.not.first) then   
                call model_clearVariable(v,crc250,irc)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Error return from clearVariable.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
             end if
          end if
          !
          ! end loop over remaining variables
          !
       end do VAR
       !
       ! stop xml output
       !
       write(ounit,'(3X,"</model>")',iostat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 09.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    ! !
    ! ! clear location positions
    ! !
    ! if(mod_bdeb)write(*,*)myname,'L locready=',css%locready
    ! do ll=1,nloc
    !    ! clear location position
    !    call model_initLocPos(css,f,p,b,lp(ll)%ptr,crc250,irc)
    !    if (irc.ne.0) then
    !       call model_errorappend(crc250,myname)
    !       call model_errorappend(crc250," Error return from clearLocPos.")
    !       call model_errorappendi(crc250,irc)
    !       call model_errorappend(crc250,"\n")
    !       return
    !    end if
    ! end do
    if(mod_bdeb)write(*,*)myname,' Done locready=',css%locready
    return
  end subroutine model_makeXML
  !
  ! write location summary
  !
  subroutine model_writeIgnoredLocXML(css,ounit,f,loc,p,crc250,irc)
    type(mod_session), pointer :: css   ! current session
    integer :: ounit                  ! output unit
    type(mod_file),pointer :: f   ! current file
    type(mod_location),pointer :: loc   ! location
    type(mod_plan),pointer :: p         ! pointer to the current plan
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="writeIgnoredLocXML"
    character*250 :: buff250
    character*50 :: s1
    integer :: lenb,len1
    integer, external :: length
    if (loc%search(0) .eq. 0) then
       ! write location information
       !
       write(s1,'(I0)')loc%locid
       call chop0(s1,50)
       len1=length(s1,50,10)
       buff250="id='"//s1(1:len1)//"' ignored='Search out of bounds for dimension:"// &
            & f%dim80(loc%search(0))(1:f%lend(loc%search(0)))//"'"
       call chop0(buff250,250)
       lenb=length(buff250,250,10)
       write(ounit,'(4X,A)',iostat=irc) "<field "//buff250(1:lenb)//"/>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 10.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    return
  end subroutine model_writeIgnoredLocXML
  !
  ! make XML for variables at location
  !
  subroutine model_setLocValXML(css,ounit,f,varid,lenv,&
               & var250,lent,trg80,lens,sval50,loc,itrg,ff,p,bok,crc250,irc)
    type(mod_session), pointer :: css   ! current session
    integer :: ounit                  ! output unit
    type(mod_file),pointer :: f   ! current file
    integer :: varid                    ! current variable
    integer :: lenv
    character*250 :: var250
    integer :: lent
    character*80 :: trg80
    integer :: lens
    character*50 :: sval50
    type(mod_location),pointer :: loc   ! location
    integer :: itrg
    integer :: ff ! offset
    type(mod_plan),pointer :: p         ! pointer to the current plan
    logical :: bok                      ! was any data printed?
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setLocValXML"
    real :: val
    logical :: bout, binn
    integer ::lenb,lenp,lenl,len1
    character*50 :: s1
    integer, external :: length
    character*250 :: buff250, loc250,pos250
    type(mod_variable),pointer :: v   ! variable pointer
    integer :: ninn, nout, pinn,cinn,cout
    real :: sum,tsum,wgt,twgt,tval
    integer, allocatable :: inn(:), out(:),ind(:)
    integer ::cnt,cval,ctot,jj
    logical :: first,set
    if (.not.loc%bok .or. loc%search(0) .ne. 0) return
    v => f%var(varid)%ptr
    !
    ! write location information
    !
    write(s1,'(I0)') loc%locid
    call chop0(s1,50)
    len1=length(s1,50,10)
    if (lent.ne.0) then
       loc250=" id='"//s1(1:len1)//"' target='"//trg80(1:lent)//"' "//sval50(1:lens)
    else
       loc250=" id='"//s1(1:len1)//"' "//sval50(1:lens)
    end if
    call chop0(loc250,250)
    lenl=length(loc250,250,10)
    !
    pos250=model_getPosWgt50(css,v,loc,ff)
    call chop0(pos250,250)
    lenp=length(pos250,250,10)
    if (lenp.ne.0) then
       pos250=" pos='"//pos250(1:lenp)//"'"
       lenp=lenp+7
    end if
    !
    first=.true.
    !
    ! get outer and inner loop indexes
    !
    if(allocated(out)) deallocate(out)
    if(allocated(inn)) deallocate(inn)
    if(allocated(ind)) deallocate(ind)
    allocate(out(p%ndim),inn(p%ndim),ind(p%ndim))
    !
    ! plan the inner (search dimensions) and outer loops
    !
    call model_planLoop(v,p,nout,out,ninn,inn,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from planLoop.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    call model_planTrgInd(css,ninn,inn,ind,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from planTrgInd.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    if(mod_bdeb)write(*,*)myname,"Innout:",ninn,nout," Undef:",nf_fill_double
    if (mod_bdeb) then
       do jj=1,ninn
          write(*,*)myname,'Inner:',jj,inn(jj), &
               & css%currentFile%dim80(inn(jj))(1:css%currentFile%lend(inn(jj)))
       end do
       do jj=1,nout
          write(*,*)myname,'Outer:',jj,out(jj), &
               & css%currentFile%dim80(out(jj))(1:css%currentFile%lend(out(jj)))
       end do
    end if
    !
    ! write value information
    !
    twgt=0.0D0
    tsum=0.0D0
    cnt=0
    call model_resetPos(nout,out,loc,ff,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from resetPos.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    bout=.false.
    do while (.not. bout)
       pinn=0   ! previous  dimension index
       call model_resetPos(ninn,inn,loc,ff,crc250,irc) 
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from resetPos.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       ctot=0 ! total number of grid points
       cval=0 ! number of valid grid points
       binn=.false.
       do while (.not. binn)
          if(mod_bdeb)write(*,*)myname,"Calling getLocValue."
          set = model_getLocValue(v,loc,ff,val,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from getLocValue.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          cnt=cnt+1
          ctot=ctot+1
          if(mod_bdeb)write(*,*)myname,"Calling Incrementing position."
          if (set) then ! val.ne.nf_fill_double
             if (first) then
                write(ounit,'(4X,A)',iostat=irc) "<field "//loc250(1:lenl)//" "//&
                     & var250(1:lenv)//pos250(1:lenp)//">"
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Unable to write to file 11.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
                first=.false.
             end if
             wgt=model_getWeight(ninn,inn,loc,ff) ! current weight
             buff250=model_getGrid250(f,v,loc,ff,val,wgt,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from getGrid250.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             call chop0(buff250,250)
             lenb=length(buff250,250,10)
             if (lenb.ne.0) then
                write(ounit,'(5X,A)',iostat=irc) buff250(1:lenb)
                if (irc.ne.0) then
                   call model_errorappend(crc250,myname)
                   call model_errorappend(crc250," Unable to write to file 12.")
                   call model_errorappendi(crc250,irc)
                   call model_errorappend(crc250,"\n")
                   return
                end if
             end if
             tsum=tsum+wgt*val
             twgt=twgt+wgt
             cval=cval+1
          end if
          !if(mod_bdeb)write(*,*) myname,'Weight:',twgt,wgt,val
          cinn=model_incrementPos(ninn,inn,loc,ff) ! current inn
          binn=(cnt.gt.250.or.(cinn.eq.0))
          if(mod_bdeb)write(*,'(X,A,A,I0,X,I0,X,L1,X,F5.2,X,F10.3)')myname,&
               & 'Count inner B: ',cinn,cnt,binn,wgt,tsum
       end do
       if(mod_bdeb)write(*,*)myname,'Checking:',twgt,ctot,cval,itrg
       if (twgt.gt.1.0D-10.and.ctot.eq.cval.and.ctot.ge.1) then
          tval=tsum/twgt
          if (itrg.ne.0) then
             call model_setLocTrgVal(css,loc,itrg,tval,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from setLocTrgVal.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             call model_locRposToTrg(css,loc,ff,ninn,inn,ind,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from resetLocTrg.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             call model_setOutVal(css,tval,itrg,loc%iloc,crc250,irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Error return from setOutVal.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
          end if
          buff250=model_getInt250(f,v,loc,tval,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from getInt250.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          call chop0(buff250,250)
          lenb=length(buff250,250,10)
          if (lenb.ne.0) then
             write(ounit,'(5X,A)',iostat=irc) buff250(1:lenb)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Unable to write to file 13.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
          end if
       end if
       cout=model_incrementPos(nout,out,loc,ff)
       bout=(cnt.gt.32.or.(cout.eq.0))
       if(mod_bdeb)write(*,*)myname,'Count outer:',cout,cnt,bout
    end do
    if (.not.first) then
       write(ounit,'(4X,A)',iostat=irc) "</field>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 14.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    if(allocated(out)) deallocate(out)
    if(allocated(inn)) deallocate(inn)
    if(allocated(ind)) deallocate(ind)
    return
  end subroutine model_setLocValXML
  !
  ! write location XML to file
  !
  subroutine model_writexml(css,ounit,locid,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: ounit
    integer :: locid
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_writexml"
    character*250 :: buff250
    type(mod_location), pointer :: loc
    integer, external :: length
    character*50 :: s1,s2,s3,s4
    integer :: len1,len2,len3,len4, pos,ii
    !
    pos=locid-css%locoo
    loc => css%locData(pos)%ptr
    if (associated(loc)) then
       if (loc%bok) then
          write(ounit,'(3X,A,I0,A)',iostat=irc) "<location id='",loc%locid,"' status='ok'>"
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to write to file 15.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          write(ounit,'(4X,A,I0,A)',iostat=irc) "<model targets='",loc%ctrg,"'>"
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to write to file 16.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          do ii=1,loc%ctrg
             if (loc%trg_set(ii)) then
                call model_wash(loc%trg_val(ii),s3,len3)
                if (len3.ne.0) then
                   s3=" value='"//s3(1:len3)//"'"
                   len3=len3+9
                end if
             else
                len3=0
             end if
             write (ounit,'(5X,A)',iostat=irc) "<target name='"//&
                  & css%trg80(ii)(1:css%trg_lent(ii))//"'"//&
                  & s3(1:len3)//">"
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Unable to write to file 17.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
          end do
          write(ounit,'(4X,A)',iostat=irc) "</model>"
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to write to file 18.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          write(ounit,'(4X,A,I0,A)',iostat=irc) "<observation targets='",loc%cobs,"'>"
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to write to file 19.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          do ii=1,loc%cobs
             call model_wash(loc%obs_val(ii),s3,len3)
             if (len3.ne.0) then
                s3=" value='"//s3(1:len3)//"'"
                len3=len3+9
             end if
             write (ounit,'(5X,A)',iostat=irc) "<target name='"//&
                  & css%obs_var(ii)(1:css%obs_lenv(ii))//"'"//&
                  & s3(1:len3)//">"
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Unable to write to file 20.")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
          end do
          write(ounit,'(4X,A)',iostat=irc) "</observation>"
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to write to file 21.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          write(ounit,'(3X,A)',iostat=irc) "</location>"
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to write to file 22.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       else
          write(ounit,'(3X,A,I0,A)',iostat=irc) "<location id='",loc%locid,"' status='rejected'/>"
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to write to file 23.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       end if
    end if
    return
  end subroutine model_writexml
  !
  subroutine model_writeModelDataXML(css,ounit,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: ounit                  ! output unit
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="writeModelDataXML"
    integer :: len1,len2,len3,len4
    integer, external :: length
    character*50 :: s1,s2,s3,s4
    integer :: ii
    write(ounit,'(1X,A,I0,A)',iostat=irc)"<model targets='",css%ctrg,"'>"
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to write to file 24.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if (css%trg_orm(0).ne.0) then
       write(ounit,'(2X,A,I0,A)',iostat=irc)"<check removed='",css%trg_orm(0),&
            & "' reason='outside target limits.'>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 25.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    do ii=1,css%ctrg
       if (css%trg_orm(ii).ne.0) then
          s1=css%trg80(ii)(1:50) ; call chop0(s1,50); len1=length(s1,50,10)!id
          IF (len1.ne.0) then
             s1=" name='"//s1(1:len1)//"'"
             len1=len1+8
          end if
          if (css%trg_minset(ii)) then
             call model_wash(css%trg_minval(ii),s3,len3)
             if (len3.ne.0) then
                s3=" min='"//s3(1:len3)//"'"
                len3=len3+7
             end if
          else
             len3=0
          end if
          if (css%trg_maxset(ii)) then
             call model_wash(css%trg_maxval(ii),s4,len4)
             if (len4.ne.0) then
                s4=" max='"//s4(1:len4)//"'"
                len4=len4+7
             end if
          else
             len4=0
          end if
          write(ounit,'(3X,A,I0,A)',iostat=irc)"<target removed='",css%trg_orm(ii),&
               & "'"//s1(1:len1)//s3(1:len3)//s4(1:len4)//"/>"
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Unable to write to file 26.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       end if
    end do
    if (css%trg_orm(0).ne.0) then
       write(ounit,'(2X,A,I0,A)',iostat=irc)"</check>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 27.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    write(ounit,'(1X,A)',iostat=irc)"</model>"
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to write to file 28.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    return
  end subroutine model_writeModelDataXML
  !
  ! variable dimensions
  ! 
  character*50 function model_getDim(file,var)
    type(mod_file),pointer :: file
    type(mod_variable),pointer :: var
    integer ii,leng
    model_getDim=""
    leng=0
    do ii=1,var%ndim
       if (leng.eq.0)then
          model_getDim=file%dim80(var%ind(ii))(1:file%lend(var%ind(ii)))
          leng=file%lend(var%ind(ii))
       else
          model_getDim=model_getDim(1:leng)//","//&
               & file%dim80(var%ind(ii))(1:file%lend(var%ind(ii)))
          leng=leng+1+file%lend(var%ind(ii))
       end if
    end do
    return
  end function model_getDim
  !
  ! write position
  !
  subroutine model_planLoop(v,p,nout,out,ninn,inn,crc250,irc) 
    type(mod_variable),pointer :: v   ! variable pointer
    type(mod_plan),pointer :: p       ! plan pointer
    integer :: nout
    integer, allocatable :: out(:)
    integer :: ninn
    integer, allocatable :: inn(:)
    character*250 :: crc250
    integer :: irc
    !
    integer :: jj,cnt
    character*25 :: myname="model_planLoop"
    !
    cnt=1
    nout=0
    ninn=0
    do jj=1,v%ndim
       if (p%innerDim(v%ind(jj))) then
          ninn=ninn+1
          inn(ninn)=v%ind(jj)
       else
          cnt=cnt*(v%icount(jj))
          nout=nout+1
          out(nout)=v%ind(jj)
       end if
    end do
    if (cnt.gt.250) then
       if (mod_bdeb) then
          write(*,*)myname,''
       end if
       irc=777
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Insufficient target matching. Too large count=")
       call model_errorappendi(crc250,cnt)
       return
    end if
    return
  end subroutine model_planLoop
  !
 subroutine model_planTrgInd(css,ninn,inn,ind,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: ninn
    integer, allocatable :: inn(:)
    integer, allocatable :: ind(:)
    character*250 :: crc250
    integer :: irc
    integer :: ii,jj
    do jj=1,ninn
       ind(jj)=0
       do ii=1,css%ntrg
          if (css%trg_dim(ii).eq.inn(jj)) then
             ind(jj)=ii
          end if
       end do
    end do
    return
  end subroutine model_planTrgInd
  !
  ! set model sorting index variable
  !
  subroutine model_setIndex(css,trgname,varname,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character(len=*) :: trgname
    character(len=*) :: varname
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setIndex"
    integer,external :: length
    integer :: lent
    character*80 :: t80
    t80=trgname
    call chop0(t80,80)
    lent=length(t80,80,10)
    if(mod_bdeb)write(*,*)myname,' Entering: ',t80(1:lent),irc
    css%ind_trg=t80
    css%ind_lent=lent
    css%ind_var=varname
    call chop0(css%ind_var,80)
    css%ind_lenv=length(css%ind_var,80,10)
    css%ind_set=.true.
    !if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_setindex
  !
  subroutine model_getIndex(css,trg80,var80,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*80 :: trg80
    character*80 :: var80
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setIndex"
    integer,external :: length
    if(mod_bdeb)write(*,*)myname,' Entering.',irc
    trg80=css%ind_trg
    var80=css%ind_var
    if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_getIndex
  !
  ! set the sort variable limits
  !
  subroutine model_setIndexLimits(css, smin, smax, crc250,irc)
    type(mod_session), pointer :: css !  current session
    character(LEN=*) :: smin
    character(LEN=*) :: smax
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_setIndexLimits"
    integer :: lens, lene, JJ
    integer, external :: length
    type(parse_session),pointer :: plim => null()  ! parse_session pointer must be se
    character*80, allocatable :: var(:)
    real, allocatable :: val(:)
    lens=len_trim(smin)
    lene=len_trim(smax)
    call parse_open(plim,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from parse_open.")
       return
    end if
    if (lens.ne.0) then
       call parse_parsef(plim,smin(1:lens),var,crc250,irc)
       if (irc.ne.0) then
          if(mod_bdeb)then
             write(*,*)myname," Compiling target limit: '"//&
                  & smin(1:lens)//"'"
             do jj=1,size(var)
                write(*,'(A,A,I0,A)')myname,"     var(",jj,") = '"//&
                     & trim(var(jj))//"'"
             end do
          end if
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from parsef.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       css%ind_minval=parse_evalf(plim,val,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from evalf.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       css%ind_lval(1)=.true.
    else
       css%ind_lval(1)=.false.
    end if
    if (lene.ne.0) then
       call parse_parsef(plim,smax(1:lene),var,crc250,irc)
       if (irc.ne.0) then
          if(mod_bdeb)then
             write(*,*)myname," Compiling target limit: '"//&
                  & smax(1:lene)//"'"
             do jj=1,size(var)
                write(*,'(A,A,I0,A)')myname,"     var(",jj,") = '"//&
                     & trim(var(jj))//"'"
             end do
          end if
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from parsef.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       css%ind_maxval=parse_evalf(plim,val,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from evalf.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       css%ind_lval(2)=.true.
    else
       css%ind_lval(2)=.false.
    end if
    call parse_close(plim,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from parse_close.")
       return
    end if
    if(mod_bdeb)write(*,*)myname,"Done min='"//trim(smin)//"' max='"//smax//"'",&
         css%ind_lval,css%ind_minval,css%ind_maxval
    return
  end subroutine model_setIndexLimits
  !
  ! set stack file limits
  !
  subroutine model_setFileStackLimits(css,ind_lval,ind_minval,ind_maxval,crc250,irc)
    implicit none
    type(mod_session), pointer :: css !  current session
    logical :: ind_lval(2)
    real :: ind_minval,ind_maxval
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="model_setFileStackLimits"
    ! set limits
    if (mod_bdeb)write(*,*)myname,' Entering:',ind_lval,ind_minval,ind_maxval
    ! make sure file stack is sorted
    if (mod_bdeb)write(*,*)myname,'Sorting stack.'
    if (.not.css%fileReady) then
       call model_sortStack(css,crc250,irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from model_sortStack.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       css%fileReady = .true.
    end if
    if (mod_bdeb)write(*,*)myname,'Find stack start/stop.'
    ! find index start/stop...
    call model_findStackLimits(css,ind_lval,ind_minval,ind_maxval,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from model_setStackLimits.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    css%currentFileSortIndex=0 ! reset index
    if (mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_setFileStackLimits
  !
  ! private subroutine for setting start/end-search-dates
  !
  subroutine model_setIndexLimitsRaw(css,ind_lval,ind_minval,ind_maxval)
    type(mod_session), pointer :: css !  current session
    logical :: ind_lval(2)
    real :: ind_minval,ind_maxval
    character*22 :: myname="model_setIndexLimitsRaw"
    css%ind_lval(1)=ind_lval(1)
    css%ind_lval(2)=ind_lval(2)
    css%ind_minval=ind_minval
    css%ind_maxval=ind_maxval
  end subroutine model_setIndexLimitsRaw
  !
  ! retrieve target variable list
  !
  subroutine model_getvariables(css,nvar,var80,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: nvar
    character*80, allocatable :: var80(:)
    character*250 :: crc250
    integer :: irc
    type(mod_target), pointer :: currentTarget
    character*25 :: myname="model_getVariables"
    if (allocated(var80)) deallocate(var80)
    allocate(var80(css%ntrg),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to allocate var80.")
       call model_errorappendi(crc250,css%ntrg)
       return
    end if
    nvar=0
    currentTarget => css%firstTrg%next
    do while (.not.associated(currentTarget,target=css%lastTrg))
       nvar=min(css%ntrg,nvar+1)
       var80(nvar)=currentTarget%n80
       currentTarget => currentTarget%next
    end do
    return
  end subroutine model_getvariables
  !
  subroutine model_filestartxml(css,ounit,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: ounit                  ! output unit
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_filestartxml"
    if (associated(css%currentFile)) then
       write(ounit,'(1X,A)',iostat=irc)"<modelFile file='"//&
            & css%currentFile%fn250(1:css%currentFile%lenf)//"'>"
    else
       write(ounit,'(1X,A)',iostat=irc)"<modelFile>"
    end if
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to write to file 29.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    return
  end subroutine model_filestartxml
  !
  subroutine model_filestopxml(css,ounit,crc250,irc)
    type(mod_session), pointer :: css !  current session
    integer :: ounit                  ! output unit
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_filestopxml"
    integer :: ii
    write(ounit,'(2X,A)',iostat=irc)"<summary>"
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to write to file 30.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if (css%currentFile%ook(1).eq.css%currentFile%ook(4)) then
       write(ounit,'(3X,A,I0,A,I0,A)',iostat=irc)"<locations found='",css%currentFile%ook(1),&
            & "' accepted='",css%currentFile%ook(4),"'/>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 31.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    else
       write(ounit,'(3X,A,I0,A,I0,A)',iostat=irc)"<locations found='",css%currentFile%ook(1),&
            & "' accepted='",css%currentFile%ook(4),"'>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 32.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       if (css%currentFile%orm(2).ne.0) then
       write(ounit,'(4X,A,I0,A)',iostat=irc)"<check removed='",&
            & css%currentFile%orm(2),&
            & "' reason='rejected by target filter.'"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 33.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    if (css%currentFile%orm(3).ne.0) then
       write(ounit,'(4X,A,I0,A)',iostat=irc)"<check removed='",&
            & css%currentFile%orm(3),&
            & "' reason='search failed.'/>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 34.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    if (css%currentFile%orm(4).ne.0) then
       write(ounit,'(4X,A,I0,A)',iostat=irc)"<check removed='",&
            & css%currentFile%orm(4),&
            & "' reason='rejected by model filter.'/>"
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Unable to write to file 35.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    end if
    write(ounit,'(3X,A)',iostat=irc)"</locations>"
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to write to file 36.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    end if
    write(ounit,'(2X,A)',iostat=irc)"</summary>"
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to write to file 37.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    write(ounit,'(1X,A)',iostat=irc)"</modelFile>"
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to write to file 38.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    return
  end subroutine model_filestopxml
  ! get nice real value
  subroutine model_wash(val,s2,len2)
    real :: val
    character*50 :: s2
    integer :: len2
    integer, external :: length
    integer :: jj
    write(s2,'(F0.10)') val; call chop0(s2,50); len2=length(s2,50,10) ! ignore last digit...
    if (len2.gt.1) then
       OUTER: do JJ=1,len2
          if (s2(JJ:JJ).eq.".") then
             INNER: do while (len2.gt.JJ.and.&
               & (s2(len2:len2).eq."0".or.s2(len2:len2).eq."."))
                len2=len2-1
             end do INNER
             exit OUTER
          end if
       end do OUTER
       if (len2.eq.1.and.s2(1:1).eq.".") then
          s2="0"
       else if (s2(len2:len2).eq.".") then
          len2=len2-1
       end if
    end if
    return
  end subroutine model_wash
  !
  !###############################################################################
  ! NETCDF ROUTINES
  !###############################################################################
  ! open netcdf file
  !
  subroutine model_openFile(css,f,crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_file),pointer :: f
    character*250 :: crc250
    integer :: irc
    integer :: ret
    character*25 :: myname="model_openFile"
    INTEGER :: CHUNKSIZEHINT
    integer :: ii
    chunksizehint= 1024*1024*1024
    if (F%LENF.eq.0) then
       irc=999
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Attempt to open empty file.")
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,'Opening modfile: ',f%fn250(1:f%lenf)
    ret = NF__OPEN(f%fn250(1:F%LENF),nf_nowrite,&
         & chunksizehint,f%ncid)
    if (ret .ne. NF_NOERR) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to open "//f%fn250(1:f%lenf))
       call model_errorappendi(crc250,ret)
       call model_errorappend(crc250,"\n")
       irc=780
       return
    endif
    do ii=1,10
       f%ook(ii)=0
       f%orm(ii)=0
    end do
     return
  end subroutine model_openFile
  !
  ! read netcdf file inventory
  !
  subroutine model_readInventory(css,f,crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_file),pointer :: f
    character*250 :: crc250
    integer :: irc
    integer :: ret,ii,dd,varid,len,lena
    integer, external :: length
    character*25 :: myname="model_readInventory"
    character*1, pointer ::  ac(:)
    integer*1,  pointer::  a1(:)
    integer*2,  pointer::  a2(:)
    integer*4,  pointer::  a4(:)
    real*4,     pointer::  ar(:)
    real*8,     pointer::  ad(:)
    type(mod_attribute),pointer :: att
    type(mod_variable),pointer :: v
    !
    css%currentfile => f
    call model_clearCurrentFile(css,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from clearCurrentFile.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    ! get number of dimension, variables, att, unlimited dimension id
    !
    if(mod_bdeb)write(*,*)myname,' Entering.'
    RET = NF_INQ(f%ncid,   f%ndim, f%nvar,  &
         &       f%ngatt, f%unlimdimid)
    if (ret .ne. NF_NOERR) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error from NF_INQ: "//nf_strerror(ret))
       call model_errorappendi(crc250,ret)
       call model_errorappend(crc250,"\n")
       irc=790
       return
    end if
    !
    if(mod_bdeb)write(*,*)myname,' Allocate file.'
    !     allocate variables in file
    if (allocated(f%dim80)) deallocate(f%dim80)
    if (allocated(f%lend)) deallocate(f%lend)
    if (allocated(f%dim_trg)) deallocate(f%dim_trg)
    if (allocated(f%istart)) deallocate(f%istart)
    if (allocated(f%istop)) deallocate(f%istop)
    if (allocated(f%dim_var)) deallocate(f%dim_var)
    if (allocated(f%dim_val)) deallocate(f%dim_val)
    if (allocated(f%var80)) deallocate(f%var80)
    if (allocated(f%lenv)) deallocate(f%lenv)
    allocate(f%dim80(f%ndim),&
         &   f%lend(f%ndim),&
         &   f%dim_trg(f%ndim),&
         &   f%istart(f%ndim),&
         &   f%istop(f%ndim),&
         &   f%dim_var(f%ndim),&
         &   f%dim_val(f%ndim),&
         &   f%var80(f%nvar),&
         &   f%lenv(f%nvar),&
         &   stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate file.")
       call model_errorappendi(crc250,f%ndim)
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !     
    if(mod_bdeb)write(*,*)myname,' Store dim.'
    !     -> store dimension names
    do dd=1,f%ndim
       f%istart(dd)=1
       RET = NF_INQ_DIM(f%NCID, DD, &
            &           f%dim80(dd), &
            &           f%istop(dd))
       if (ret .ne. NF_NOERR) then
          irc=801
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from NF_INQ_DIM."//nf_strerror(ret))
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       call chop0(f%dim80(dd),80)
       f%lend(dd)=length(f%dim80(dd),80,10)
       f%dim_var(dd)=f%dim80(dd)(1:f%lend(dd))
       f%dim_val(dd)=real(f%istop(dd))
       f%dim_trg(dd)=0
    end do
    !
    if(mod_bdeb)write(*,*)myname,' Allocate var pointers.',f%nvar
    !     allocate variables in file
    allocate(f%var(f%nvar),stat=irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250,"Unable to allocate vars.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    if(mod_bdeb)write(*,*)myname,' Process var.'
    !     -> store variable names
    do varid=1,f%nvar
       allocate(f%var(varid)%ptr,stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate vars.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       v=>f%var(varid)%ptr
       v%ndim=0
       v%natt=0
       ret = NF_INQ_VARNDIMS (f%ncid, varid, v%ndim);
       if (ret .ne. NF_NOERR) then
          irc=802
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from NF_INQ_VARNDIMS."//&
               & nf_strerror(ret))
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       allocate(v%ind(v%ndim),v%istart(v%ndim),v%icount(v%ndim),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate var.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       RET = NF_INQ_VAR(f%ncid, varid,v%var80,v%type,v%ndim,v%ind,v%natt)
       if (ret .ne. NF_NOERR) then
          irc=802
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from NF_INQ_VAR."//nf_strerror(ret))
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       call chop0(v%var80,80)
       v%lenv=length(v%var80,80,10)
       f%var80(varid)=v%var80
       f%lenv(varid)=v%lenv
       do ii=1,v%ndim
          v%istart(ii)=1
          v%icount(ii)=f%istop(v%ind(ii))
       end do
       call chop0(v%var80,80)
       ! process attributes
       v%scale=1.0
       v%offset=0.0
       v%mc=char(nf_fill_char)
       v%m1=nf_fill_int1
       v%m2=nf_fill_int2
       v%m4=nf_fill_int
       v%mr=nf_fill_real
       v%md=nf_fill_double
       v%misstype=0
       !
       !if(mod_bdeb)write(*,*)myname,' Store attr.'
       allocate(v%att(v%natt),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate var-att.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       do ii=1,v%natt
          allocate(att,stat=irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250,"Unable to allocate att.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          RET=NF_INQ_ATTNAME(f%NCID,VARID,ii,att%att80)
          if (ret .ne. NF_NOERR) cycle
          RET=NF_INQ_ATT(f%NCID,VARID,att%att80,att%type,att%len)
          if (ret.ne.NF_NOERR) cycle
          if (att%len.eq.0) then
             irc=845
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250,"Zero length attribute ")
             call model_errorappend(crc250,att%att80)
             call model_errorappend(crc250,"\n")
             return
          end if
          select case (att%type)
          case (nf_char)
             if (allocated(att%ac)) deallocate(att%ac)
             allocate(att%ac(att%len),stat=irc)
             if (irc.eq.0) ret = nf_get_att_text (f%ncid, varid,att%att80,att%ac)
          case(nf_int1)
             if (allocated(att%a1)) deallocate(att%a1)
             allocate(att%a1(att%len),stat=irc)
             if (irc.eq.0) ret = nf_get_att_int1 (f%ncid, varid,att%att80,att%a1)
          case(nf_int2)
             if (allocated(att%a2)) deallocate(att%a2)
             allocate(att%a2(att%len),stat=irc)
             if (irc.eq.0) ret = nf_get_att_int2 (f%ncid, varid,att%att80,att%a2)
          case(nf_int)
             if (allocated(att%a4)) deallocate(att%a4)
             allocate(att%a4(att%len),stat=irc)
             if (irc.eq.0) ret = nf_get_att_int (f%ncid, varid,att%att80,att%a4)
          case(nf_real)
             if (allocated(att%ar)) deallocate(att%ar)
             allocate(att%ar(att%len),stat=irc)
             if (irc.eq.0) ret = nf_get_att_real (f%ncid, varid, att%att80,att%ar)
          case(nf_double)
             if (allocated(att%ad)) deallocate(att%ad)
             allocate(att%ad(att%len),stat=irc)
             if (irc.eq.0) ret = nf_get_att_double (f%ncid, varid,att%att80,att%ad)
          case DEFAULT
          end select
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250,"Unable to allocate att value.")
             call model_errorappendi(crc250,v%ndim)
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          if (ret.ne.NF_NOERR) cycle
          call chop0(att%att80,80)
          att%lena=length(att%att80,80,10)
          !if(mod_bdeb)write(*,*)myname,' get attr.',ii,att%att80(1:att%lena)
          !     check if we have scale-factor/missing value
          if (att%att80(1:att%lena).eq."scale_factor") then
             select case (att%type)
             case(nf_real)
                v%scale=att%ar(1)
             case(nf_double)
                v%scale=att%ad(1)
             case DEFAULT
             end select
          else if (att%att80(1:att%lena).eq."add_offset") then
             select case (att%type)
             case(nf_real)
                v%offset=att%ar(1)
             case(nf_double)
                v%offset=att%ad(1)
             case DEFAULT
             end select
          else if (att%att80(1:att%lena).eq."missing_value") then
             select case (att%type)
             case (nf_char)
                v%mc=att%ac(1)
                v%misstype=nf_char
             case (nf_int1)
                v%m1=att%a1(1)
                v%misstype=nf_int1
             case (nf_int2)
                v%m2=att%a2(1)
                v%misstype=nf_int2
             case (nf_int)
                v%m4=att%a4(1)
                v%misstype=nf_int
             case (nf_real)
                v%mr=att%ar(1)
                v%misstype=nf_real
             case (nf_double)
                v%md=att%ad(1)
                v%misstype=nf_double
             case DEFAULT
             end select
          else
             if (allocated(att%ac)) deallocate(att%ac,stat=irc)
             if (allocated(att%a1)) deallocate(att%a1,stat=irc)
             if (allocated(att%a2)) deallocate(att%a2,stat=irc)
             if (allocated(att%a4)) deallocate(att%a4,stat=irc)
             if (allocated(att%ar)) deallocate(att%ar,stat=irc)
             if (allocated(att%ad)) deallocate(att%ad,stat=irc)
          end if
          v%att(ii)%ptr => att
          att => null()
       end do
    end do
    if(mod_bdeb)write(*,*)myname,' Done.'
  end subroutine model_readInventory
  !
  ! check variable limits
  !
  subroutine model_setRange(css,f,crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_file),pointer :: f
    character*250 :: crc250
    integer :: irc
    integer :: varid,ii
    type(mod_variable),pointer :: v
    character*25 :: myname="model_setRange"
    real :: val
    integer*8, parameter :: maxlen=1000
    integer*8 :: dimlen
    do varid=1,f%nvar
       v=>f%var(varid)%ptr
       dimlen=model_varLen(v)
       if (dimlen.lt.maxlen) then
          if (mod_bdeb)write(*,*)myname,"Opening '"//v%var80(1:v%lenv)//"'"
          call model_readVariable(css,f,varid,crc250,irc)       
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from readVariable.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          if (mod_bdeb)write(*,*)myname,"Scanning:'"//v%var80(1:v%lenv)//"'",v%len,v%type
          v%mmrange=.true.
          select case (v%type)
          case (nf_char)
          case (nf_int1)
             if (mod_bdeb)write(*,*)myname,"Int1.",v%scale,v%offset
             do ii=1,v%len
                val=real((v%f1(ii)*v%scale)+v%offset)
                if (v%f1(ii).ne.v%m1) then
                   if (v%mmset) then
                      v%minval=min(v%minval,val)
                      v%maxval=max(v%maxval,val)
                   else
                      v%minval=val
                      v%maxval=val
                      v%mmset=.true.
                   end if
                end if
             end do
          case (nf_int2)
             if (mod_bdeb)write(*,*)myname,"Int2.",v%scale,v%offset
             do ii=1,v%len
                val=real((v%f2(ii)*v%scale)+v%offset)
                if (v%f2(ii).ne.v%m2) then
                   if (v%mmset) then
                      v%minval=min(v%minval,val)
                      v%maxval=max(v%maxval,val)
                   else
                      v%minval=val
                      v%maxval=val
                      v%mmset=.true.
                   end if
                end if
             end do
          case (nf_int)
             if (mod_bdeb)write(*,*)myname,"Int4.",v%scale,v%offset
             do ii=1,v%len
                val=real((v%f4(ii)*v%scale)+v%offset)
                if (v%f4(ii).ne.v%m4) then
                   if (v%mmset) then
                      v%minval=min(v%minval,val)
                      v%maxval=max(v%maxval,val)
                   else
                      v%minval=val
                      v%maxval=val
                      v%mmset=.true.
                   end if
                end if
             end do
          case (nf_real)
             if (mod_bdeb)write(*,*)myname,"Real.",v%scale,v%offset
             do ii=1,v%len
                val=real((v%fr(ii)*v%scale)+v%offset)
                if (v%fr(ii).ne.v%mr) then
                   if (v%mmset) then
                      v%minval=min(v%minval,val)
                      v%maxval=max(v%maxval,val)
                   else
                      v%minval=val
                      v%maxval=val
                      v%mmset=.true.
                   end if
                end if
             end do
          case (nf_double)
             if (mod_bdeb)write(*,*)myname,"Double.",v%scale,v%offset
             do ii=1,v%len
                val=(v%fd(ii)*v%scale)+v%offset
                if (v%fd(ii).ne.v%md) then
                   if (v%mmset) then
                      v%minval=min(v%minval,val)
                      v%maxval=max(v%maxval,val)
                   else
                      v%minval=val
                      v%maxval=val
                      v%mmset=.true.
                   end if
                end if
             end do
          case DEFAULT
          end select
          if (mod_bdeb)write(*,*)myname,"Clearing:'"//v%var80(1:v%lenv)//"'",&
               & v%len,v%mmset,v%minval,v%maxval
          call model_clearVariable(v,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from clearVariable.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       end if
    end do
    if (mod_bdeb)write(*,*)myname,"Done."
    return
  end subroutine model_setRange
  !
  ! read variable values into memory...
  !
  subroutine model_readVariable(css,f,varid,crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_file),pointer :: f
    integer :: varid
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_readVariable"
    integer*1::  fill1
    integer*2::  fill2
    integer*4::  fill4
    real*4::     fillr
    real*8::     filld
    integer :: ii,ret,lend
    integer,external :: length
    character*50 :: dim50
    type(mod_variable),pointer :: v
    integer*8, parameter :: maxlen=2147483647
    !
    v => f%var(varid)%ptr
    !
    if(mod_bdeb)then
       dim50=model_getDim(f,v)
       call chop0(dim50,50)
       lend=length(dim50,50,10)
       write(*,*)myname,"Processing '",&
            & v%var80(1:v%lenv)//"("//dim50(1:lend)//")'"
       do ii=1,v%ndim
          write(*,'(X,A,A," = "I0,":",I0,X,I0)') myname,&
               & "    dim '"//f%dim80(v%ind(ii))(1: &
               & f%lend(v%ind(ii)))//"'",v%istart(ii),v%istart(ii)+v%icount(ii)-1,f%istop(v%ind(ii))
       end do
    end if
    ! find length of grid
    v%len=1
    do ii=1,v%ndim
       v%len=v%len*(v%icount(ii))
    end do
    !
    if (mod_bdeb) then
       write(*,'(X,A,A,I0,A)')myname,&
            &" *** Allocating: '"//v%&
            & var80(1:v%lenv)//"(",&
            & v%len,")"
    end if
    !
    call model_clearVariable(v,crc250,irc)
    if (irc.ne.0) then
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Error return from clearVariable.")
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    !
    select case (v%type)
    case (nf_int1)
       if(mod_bdeb)write(*,*)myname,'Allocating Int 1.',v%len
       allocate( v%f1(v%len),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate var1 value.")
          call model_errorappendi8(crc250,v%len)
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       ret = nf_get_vara_int1(f%ncid,varid,v%istart,v%icount,v%f1)
       if (ret .ne. NF_NOERR) then
          irc=812
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from NF_GET_VARA_INT1."//&
               & nf_strerror(ret))
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    case (nf_int2)
       if(mod_bdeb)write(*,*)myname,'Allocating Int 2.',v%len
       allocate( v%f2(v%len),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate var2 value.")
          call model_errorappendi8(crc250,v%len)
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       ret = nf_get_vara_int2(f%ncid,varid,v%istart,v%icount,v%f2)
       if (ret .ne. NF_NOERR) then
          irc=812
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from NF_GET_VARA_INT2."//&
               & nf_strerror(ret))
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    case (nf_int)
       if(mod_bdeb)write(*,*)myname,'Allocating Int 4.',v%len
       allocate( v%f4(v%len),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate var4 value.")
          call model_errorappendi8(crc250,v%len)
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       if(mod_bdeb)write(*,*)myname,'Reading Int 4.'
       ret = nf_get_vara_int(f%ncid,varid,v%istart,v%icount,v%f4)
       if (ret .ne. NF_NOERR) then
          irc=812
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from NF_GET_VARA_INT."//&
               & nf_strerror(ret))
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
    case (nf_real)
       if(mod_bdeb)write(*,*)myname,'Allocating Real.',v%len,&
            & f%ncid,varid,nf_real,v%type
       allocate( v%fr(v%len),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate varr value.")
          call model_errorappendi8(crc250,v%len)
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       if(mod_bdeb)write(*,*)myname,'Reading.',v%istart,v%icount,v%len,&
            & allocated(v%fr),size(v%fr)
       ret = nf_get_vara_real(f%ncid,varid,v%istart,v%icount,v%fr)
       if(mod_bdeb)write(*,*)myname,'Returned real',ret
       if (ret .ne. NF_NOERR) then
          irc=812
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250," Error return from NF_GET_VARA_REAL."//&
               & nf_strerror(ret))
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       if(mod_bdeb)write(*,*)myname,'Done real'
    case (nf_double) 
       if(mod_bdeb)write(*,*)myname,'Allocating Double.'
       allocate( v%fd(v%len),stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to allocate vard value.")
          call model_errorappendi8(crc250,v%len)
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       ret = nf_get_vara_double(f%ncid,varid,v%istart,v%icount,v%fd)
       if (ret .ne. NF_NOERR) then
          write(*,*) myname,"ERROR from NF_GET_VARA_DOUBLE:",&
               &                    nf_strerror(ret)
          irc=812
          return
       end if
    case DEFAULT
       if(mod_bdeb)write(*,*)myname,'Undefined.'
       v%len=0
       deallocate( v%fd,stat=irc)
       if (irc.ne.0) then
          call model_errorappend(crc250,myname)
          call model_errorappend(crc250,"Unable to deallocate fd.")
          call model_errorappendi(crc250,irc)
          call model_errorappend(crc250,"\n")
          return
       end if
       return
    end select
    if(mod_bdeb)write(*,*)myname,' Done. ',v%type,v%len,allocated(v%fd)
    return
  end subroutine model_readVariable
  !
  ! clear variable values from memory
  !
  subroutine model_deleteVariable(v,crc250,irc)
    type(mod_variable),pointer :: v
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_deleteVariable"
    !if(mod_bdeb)write(*,*)myname,' Entering.',associated(v)
    if (associated(v)) then
       call model_deleteAttributes(v,crc250,irc)
       if (associated(v%att)) deallocate(v%att)
       if (allocated(v%ind)) deallocate(v%ind)
       if (allocated(v%icount)) deallocate(v%icount)
       if (allocated(v%istart)) deallocate(v%istart)
       if (allocated(v%icount)) deallocate(v%icount)
       v%ndim=0
       v%natt=0
       call model_clearVariable(v,crc250,irc)
    end if
    !if(mod_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine model_deleteVariable
  !
  subroutine model_clearVariable(v,crc250,irc)
    type(mod_variable),pointer :: v
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_clearVariable"
    !if(mod_bdeb)write(*,*)myname,' Entering.',associated(v)
    if (allocated(v%fc)) deallocate(v%fc)
    if (allocated(v%f1)) deallocate(v%f1)
    if (allocated(v%f2)) deallocate(v%f2)
    if (allocated(v%f4)) deallocate(v%f4)
    if (allocated(v%fr)) deallocate(v%fr)
    if (allocated(v%fd)) deallocate(v%fd)
    !if(mod_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine model_clearVariable
  !
  ! clear attibute from memory
  !
  subroutine model_deleteAttributes(v,crc250,irc)
    type(mod_variable),pointer :: v
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_deleteAttributes"
    integer :: attid
    !if(mod_bdeb)write(*,*)myname,' Entering.',associated(v)
    !if(mod_bdeb)write(*,*)myname,'Have.',v%natt,associated(v%att)
    do attid=1,v%natt
       !if(mod_bdeb)write(*,*)myname,'Loop.',attid,v%natt,associated(v%att)
       if (associated(v%att(attid)%ptr)) then
          call model_clearAttribute(v%att(attid)%ptr,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from clearAttribute.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          deallocate(v%att(attid)%ptr)
       end if
    end do
    !if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_deleteAttributes
  !
  subroutine model_clearAttribute(att,crc250,irc)
    type(mod_attribute),pointer :: att
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_clearAttribute"
    !if(mod_bdeb)write(*,*)myname,' Entering.',associated(att)
    if (allocated(att%ac)) deallocate(att%ac)
    if (allocated(att%a1)) deallocate(att%a1)
    if (allocated(att%a2)) deallocate(att%a2)
    if (allocated(att%a4)) deallocate(att%a4)
    if (allocated(att%ar)) deallocate(att%ar)
    if (allocated(att%ad)) deallocate(att%ad)
    !if(mod_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine model_clearAttribute
  !
  ! read sort variable
  !
  subroutine model_readSortVariable(css,f,crc250,irc)
    use sort
    type(mod_session), pointer :: css !  current session
    type(mod_file),pointer :: f
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="model_readSortVariable"
    integer :: iisort,jj,ii
    integer, external :: length
    real :: val
    type(mod_variable),pointer :: v
    !
    ! load ind_var into memory
    !
    css%ind_lenv=length(css%ind_var,80,10)
    if (css%ind_lenv.eq.0) then ! no sort variable
       if(mod_bdeb)write(*,*)myname,'Warning: no file-sorting variable defined.'
       f%nsort=1
       allocate(f%sort(f%nsort),&
            & f%indsort(f%nsort), &
            & f%desc250(f%nsort),stat=irc)
       do jj=1,f%nsort
          f%sort(jj)=0.0D0
          f%indsort(jj)=jj
          f%desc250(jj)="undef"
       end do
       f%ind_lim=.false. ! no target to print...
       f%ind_start=0.0D0
       f%ind_stop=0.0D0
       f%trg=0.0D0
    else
       iisort=0
       do ii=1,f%nvar
!          write(*,*)myname,'Checking: ',ii,' "',f%var80(ii)(1:f%lenv(ii)),'"  "',css%ind_var(1:css%ind_lenv),'"'
          if (css%ind_var(1:css%ind_lenv).eq. &
               & f%var80(ii)(1:f%lenv(ii))) then
             iisort=ii
             exit
          end if
       end do
       if (iisort .ne. 0) then
          call model_readVariable(css,f,iisort,crc250,irc)
          if (irc.ne.0) then
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Error return from readVariable.")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
          v=>f%var(iisort)%ptr
          f%nsort=0
          do ii=1,v%len
             if (model_getValue(v,ii,val,crc250,irc)) then
                f%nsort=f%nsort+1
             else if (mod_bdeb) then
                write(*,*)myname,'Invalid sort variable at:',ii,v%type,nf_double
             end if
          end do
          if (f%nsort.gt.0.and.f%nsort .lt.1000) then
             allocate(f%sort(f%nsort),&
                  & f%indsort(f%nsort), &
                  & f%desc250(f%nsort),stat=irc)
             if (irc.ne.0) then
                call model_errorappend(crc250,myname)
                call model_errorappend(crc250," Unable to allocate varsort:")
                call model_errorappendi(crc250,abs(f%nsort))
                call model_errorappend(crc250,":")
                call model_errorappendi(crc250,irc)
                call model_errorappend(crc250,"\n")
                return
             end if
             jj=0
             do ii=1,v%len
                if (model_getValue(v,ii,val,crc250,irc)) then
                   jj=jj+1
                   f%sort(jj)=val
                   if (jj.eq.1) then
                      f%ind_start=f%sort(jj)
                      f%ind_stop=f%sort(jj)
                   else
                      f%ind_start=min(f%ind_start,f%sort(jj))
                      f%ind_stop=max(f%ind_stop,f%sort(jj))
                   end if
                   f%indsort(jj)=jj
                   f%desc250(jj)=model_getdesc250(jj,f,v,crc250,irc)
                end if
             end do
             if(mod_bdeb)write(*,*)myname,' Sorting.'
             f%tsort=f%nsort
             call sort_heapsort1r(f%nsort,f%sort,1.0D-5,&
                  & f%tsort,f%nsort,f%indsort,.false.)
             if(mod_bdeb)write(*,*)myname,' Sorting done.'
             f%ind_lim=.true. ! target is available
             f%ind_start=f%sort(f%indsort(1))
             f%ind_stop=f%sort(f%indsort(f%nsort))
             f%trg=f%ind_start
          else
             irc=453
             call model_errorappend(crc250,myname)
             call model_errorappend(crc250," Invalid "//v%var80(1:v%lenv)//" dimensions.")
             call model_errorappendi(crc250,f%nsort)
             call model_errorappend(crc250,"\n")
             call model_errorappendi(crc250,irc)
             call model_errorappend(crc250,"\n")
             return
          end if
       else
          if(mod_bdeb)write(*,*)myname,'Unable to find sort variable: "',&
               & css%ind_var(1:css%ind_lenv),'"'
       end if
    end if
  end subroutine model_readSortVariable
  !
  ! close file
  !
  subroutine model_closeFile(css,f,crc250,irc)
    type(mod_session), pointer :: css !  current session
    type(mod_file),pointer :: f
    character*250 :: crc250
    integer :: irc,ret
    character*25 :: myname="model_closeFile"
    ret=NF_CLOSE(f%ncid)        ! end definitions: leave define mode
    if (ret .ne. NF_NOERR) then
       irc=170
       call model_errorappend(crc250,myname)
       call model_errorappend(crc250," Unable to close "//&
               & f%fn250(1:f%lenf)//" "//nf_strerror(ret))
       call model_errorappendi(crc250,irc)
       call model_errorappend(crc250,"\n")
       return
    end if
    return
  end subroutine model_closeFile
  !
  subroutine model_resetStat(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    integer :: ii
    type(mod_file), pointer :: cfile
    character*22 :: myname="model_resetStat"
    if (mod_bdeb) write(*,*)myname,'Entering.',irc
    do ii=1,10
       css%fok(ii)=0
       css%frm(ii)=0
    end do
    if (associated(css%firstFile)) then
       cfile => css%firstFile%next
       do while (.not.associated(cfile,target=css%lastFile))
          ! update statistics
          do ii=1,10
             cfile%ook(ii)=0
             cfile%orm(ii)=0
          end do
          cfile  => cfile%next
       end do
    end if
    ! if (mod_bdeb) write(*,*)myname,'Targets.',css%ntrg
    if (associated(css%trg_ook).and.associated(css%trg_orm)) then
       do ii=0,css%ntrg
          css%trg_orm(ii)=0
          css%trg_ook(ii)=0
          css%trg_frm(ii)=0
          css%trg_fok(ii)=0
       end do
    end if
    if (mod_bdeb) write(*,*)myname,'Done.',irc
    return
  end subroutine model_resetStat
  !
  subroutine model_printFStat(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    integer :: ii
    real :: pst(10),pp
    type(mod_file), pointer :: cfile
    character*22 :: myname="model_printFStat"
    ! accumulate file statistics...
    ! file statistics
    do ii=1,10
       pst(ii)=dfloat(css%frm(ii))/max(1.0d0,dfloat(css%frm(ii)+css%fok(ii)))*100
    end do
    WRITE(*,*)
    WRITE(*,998) MYNAME,                     'Model files:               ', css%fok(1)+css%frm(1)
    IF (CSS%FRM(1).NE.0) WRITE(*,999) MYNAME,'Out of index filter range: ', -CSS%FRM(1),PST(1)
    IF (CSS%FRM(2).NE.0) WRITE(*,999) MYNAME,'Model index filter:        ', -CSS%FRM(2),PST(2)
    do ii=1,css%ntrg
       pp=dfloat(css%trg_frm(ii))/max(1.0d0,dfloat(css%trg_frm(0)+css%trg_fok(0)))*100
       IF (css%trg_frm(ii).NE.0) WRITE(*,996) MYNAME,"'"//css%trg80(ii)(1:css%trg_lent(ii))//"' filter:", &
            & -css%trg_frm(ii),PP
    end do
    WRITE(*,997) MYNAME,     '--------------------------------------------------'
    pp=dfloat(css%fok(3))/max(1.0d0,dfloat(css%frm(1)+css%fok(1)))*100
    WRITE(*,999) MYNAME,                     'Accepted model files:      ', css%fok(3),pp
    !
999 FORMAT(X,A12,X,A,I13,' (',F6.2,'%)')
998 FORMAT(X,A12,X,A,I13)
997 FORMAT(X,A12,X,A)
996 FORMAT(X,A12,X,A30,I13,' (',F6.2,'%)')
  
    return
  end subroutine model_printFStat
  !
  subroutine model_printLStat(css,crc250,irc)
    type(mod_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    integer :: ii
    integer :: ook(10),orm(10)
    real :: pst(10),pp
    type(mod_file), pointer :: cfile
    character*22 :: myname="model_printStatistics"
    ! accumulate file statistics...
    do ii=1,10
       ook(ii)=0
       orm(ii)=0
    end do
    if (associated(css%firstFile)) then
       cfile => css%firstFile%next
       do while (.not.associated(cfile,target=css%lastFile))
          ! update statistics
          do ii=1,10
             ook(ii)=ook(ii)+cfile%ook(ii)
             orm(ii)=orm(ii)+cfile%orm(ii)
          end do
          cfile  => cfile%next
       end do
    end if
    ! target statistics
    if (css%trg_orm(0).ne.0) then
       WRITE(*,*)
       WRITE(*,998) MYNAME,                 'Target filter checks:        ', css%trg_orm(0)+css%trg_ook(0)
       do ii=1,css%ntrg
          pp=dfloat(css%trg_orm(ii))/max(1.0d0,dfloat(css%trg_orm(0)+css%trg_ook(0)))*100
          IF (css%trg_orm(ii).NE.0) WRITE(*,996) MYNAME,"'"//css%trg80(ii)(1:css%trg_lent(ii))//"'-filter:", &
               & -css%trg_orm(ii),PP
       end do
       WRITE(*,997) MYNAME,     '-----------------------------------------------------'
       pp=dfloat(css%trg_ook(0))/max(1.0d0,dfloat(css%trg_orm(0)+css%trg_ook(0)))*100
       WRITE(*,999) MYNAME,                 'Accepted target filter checks:',css%trg_ook(0),pp
    end if
    ! location statistics
    do ii=1,10
       pst(ii)=dfloat(orm(ii))/max(1.0d0,dfloat(orm(ii)+ook(ii)))*100
    end do
    WRITE(*,*)
    WRITE(*,998) MYNAME,                 'Locations:                 ', ook(1)+orm(1)
    IF (ORM(1).NE.0) WRITE(*,999) MYNAME,'Failed to qualify:         ', -ORM(1),PST(1)
    IF (ORM(2).NE.0) WRITE(*,999) MYNAME,'Target filter rejection:   ', -ORM(2),PST(2)
    IF (ORM(3).NE.0) WRITE(*,999) MYNAME,'Missing model data:        ', -ORM(3),PST(3)
    IF (ORM(4).NE.0) WRITE(*,999) MYNAME,'Model filter rejection:    ', -ORM(4),PST(4)
    WRITE(*,997) MYNAME,     '--------------------------------------------------'
    pp=dfloat(ook(4))/max(1.0d0,dfloat(orm(1)+ook(1)))*100
    WRITE(*,999) MYNAME,                 'Accepted locations:        ', ook(4),pp
    !
999 FORMAT(X,A12,X,A,I13,' (',F6.2,'%)')
998 FORMAT(X,A12,X,A,I13)
997 FORMAT(X,A12,X,A)
996 FORMAT(X,A12,X,A30,I13,' (',F6.2,'%)')
  
    return
  end subroutine model_printLStat
  !
  !###############################################################################
  ! ERROR ROUTINES
  !###############################################################################
  !
  subroutine model_errorappend(crc250,string)
    implicit none
    character*250 :: crc250
    character*(*) :: string
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    lenb=len(trim(string))
    buff250=string(1:lenb)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//" "//buff250(1:min(250-lenc-1,lenb))
    end if
    call chop0(crc250,250)
  end subroutine model_errorappend
  subroutine model_errorappendi(crc250,inum)
    implicit none
    character*250 :: crc250
    integer :: inum
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    write(buff250,'(I12)')inum
    call chop0(buff250,250)
    lenb=length(buff250,250,1)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//" "//buff250(1:min(250-lenc-1,lenb))
    end if
    call chop0(crc250,250)
  end subroutine model_errorappendi
  !
  subroutine model_errorappendi8(crc250,inum)
    implicit none
    character*250 :: crc250
    integer*8 :: inum
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    write(buff250,'(I12)')inum
    call chop0(buff250,250)
    lenb=length(buff250,250,1)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//" "//buff250(1:min(250-lenc-1,lenb))
    end if
    call chop0(crc250,250)
  end subroutine model_errorappendi8

  character*250 function model_diff(dt)
    real :: dt
    character*250 :: buff250
    character*25 :: siff25
    integer, external :: length
    integer :: lenb,lens
    integer :: dd
    integer :: hh
    integer :: mi
    integer :: ss
    lenb=0
    call chop0(buff250,250)
    ss=nint(dt*86400.0D0)
    if (ss.gt.86400) then
       if (lenb.gt.0) then
          buff250=buff250(1:lenb)//" "
          lenb=lenb+1
       end if
       dd=int(ss/86400)
       ss=ss-dd*86400
       write(siff25,*)dd
       call chop0(siff25,25)
       lens=length(siff25,25,5)
       buff250=buff250(1:lenb)//siff25(1:lens)//"d"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end if
    if (ss.gt.3600) then
       if (lenb.gt.0) then
          buff250=buff250(1:lenb)//" "
          lenb=lenb+1
       end if
       hh=int(ss/3600)
       ss=ss-hh*3600
       write(siff25,*)hh
       call chop0(siff25,25)
       lens=length(siff25,25,5)
       buff250=buff250(1:lenb)//siff25(1:lens)//"h"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end if
    if (ss.gt.60) then
       if (lenb.gt.0) then
          buff250=buff250(1:lenb)//" "
          lenb=lenb+1
       end if
       mi=int(ss/60)
       ss=ss-mi*60
       write(siff25,*)mi
       call chop0(siff25,25)
       lens=length(siff25,25,5)
       buff250=buff250(1:lenb)//siff25(1:lens)//"m"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end if
    if (ss.gt.0) then
       if (lenb.gt.0) then
          buff250=buff250(1:lenb)//" "
          lenb=lenb+1
       end if
       write(siff25,*)ss
       call chop0(siff25,25)
       lens=length(siff25,25,5)
       buff250=buff250(1:lenb)//siff25(1:lens)//"s"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end if
    model_diff=buff250
    return
  end function model_diff
  !
  !###############################################################################
  ! STRING ROUTINES
  !###############################################################################
  !
  subroutine findDelimiter(string,del,pos)
    character(len=*) :: string
    character*1 :: del
    integer :: pos
    logical :: bdone
    integer :: lens
    lens=len(trim(string))
    pos=pos+1
    bdone=(pos.gt.lens)
    do while (.not.bdone)
       if (string(pos:pos).eq.del) then
          bdone=.true.
       else
          pos=pos+1
          bdone=(pos.gt.lens)
       end if
    end do
  end subroutine findDelimiter

  subroutine decode(string)
    character*(*) :: string
    string=replaceText(string,"%1%"," ")
    return
  end subroutine decode
  !
  subroutine encode(string)
    character*(*) :: string
    string=replaceText(string," ","%1%")
    return
  end subroutine encode
  !
  FUNCTION ReplaceText (s,text,rep)  RESULT(outs)
    CHARACTER(*)        :: s,text,rep
    CHARACTER(LEN(s)+100) :: outs     ! provide outs with extra 100 char len
    INTEGER             :: i, mi, nt, nr, ns, ms
    outs = "";
    outs(1:len_trim(s))=trim(s) ;
    nt = LEN(text) ;
    nr = LEN(rep) ;
    ns = len_trim(s) ;
    ms = len(s)+100;
    !write(*,*) "S:"//trim(s)//":",ns,":"//trim(outs)//":",nt,nr
    mi=0
    DO
       i = mi+INDEX(outs(mi+1:ns),text(:nt)) ;
       IF (i <= mi) EXIT
       !write(*,*) "Outs:"//outs(:i-1)//"|"//outs(i:i+nt-1)//":",&
       !     & i-1,":"//rep(:nr)//":",nr,":",i+nt,ns-nr-i+1,(i+nt)-(ns-nr-i+1)+1
       if (ns+nr-nt <= ms) then
          outs(1:ns+nr-nt) = outs(:i-1) // rep(:nr) // outs(i+nt:ns)
          ns=ns+nr-nt
          mi=i-1+nr;
       else ! not enough space in string
          EXIT
       end if
    END DO
  END FUNCTION ReplaceText
  !
end module model
#__file: 'libmod/mod_loadCache.F90' 0100644    **DO NOT DELETE**
subroutine mod_loadCache(sid, path, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*250 :: path
  character*250 :: crc250
  integer :: irc
  character*250 :: buff250
  integer :: lenc
  character*25 :: myname = "mod_loadCache"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc,sid,path
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_loadcache(css,path,crc250,irc)
  if (irc.ne.0) then
     !write(*,*) 'pushFile Error.'
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_loadcache.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.',irc,sid
  return
end subroutine mod_loadCache
#__file: 'libmod/mod_makeCache.F90' 0100644    **DO NOT DELETE**
subroutine mod_makeCache(sid, path, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*250 :: path
  character*250 :: crc250
  integer :: irc
  character*250 :: buff250
  integer :: lenc
  character*25 :: myname = "mod_makeCache"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc,sid,path
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_makecache(css,path,crc250,irc)
  if (irc.ne.0) then
     !write(*,*) 'pushFile Error.'
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_makecache.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.',irc,sid
  return
end subroutine mod_makeCache
#__file: 'libmod/mod_openSession.F90' 0100644    **DO NOT DELETE**
subroutine mod_opensession(sid, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "determinefileorder"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call model_opensession(sid,css,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_openSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.'
  return
end subroutine mod_opensession
#__file: 'libmod/mod_peekFile.F90' 0100644    **DO NOT DELETE**
subroutine mod_peekfile(sid, maxrep, nrep, rep250, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  integer :: maxrep
  integer :: nrep
  character*250 :: rep250(maxrep)
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "peekFile"
  type(mod_session), pointer :: css !  current session
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_peek(css,maxrep,nrep,rep250,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_stackpeek.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  return
end subroutine mod_peekfile
#__file: 'libmod/mod_peekFileLen.F90' 0100644    **DO NOT DELETE**
subroutine mod_peekfilelen(sid, maxrep, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  integer :: maxrep
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "peekFileLen"
  type(mod_session), pointer :: css !  current session
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_peeklen(css,maxrep,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_stackpeeklen.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  return
end subroutine mod_peekfilelen
#__file: 'libmod/mod_popFile.F90' 0100644    **DO NOT DELETE**
subroutine mod_popfile(sid,path250,crc250,irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*250 :: path250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "popFile"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_popfile(css,path250,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_stackpop.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.'
  return
end subroutine mod_popfile
#__file: 'libmod/mod_pushFile.F90' 0100644    **DO NOT DELETE**
subroutine mod_pushfile(sid, path, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*250 :: path
  character*250 :: crc250
  integer :: irc
  character*250 :: buff250
  integer :: lenc
  character*25 :: myname = "pushFile"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc,sid,path
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_pushfile(css,path,crc250,irc)
  if (irc.ne.0) then
     !write(*,*) 'pushFile Error.'
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_stackpush.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.'
  return
end subroutine mod_pushfile
#__file: 'libmod/mod_pushTarget.F90' 0100644    **DO NOT DELETE**
subroutine mod_pushtarget(sid, t80, v80, l80, u80, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*80 :: t80        ! target name
  character*80 :: v80        ! variable
  character*80 :: l80        ! lower value
  character*80 :: u80        ! upper value
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "pushtarget"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid,varname
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_pushtarget(css,t80,v80,l80,u80,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_stackclear.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine mod_pushtarget
#__file: 'libmod/mod_setFilter.F90' 0100644    **DO NOT DELETE**
subroutine mod_setfilter(sid,flt,crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character*(*) :: flt
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setfilter"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,filter250,
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_setfilter(css,flt,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from col_setobscache.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine mod_setfilter
#__file: 'libmod/mod_setIndex.F90' 0100644    **DO NOT DELETE**
subroutine mod_setIndex(sid, trgname,varname, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character(len=*) :: trgname
  character(len=*) :: varname
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setindex"
  type(mod_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_setindex(css,trgname,varname, crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_setindex.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine mod_setIndex
#__file: 'libmod/mod_setIndexLimits.F90' 0100644    **DO NOT DELETE**
!void mod_setindexlimits_(int* sid, char* min80, char* max80, char* crc250, int* irc, int len1);
subroutine mod_setIndexlimits(sid, smin, smax, crc250, irc)
  use model
  implicit none
  integer :: sid             ! session id
  character(LEN=*) :: smin,smax
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "mod_setindexlimits"
  type(mod_session), pointer :: css !  current session
  if(mod_bdeb)write(*,*) myname, 'Entering.',irc,sid
  call model_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from getSession.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  call model_setindexlimits(css, smin, smax, crc250,irc)
  if (irc.ne.0) then
     call model_errorappend(crc250,myname)
     call model_errorappend(crc250," Error return from model_setindexlimits.")
     call model_errorappendi(crc250,irc)
     call model_errorappend(crc250,"\n")
     return
  end if
  if(mod_bdeb)write(*,*) myname,' Done.'
  return
end subroutine mod_setIndexlimits
#__file: 'libobs/obs_clearFileStack.F90' 0100644    **DO NOT DELETE**
subroutine obs_clearfilestack(sid, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearFileStack"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid,varname
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_stackclear(css,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_stackclear.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_clearfilestack
#__file: 'libobs/obs_clearTargetStack.F90' 0100644    **DO NOT DELETE**
subroutine obs_clearTargetStack(sid, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "obs_clearTarget"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_clearTargetStack(css,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_clearTarget.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_clearTargetStack
#__file: 'libobs/obs_closeSession.F90' 0100644    **DO NOT DELETE**
subroutine obs_closesession(sid, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "obs_closesession"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_closesession(css,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_closeSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.'
  return
end subroutine obs_closeSession
#__file: 'libobs/observations.F90' 0100644    **DO NOT DELETE**
!
!"*********************************************************************************************"
!"***This software is ONLY permitted used by staff at the Norwegian Meteorological Institute***"
!"*********************************************************************************************"
!
module observations
  use parse
  IMPLICIT NONE
  !
  ! Global constants
  !
  CHARACTER(LEN=50)               :: blank50 = ''
  character*1 :: sep = "|"
  logical                         :: obs_bdeb=.false.
  !
  ! bufrdc PARAMETERS
  integer,parameter :: JSUP   =       9
  integer,parameter :: JSEC0  =       3
  integer,parameter :: JSEC1  =      80
  integer,parameter :: JSEC2  =    4096
  integer,parameter :: JSEC3  =       4
  integer,parameter :: JSEC4  =       2
  integer,parameter :: JELEM  =  320000
  integer,parameter :: JBUFL  =  512000
#ifdef JBPW_64
  integer,parameter :: JBPW   =      64
#else
  integer,parameter :: JBPW   =      32
#endif
  integer,parameter :: JTAB   =    3000
  integer,parameter :: JCTAB  =    3000
  integer,parameter :: JCTST  =    9000
  integer,parameter :: JCTEXT =    9000
  integer,parameter :: JKEY   =      46 
  integer,parameter :: JTMAX  =      10
  integer,parameter :: JTCLAS =      64
  integer,parameter :: JTEL   =     255
  integer,parameter :: KELEM  =   400000
  integer,parameter :: KVALS  = 4096000
  !
  integer :: nsubset=0           ! number of subsets in file
  integer :: isubset=0           ! current subset
  integer :: nitem = 0           ! number of items in a subset
  integer :: irep=0
  integer :: NBYTPW
  integer :: kbufl
  integer :: ktdlen
  integer :: KEL
  integer :: ktdexl
  integer,parameter :: ktdexl_max=250
  integer :: KBUFF(JBUFL)
  integer :: KSUP(JSUP)
  integer :: KSEC0(JSEC0)
  integer :: KSEC1(JSEC1)
  integer :: KSEC2(JSEC2)
  integer :: KSEC3(JSEC3)
  integer :: KSEC4(JSEC4)
  integer :: KEY(JKEY)
  REAL*8 :: VALUES(KVALS)
  integer :: KTDLST(JELEM)
  integer :: KTDEXP(0:JELEM)
  CHARACTER*64 ::CNAMES(KELEM)
  CHARACTER*24 ::CUNITS(KELEM)
  CHARACTER*80 ::CVALS(KELEM)
  REAL*8 :: RVIND=1.7D38
  integer :: nvind=2147483647
  integer*8 :: unit
  logical :: fopen=.false. ! is file open
  logical :: bread=.false.
  !
  ! category used for counting observations categories in file
  !
  type :: obs_subCategory
     integer :: subcategory = 0
     integer :: cnt = 0
     integer :: ktdexl = 0
     integer, allocatable :: ktdexp(:)
     character*64, allocatable :: cnames(:)
     character*24, allocatable :: cunits(:)
     real*8, allocatable :: values(:)
     type(obs_subCategory), pointer :: prev
     type(obs_subCategory), pointer :: next
  end type obs_subCategory
  !
  type :: obs_mainCategory
     integer :: category = 0
     integer :: cnt = 0
     type(obs_subCategory) :: firstSubCategory
     type(obs_subCategory) :: lastSubCategory
     integer :: nsub=0
     type(obs_mainCategory), pointer :: prev
     type(obs_mainCategory), pointer :: next
  end type obs_mainCategory
  !
  !
  type :: obs_message
     integer :: nobs=0 ! number of observations
     integer :: vobs=0 ! number of valid observations
     integer :: iobs=0  ! current observation
     logical :: check=.false. ! has message check been performed yet...
     !
     integer :: ctrg = 0 ! number of allocated targets
     integer :: cobs = 0 ! number of allocated observations
     real, allocatable :: trg_val(:,:)   ! target values
     logical, allocatable :: trg_vok(:,:)   ! target values ok?
     logical, allocatable :: trg_set(:)  ! did observation pass message check?
     real, allocatable :: trg_res(:)     ! filter values
  end type obs_message
  !
  ! BUFR FILE STACK
  !
  type :: obs_file
     character*250  :: fn250 = ""          ! file name
     integer        :: lenf=0              ! length of file name string
     character*250  :: tablepath = ""      ! table path
     real           :: ind_start=0.0D0     ! lowest index value in file
     real           :: ind_stop=0.0D0      ! highest index value in file
     logical        :: ind_lim = .false.   ! are ind_start/ind_stop available
     real           :: time_start=0.0D0    ! lowest index value in file
     real           :: time_stop=0.0D0     ! highest index value in file
     logical        :: time_lim = .false.  ! are ind_start/ind_stop available
     integer        :: nmessage=0          ! number of BUFR messages in file
     integer        :: nsubset=0           ! total number of subsets in file
     integer        :: nitem = 0           ! total number of items in file
     type(obs_mainCategory) :: firstCategory
     type(obs_mainCategory) :: lastCategory
     integer :: ncat=0
     integer :: nsub=0
     integer :: mok(10),mrm(10),ook(10),orm(10),lenh(10)
     character*80 :: hint80(10)
     type(obs_file), pointer :: prev => null() ! linked list
     type(obs_file), pointer :: next => null() ! linked list
  end type obs_file
  !
  type :: obs_filePointer
     type(obs_file), pointer :: ptr => null()
  end type obs_filePointer
  !
  ! Target item
  !   
  type :: obs_target
     character*80 :: trg80      ! target name
     character*250 :: pos250    ! position/sequence number
     integer :: type            ! empty, constant, variable, expression
     integer :: ind             ! index to internal variable (0=none)
     character*80 :: descr80    ! descriptor
     character*250 :: info250   ! information
     character*80 :: min80      ! min value
     character*80 :: max80      ! max value
     type(obs_target), pointer :: prev => null()   ! linked list
     type(obs_target), pointer :: next => null()   ! linked list
  end type obs_target
  !
  type :: obs_targetPointer
     type(obs_target), pointer :: ptr => null()
  end type obs_targetPointer
  !
  ! Location item
  !   
  type :: obs_location
     integer :: locid
     integer :: iloc
     integer :: ntrg ! number of targets
     real, allocatable :: trg_val(:) ! target value
     logical, allocatable :: trg_vok(:) ! target value ok
     integer :: search = 0     ! is grid search successful, 0=ok?
     logical :: bok = .true.
     type(obs_location), pointer :: prev => null()   ! linked list
     type(obs_location), pointer :: next => null()   ! linked list
  end type obs_location
  !
  type :: obs_locPointer
     type(obs_location), pointer :: ptr => null()
  end type obs_locPointer
  !
  ! report
  !
  type :: obs_reportItem
     character*250 :: desc250 ! description
     type(obs_reportItem), pointer :: prev => null()   ! linked list
     type(obs_reportItem), pointer :: next => null()   ! linked list
  end type obs_reportItem
  !
  type :: obs_report
     type(obs_reportItem), pointer :: firstItem => null()    ! linked list start
     type(obs_reportItem), pointer :: lastItem => null()     ! linked list end
     type(obs_reportItem), pointer :: currentItem => null()  ! current pointer
     integer :: nitem = 0                           ! number of items
     type(obs_report), pointer :: prev => null()   ! linked list
     type(obs_report), pointer :: next => null()   ! linked list
  end type obs_report
  !
  ! BUFR arrays:::  WARNING: WILL PROBABLY USE ALMOST ALL OF YOUR COMPUTER MEMORY!!!!
  !
  ! SESSION VARIABLES
  !
  type :: obs_session
     integer                         :: sid
     CHARACTER(LEN=250)              :: fn250
     CHARACTER(LEN=250)              :: tablepath=""
     !
     ! STACK
     !
     type(obs_file), pointer :: firstFile => null()   ! linked list start
     type(obs_file), pointer :: lastFile => null()    ! linked list end
     type(obs_file), pointer :: currentFile => null()
     type(obs_file), pointer :: nextFile => null()
     type(obs_filePointer), pointer   :: fileStack(:) => null() ! array of the stack elements
     real, allocatable            :: fileStackSort(:,:)
     integer, allocatable         :: fileStackInd(:,:)
     integer :: nFileIndexes = 0              ! total number of files on the stack
     integer :: nFileSortIndexes = 0          ! number of file indexes on the stack
     integer :: newnFileSortIndexes(2)        ! new number of file indexes on the stack
     integer :: currentFileSortIndex = 0      ! current stack index element
     integer :: currentFileIndex = 0          ! current stack element
     logical :: stackReady =.false.           ! are sorted data ready for use?
     integer :: leftFileSortIndex=0           ! ref fileStackSort(*,2) - maxvalues
     integer :: rightFileSortIndex=0          ! ref fileStackSort(*,1) - minvalues
     logical :: sortLimitsOk  = .false.
     integer :: fopened  = 0                 ! number of overlapping observation files
     integer :: fok(10), frm(10)
     !
     !
     ! data selection
     !
     real                            :: ind_minval=0.0D0      ! lowest index
     real                            :: ind_maxval=0.0D0      ! highest index
     logical                         :: ind_lval(2) = .false. ! are ind_minval/ind_maxval available
     !
     character*80                    :: ind_trg80=""          ! index target name
     integer                         :: ind_lent              ! length of target name
     character*250                   :: ind_exp250=""         ! index target expression
     integer                         :: ind_lene              ! length of target expression
     real                            :: ind_val=0.0D0         ! index value (=trg_val(ntrg))
     logical                         :: ind_eset = .false.    ! is index expression set
     type(parse_session), pointer    :: ind_pe => null()      ! index expression
     logical                         :: ind_tset = .false.    ! is index tranformation set
     type(parse_session), pointer    :: ind_pt => null()      ! index transformation
     !
     ! TARGET
     !
     type(obs_target), pointer        :: firsttarget => null()   ! linked list start
     type(obs_target), pointer        :: lasttarget => null()    ! linked list end
     type(obs_target), pointer        :: ctarget => null()    ! linked list end
     integer :: ntarget=0                  ! number of targets
     integer :: ntrg=0                     ! number of targets including index_target
     integer :: category                   ! filter category/bufrType
     integer :: subCategory                ! filter subcategory/subType
     !
     character*80, allocatable       :: trg80(:)        ! target name
     integer, allocatable            :: trg_lent(:)     ! target name length
     character*250, allocatable      :: trg_pos250(:)   ! target position
     integer, allocatable            :: trg_lenp(:)     ! target position length
     !  position can be empty,constant,variable or expression
     integer, allocatable            :: trg_type(:)     ! type of sequence
     integer, allocatable            :: trg_seq(:)      ! constant
     integer, allocatable            :: trg_ind(:)      ! index to internal variable
     type(parse_pointer), pointer    :: trg_psp(:) => null() ! expression parser
     integer, allocatable            :: trg_descr(:)    ! descriptor
     logical, allocatable            :: trg_lval(:,:)   ! above/below/between limits?
     real, allocatable               :: trg_minval(:)
     real, allocatable               :: trg_maxval(:)
     integer, allocatable            :: trg_ook(:)
     integer, allocatable            :: trg_orm(:)
     logical,allocatable             :: trg_req(:)      ! is target required?
     REAL,allocatable                :: trg_val(:)      ! target variable values
     logical,allocatable             :: trg_vok(:)      ! is target valid?
     type(obs_targetPointer), pointer:: trg_ptr(:)=> null()
     logical                         :: trg_set=.false. ! is target list set?
     ! message -> location ratios     
     integer :: omin,omax,osum,ocnt
     integer :: lmin,lmax,lsum,lcnt
     logical :: keepstat=.false.
     !
     ! index to duplication targets (targets that cause observation duplication)
     !
     integer :: ndup=0                    ! number of duplication targets
     integer, allocatable :: dup_ind(:)   ! duplication index
     integer, allocatable :: dup_inc(:)   ! duplication index
     !
     ! dynamic position/sequence variables
     integer                         :: ndyn = 0        ! number of dynamic variables
     CHARACTER (LEN=80), allocatable :: dyn_var(:)      ! dynamic variable name
     integer,            allocatable :: dyn_lenv(:)     ! dynamic variable name length
     !     REAL(rn),           allocatable :: dyn_val(:)      ! dynamic variable values
     REAL,               allocatable :: dyn_val(:)      ! dynamic variable values
     integer                         :: dyn_pos=0       ! dynamic search position
     integer                         :: dyn_max=0       ! dynamic max count
     integer                         :: dyn_cnt=0       ! dynamic count position
     logical                         :: dyn_set=.false. ! is dynamic list set?
     logical                         :: dyn_bok=.false. ! is duplicate observation valid
     !
     ! internal variables...
     integer                         :: nint = 0        ! number of internal variables
     CHARACTER (LEN=80), allocatable :: int_var(:)      ! internal variable name
     integer,            allocatable :: int_lenv(:)     ! internal variable name length
     !REAL(rn),           allocatable :: int_val(:)      ! internal variable values
     REAL,               allocatable :: int_val(:)      ! internal variable values
     !
     ! locations
     type(obs_location), pointer :: firstLoc => null()   ! linked list start
     type(obs_location), pointer :: lastLoc => null()    ! linked list end
     integer :: nloc=0                                   ! number of items in location-chain
     integer :: locoffset = 0                            ! offset between locid and position in locdata
     type(obs_locPointer), allocatable :: locData(:)     !  data locations
     logical :: locReady = .false.
     !
     character*80, allocatable :: var(:)
     real, allocatable :: val(:)
     integer,dimension(8) :: values
     !
     ! report label flags
     !
     logical :: ignmis=.false.
     logical :: ignuni=.false.
     logical :: ignden=.false.
     logical :: ignder=.false.
     logical :: ignval=.false.
     logical :: ignsec=.false.
     logical :: ignarr=.false.
     logical :: igncat=.false.
     !
     type(parse_session), pointer :: psf => null()
     logical ::  flt_set=.false.
     character*250 :: flt250
     integer :: lenf=0
     type(obs_message), pointer :: msg => null()
     !
     ! REPORTS
     !
     type(obs_report), pointer :: firstReport => null()    ! linked list start
     type(obs_report), pointer :: lastReport => null()     ! linked list end
     type(obs_report), pointer :: currentReport => null()  ! current pointer
     type(obs_report), pointer :: nextReport => null()  ! current pointer
     integer :: nsubset=0               ! number of reports
     logical :: reportsReady=.false.    ! are reported data ready for use
     !
     ! output identification...
     !integer :: fid = 0 ! file id (index number)
     !integer :: mid = 0 ! message id in file
     !integer :: oid = 0 ! observation id in file
     !integer :: lid = 0 ! location id in file
     !
     type(obs_session), pointer :: prev => null()         ! linked list
     type(obs_session), pointer :: next => null()         ! linked list
  end type obs_session

  type :: obs_table
     integer :: code
     integer :: maxnn = 0
     integer, allocatable :: subcodes(:)
     character*250, allocatable :: values(:)
     integer :: nn = 0
     integer, allocatable :: index(:)
  end type obs_table
  !
  type :: obs_codeTable
     integer :: maxnn = 0
     integer, allocatable :: codes(:)
     type(obs_table), allocatable :: tables(:)
     integer :: nn = 0
     integer, allocatable :: index(:)
  end type obs_codeTable
  !
  character*250 :: c250 = ""
  type(obs_codeTable), target :: ctable
  logical :: ctableInit=.false.
  !
  integer :: maxid=0 ! session counter
  type(obs_session), pointer :: firstSession => null()   ! linked list start
  type(obs_session), pointer :: lastSession => null()    ! linked list end
  !
CONTAINS
  !
  !###############################################################################
  ! SESSION ROUTINES
  !###############################################################################
  !
  subroutine observation_opensession(sid,css,crc250,irc)
    integer :: sid
    character*250 :: crc250
    integer :: irc
    type(obs_session),pointer :: css !  new session
    character*22 :: myname="observation_opensession"
    !write(*,*)myname,'Entering.'
    if (.not.associated(firstSession)) then
       allocate(firstSession, lastSession,stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250,"Unable to allocate 'firstSession/lastSession'.")
          call observation_errorappend(crc250,"\n")
          return
       end if
       firstSession%next => lastSession
       lastSession%prev => firstSession
       !
    end if
    nullify(css)
    allocate(css,stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Unable to allocate 'new session'.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    !
    !call date_and_time(VALUES=css%values) ! get current date
    call parse_date_and_time(VALUES=css%values) ! get current date
    if (allocated(css%var)) deallocate (css%var)
    if (allocated(css%val)) deallocate (css%val)
    allocate(css%var(2),css%val(2),stat=irc)
    css%var(1)="now"
    css%var(2)="midnight"
    css%val(1)=parse_f1970(&
         & real(css%values(1)),real(css%values(2)),&
         & real(css%values(3)),real(css%values(5)),&
         & real(css%values(6)),real(css%values(7)))
    css%val(2)=parse_f1970(&
         & real(css%values(1)),real(css%values(2)),&
         & real(css%values(3)),0.0D0,&
         & 0.0D0,0.0D0) ! midnight
    !
    maxid=maxid+1
    css%sid=maxid
    css%prev => lastSession%prev
    css%next => lastSession
    css%prev%next => css
    css%next%prev => css
    sid = css%sid
    ! stack
    allocate(css%firstFile,css%lastFile, stat=irc) ! 
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Unable to allocate &
            & 'css%firstFile/css%lastFile'.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    css%firstFile%next => css%lastFile
    css%lastFile%prev => css%firstFile
    ! internal variables
    css%nint=5
    if (allocated(css%int_var)) deallocate(css%int_var)
    if (allocated(css%int_lenv)) deallocate(css%int_lenv)
    if (allocated(css%int_val)) deallocate(css%int_val)
    allocate(css%int_var(css%nint),css%int_lenv(css%nint),&
         & css%int_val(css%nint),stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Unable to allocate internal variables.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    !
    css%int_var(1)="mid" ! model file id
    css%int_var(2)="oid" ! observation file id
    css%int_var(3)="bid" ! message id 
    css%int_var(4)="sid" ! obs id
    css%int_var(5)="lid" ! location id
    !
    css%int_val(1)=0 ! model file id
    css%int_val(2)=0 ! observation file id
    css%int_val(3)=0 ! message id (for each file)
    css%int_val(4)=0 ! obs id (for each message)
    css%int_val(5)=0 ! location id (for each message)
    ! reports
    allocate(css%firstReport,css%lastReport,stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Unable to allocate first/lastReport.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    css%firstReport%next => css%lastReport
    css%lastReport%prev => css%firstReport
    css%nsubset = 0
    ! targets
    call observation_targetinit(css,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from observation_targetInit.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    !
    allocate(css%msg)
    !
    !write(*,*)myname,' Done.'
    return
  end subroutine observation_opensession

  subroutine observation_getSession(css,sid,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: sid
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_getSession"
    !if(obs_bdeb)write(*,*)myname,' Entering.',irc,sid
    if (.not.associated(firstSession)) then
       irc=911
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"No session is opened!")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    css => firstSession%next
    do while ( .not.associated(css,target=lastSession))
       if (css%sid .eq. sid) then
          !if (obs_bdeb) write(*,*)myname,'Exiting with sid:',sid,irc
          return
       end if
       css=>css%next
    end do
    nullify(css)
    irc=342
    call observation_errorappend(crc250,myname)
    call observation_errorappend(crc250,"Invalid session id:")
    call observation_errorappendi(crc250,sid)
    call observation_errorappend(crc250,"\n")
    if(obs_bdeb)write(*,*)myname,'Error.',irc,sid
    return
  end subroutine observation_getSession

  subroutine observation_closeSession(css,crc250,irc)
    character*250 :: crc250
    integer :: irc
    type(obs_session), pointer :: css !  current session
    integer :: ii
    character*22 :: myname="observation_closeSession"
    if(obs_bdeb)write(*,*)myname,'Entering.',irc
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       !
       if (allocated(css%var)) deallocate (css%var)
       if (allocated(css%val)) deallocate (css%val)
       if (allocated(css%dup_ind)) deallocate(css%dup_ind)
       if (allocated(css%dup_inc)) deallocate(css%dup_inc)
       ! remove reportdata
       call observation_clearReports(css,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_clearReports.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       deallocate(css%firstReport,css%lastReport,stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Unable to deallocate first/lastreport.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       ! remove file-stack
       if (associated(css%filestack)) then
          do ii=1,size(css%filestack)
             if (associated(css%filestack(ii)%ptr)) then
                nullify(css%filestack(ii)%ptr)
             end if
          end do
          deallocate(css%filestack)
       end if
       !
       do ii=1,css%ntrg
          call parse_close(css%trg_psp(ii)%ptr,crc250,irc)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from parse_close.")
             return
          end if
       end do
          
       if (allocated(css%filestacksort)) deallocate(css%filestacksort)
       if (allocated(css%filestackind)) deallocate(css%filestackind)
       call observation_removeFiles(css,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from removeFiles.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       deallocate(css%firstFile,css%lastFile)
       ! clear target 
       call observation_removeTarget(css,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_removeTarget.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       ! internal variables
       css%nint=0
       if (allocated(css%int_var)) deallocate(css%int_var)
       if (allocated(css%int_lenv)) deallocate(css%int_lenv)
       if (allocated(css%int_val)) deallocate(css%int_val)
       ! deallocate observation filter...
       if (css%lenf.ne.0) then
          call parse_close(css%psf,crc250,irc)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from parse_close.")
             return
          end if
       end if
       !
       call observation_clearTargetList(css,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from cleartargetlist.")
          return
       end if
       deallocate(css%msg)
       ! 
       css%prev%next => css%next
       css%next%prev => css%prev
       deallocate(css)
    else
       irc=599
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Attempt to close none-existent session.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    if(obs_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine observation_closeSession
  !
  ! make cache file
  !
  subroutine observation_makeCache(css,path250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile !  current file
    type(obs_mainCategory), pointer :: currentCat !  current file
    type(obs_subCategory), pointer :: currentSub !  current file
    integer, external :: length,ftunit
    integer :: lenp,unitr
    character*250 :: buff250, str250
    character*22 :: myname="observation_makeCache"
    integer :: ii, leno,cnt
    character*250 :: old250
    !if(obs_bdeb)write(*,*) myname,' *** Entering.',irc
    leno=0
    call chop0(path250,250)
    lenp=length(path250,250,20)
    if(obs_bdeb)write(*,*)myname," *** Entering '"//path250(1:lenp)//"'",irc
    ! open file
    unitr=ftunit(irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," no free unit number for "//path250(1:lenp))
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    lenp=length(path250,250,10)
    open ( unit=unitr, status="unknown", form="formatted", &
         &        access="sequential", &
         &        iostat=irc, file=path250(1:lenp) )
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," unable to open '"//path250(1:lenp)//"'")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    !
    call observation_makeTargetList(css,crc250,irc) 
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from makeTargetList.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    !
    call observation_sortStack(css,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from sortStack.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    !
    ! write number of files: css%nFileIndexes
    if(obs_bdeb)write(*,*) myname,' Files:',css%nFileIndexes
    leno=0
    cnt=0
    do ii=1,css%newnFileSortIndexes(1)
       currentFile=>css%fileStack(css%fileStackInd(ii,1))%ptr
       if (old250(1:leno).ne.currentFile%fn250(1:currentFile%lenf)) then
          cnt=cnt+1
       end if
       old250=currentFile%fn250
       leno=currentFile%lenf
    end do
    write(unitr,'(I0,8(X,I0))',iostat=irc) cnt,css%values
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," unable to write to "//path250(1:lenp))
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    !
    write(*,'(X,A,A,I0,A,I4.4,6(A,I2.2))')myname," Index '"//path250(1:lenp)//&
         & "' contains ",cnt," files. Modified:", &
         & css%values(1),"-",css%values(2),"-",css%values(3),"T",&
         & css%values(5),":",css%values(6),":",css%values(7)
    ! loop over file stack
    leno=0
    do ii=1,css%newnFileSortIndexes(1)
       currentFile=>css%fileStack(css%fileStackInd(ii,1))%ptr
       if (old250(1:leno).ne.currentFile%fn250(1:currentFile%lenf)) then
          write(unitr,'(L1,2(X,F0.10),4(X,I0),X,A)',iostat=irc) &
               & currentFile%ind_lim,&
               & currentFile%ind_start,currentFile%ind_stop,&
               & currentFile%nmessage,currentFile%ncat,currentFile%nsub,&
               & currentFile%lenf,currentFile%fn250(1:currentFile%lenf)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," unable to write to "//path250(1:lenp))
             call observation_errorappendi(crc250,irc)
             call observation_errorappend(crc250,"\n")
             return
          end if
          !
          if (currentFile%ind_lim) then
             write(*,'(2X,A," <",F0.1,",",F0.1,">")') currentFile%fn250(1:currentFile%lenf),&
                  & currentFile%ind_start,currentFile%ind_stop
          else
             write(*,'(2X,A," <*,*>")') currentFile%fn250(1:currentFile%lenf)
          end if
          ! write category summary
          currentCat=>currentFile%firstCategory%next
          do while (.not.associated(currentCat,target=currentFile%lastCategory)) 
             write(unitr,'(3(X,I0))',iostat=irc) currentCat%category,&
                  & currentCat%cnt,currentCat%nsub
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," unable to write to "//path250(1:lenp))
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
             currentSub=> currentCat%firstSubCategory%next
             do while (.not.associated(currentSub,target=currentCat%lastSubCategory)) 
                write(unitr,'(2(X,I0))',iostat=irc) currentSub%subcategory,currentSub%cnt
                if (irc.ne.0) then
                   call observation_errorappend(crc250,myname)
                   call observation_errorappend(crc250," unable to write to "//path250(1:lenp))
                   call observation_errorappendi(crc250,irc)
                   call observation_errorappend(crc250,"\n")
                   return
                end if
                currentSub=>currentSub%next
             end do
             currentCat=>currentCat%next
          end do
       end if
       old250=currentFile%fn250
       leno=currentFile%lenf
    end do
    ! close file
    close(unitr,iostat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," unable to close "//path250(1:lenp))
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    if(obs_bdeb)write(*,*)myname,' *** Done.',irc
  end subroutine observation_makeCache
  !
  ! load cache file
  !
  subroutine observation_loadCache(css,path250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(obs_file),pointer :: newFile
    type(obs_mainCategory), pointer :: newCat !  current file
    type(obs_subCategory), pointer :: newSub !  current file
    integer, external :: length
    integer :: lenp,lenf,lenb,ii,jj,kk,opos,pos,unitr
    character*250 :: buff250
    character*22 :: myname="observation_loadCache"
    character*250 diff250
    integer :: values(8),yy,mm,dd,hh,mi,lend
    real :: sec, f2000,s2000
    !if(obs_bdeb)write(*,*) myname,' *** Entering.',irc
    call chop0(path250,250)
    lenp=length(path250,250,20)
    if(obs_bdeb)write(*,*)myname," *** Entering '"//path250(1:lenp)//"'",irc
    if (lenp.eq.0) then
       irc=377
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Empty cache-file.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    ! clear existing cache
    css%stackReady=.false.
    call observation_removeFiles(css,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from removeFiles.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    ! open cache file
    if(obs_bdeb)write(*,*)myname," Opening obscache: '"//path250(1:lenp)//"'"
    open ( unit=unitr, status="old", form="formatted", &
         &        access="sequential", &
         &        iostat=irc, file=path250(1:lenp) )
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," unable to open '"//path250(1:lenp)//"'")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    ! read number of files: css%nFileIndexes
    read(unitr,'(A)',iostat=irc) buff250
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," unable to read: '"//path250(1:lenp)//"'")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    call chop0(buff250,250)
    lenb=length(buff250,250,10)
    read(buff250(1:lenb),*,iostat=irc) css%nFileIndexes,values
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Corrupt index file "//path250(1:lenp))
       call observation_errorappend(crc250,buff250(1:lenb))
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    if(obs_bdeb)write(*,*)myname," Indexed files:",css%nFileIndexes
    ! loop through cache file
    do ii=1,css%nFileIndexes
       allocate(newFile,stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Unable to allocate new File item.")
          call observation_errorappend(crc250,"\n")
          return
       end if
       newFile%firstCategory%next => newFile%lastCategory
       newFile%lastCategory%prev => newFile%firstCategory
       css%stackReady=.false.
       newFile%prev => css%lastFile%prev
       newFile%next => css%lastFile
       newFile%prev%next => newFile
       newFile%next%prev => newFile
       css%currentFile=>newFile
       !
       do jj=1,10
          newFile%ook(jj)=0
          newFile%orm(jj)=0
       end do
       !
       read(unitr,'(A)',iostat=irc) buff250
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," unable to read (2) "//path250(1:lenp))
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       call chop0(buff250,250)
       pos=0
       opos=pos
       call findDelimiter(buff250," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%ind_lim
       opos=pos
       call findDelimiter(buff250," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%ind_start
       opos=pos
       call findDelimiter(buff250," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%ind_stop
       opos=pos
       call findDelimiter(buff250," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%nmessage
       opos=pos
       call findDelimiter(buff250," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%ncat
       opos=pos
       call findDelimiter(buff250," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%nsub
       opos=pos
       call findDelimiter(buff250," ",pos)
       read(buff250(opos+1:pos-1),*,iostat=irc)newFile%lenf
       opos=pos
       pos=length(buff250,250,10)
       newFile%fn250=buff250(opos+1:pos)
       call chop0(newFile%fn250,250)
       lenf=length(newFile%fn250,250,10)
       !
       if (obs_bdeb) then
          if (newFile%ind_lim) then
             write(*,'(X,A,X,A,I0,X,"<",F0.1,",",F0.1,">")') myname,&
                  & "loaded:'"//newFile%fn250(1:newFile%lenf)//"'",ii,newFile%ind_start,newfile%ind_stop
          else
              write(*,'(X,A,X,A,I0,X,"<*,*>")') myname,&
                  & "loaded:'"//newFile%fn250(1:newFile%lenf)//"'",ii
         end if
       end if
       !
       do jj=1,newFile%ncat
          allocate(newCat,stat=irc)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Unable to allocate new Cat item.")
             call observation_errorappend(crc250,"\n")
             return
          end if
          newCat%next => newFile%lastCategory
          newCat%prev => newFile%lastCategory%prev
          newFile%lastCategory%prev%next => newCat
          newFile%lastCategory%prev => newCat
          newCat%lastSubCategory%prev => newCat%firstSubCategory
          newCat%firstSubCategory%next => newCat%lastSubCategory
          read(unitr,'(A)',iostat=irc) buff250
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," unable to read "//path250(1:lenp))
             call observation_errorappendi(crc250,irc)
             call observation_errorappend(crc250,"\n")
             return
          end if
          call chop0(buff250,250)
          pos=0
          opos=pos
          call findDelimiter(buff250," ",pos)
          read(buff250(opos+1:pos-1),*,iostat=irc)newCat%category
          opos=pos
          call findDelimiter(buff250," ",pos)
          read(buff250(opos+1:pos-1),*,iostat=irc)newCat%cnt
          opos=pos
          pos=length(buff250,250,10)
          read(buff250(opos+1:pos),*,iostat=irc)newCat%nsub
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," unable to get nsub from:"//buff250(opos+1:pos-1))
             call observation_errorappendi(crc250,irc)
             call observation_errorappend(crc250,"\n")
             return
          end if
          do kk=1,newCat%nsub
             allocate(newSub,stat=irc)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Unable to allocate new Subcat item.")
                call observation_errorappend(crc250,"\n")
                return
             end if
             newSub%next => newCat%lastSubCategory
             newSub%prev => newCat%lastSubCategory%prev
             newCat%lastSubCategory%prev%next => newSub
             newCat%lastSubCategory%prev => newSub
             read(unitr,'(A)',iostat=irc) buff250
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," unable to read "//path250(1:lenp))
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
             call chop0(buff250,250)
             pos=0
             opos=pos
             call findDelimiter(buff250," ",pos)
             read(buff250(opos+1:pos-1),*,iostat=irc)newSub%subcategory
             opos=pos
             pos=length(buff250,250,10)
             read(buff250(opos+1:pos),*,iostat=irc)newSub%cnt
          end do
       end do

    end do
    ! close file
    close(unitr,iostat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," unable to close "//path250(1:lenp))
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    yy=css%values(1)
    mm=css%values(2)
    dd=css%values(3)
    hh=css%values(5)
    mi=css%values(6)
    sec=css%values(7)
    call jd2000(s2000,yy,mm,dd,hh,mi,sec)
    yy=values(1)
    mm=values(2)
    dd=values(3)
    hh=values(5)
    mi=values(6)
    sec=values(7)
    call jd2000(f2000,yy,mm,dd,hh,mi,sec)
    diff250=observation_diff(s2000-f2000)
    lend=length(diff250,250,10)
    write(*,'(X,A,A,I0,A,I4.4,6(A,I2.2),A)')myname," Index '"//path250(1:lenp)//&
         & "' contains ",css%nFileIndexes," files. Modified:", &
         & values(1),"-",values(2),"-",values(3),"T",&
         & values(5),":",values(6),":",values(7),". Age:"//diff250(1:lend)
    if(obs_bdeb)write(*,*)myname,' *** Done.',irc
  end subroutine observation_loadCache
  !
  !###############################################################################
  !STACK ROUTINES
  !###############################################################################
  !
  ! clear the BUFR STACK
  !
  subroutine observation_stackclear(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    integer :: lens
    character*22 :: myname="observation_stackclear"
    if(obs_bdeb)write(*,*)myname,' Entering.'
    ! mark as prepared
    css%stackReady=.false.
    !
    if(obs_bdeb)write(*,*)myname,' Removing files.'
    call observation_removeFiles(css,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from observation_removeFiles.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    if (css%nFileIndexes .ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," System error A:")
       call observation_errorappendi(crc250,css%nFileIndexes)
       call observation_errorappend(crc250,"\n")
       irc=940
       return
    end if
    if(obs_bdeb)write(*,*)myname,' Done.'
  end subroutine observation_stackclear
  !
  ! get the bufr table path
  !
  subroutine observation_getTablePath(css,path250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    path250=css%tablepath
    return
  end subroutine observation_getTablePath
  !
  ! set the bufr table path
  !
  subroutine observation_setTablePath(css,path250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    type(obs_file), pointer :: stackNext => null()
    integer, external :: length
    integer :: lenb
    character*250 :: buff250
    character*22 :: myname="observation_setTablePath"
    buff250=path250
    call chop0(buff250,250)
    lenb=length(buff250,250,10)
    if(obs_bdeb)write(*,*)myname,' Entering.'//buff250(1:lenb)
    if (lenb.gt.0.and.lenb.lt.250) then
       if (buff250(lenb:lenb).ne."/") then
          buff250=buff250(1:lenb)//"/"
          call chop0(buff250,250)
          lenb=length(buff250,250,10)
       end if
    end if
    css%tablepath=buff250
    call chop0(css%tablepath,250)
    write(*,*)myname," BUFR table path= '"//buff250(1:lenb)//"'"
    !if(obs_bdeb)write(*,*)myname,' Done. "'//buff250(1:lenb)//'"'
  end subroutine observation_setTablePath
  !
  ! set table c file name
  !
  subroutine observation_setTableC(css,path250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    type(obs_file), pointer :: stackNext => null()
    integer, external :: length
    integer :: lens
    character*22 :: myname="observation_setTableC"
    ctableInit=.false.
    c250=path250
    call chop0(c250,250)
    if(obs_bdeb)write(*,*)myname,' Done.'
  end subroutine observation_setTableC
  !
  !
  !
  subroutine observation_setBufrType(css,category,subCategory,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: category
    integer :: subCategory
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    type(obs_file), pointer :: stackNext => null()
    integer, external :: length
    integer :: lens
    character*22 :: myname="observation_setBufrType"
    if(obs_bdeb)write(*,*)myname,' Entering.'
    css%category=category
    css%subCategory=subCategory
    if(obs_bdeb)write(*,*)myname,' Done.'
  end subroutine observation_setBufrType
  !
  !
  subroutine observation_getBufrType(css,category,subCategory,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: category
    integer :: subCategory
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    type(obs_file), pointer :: stackNext => null()
    integer, external :: length
    integer :: lens
    character*22 :: myname="observation_getBufrType"
    if(obs_bdeb)write(*,*)myname,' Entering.'
    category=css%category
    subCategory=css%subCategory
    if(obs_bdeb)write(*,*)myname,' Done.'
  end subroutine observation_getBufrType
  !
  ! remove item from bufr stack
  !
  subroutine observation_removeFiles (css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    type(obs_file), pointer :: currentFile,nextFile
    character*22 :: myname="observation_removeFiles "
    currentFile => css%firstFile%next
    do while (.not.associated(currentFile,target=css%lastFile))
       nextFile => currentFile%next
       if (associated(currentFile)) then
          !if(obs_bdeb)write(*,*)myname,' Removing categories.'
          call observation_clearCat(currentFile)
          !if(obs_bdeb)write(*,*)myname,' Updating inventory.'
          css%nFileIndexes = css%nFileIndexes - 1
          css%stackReady=.false.
          currentFile%next%prev => currentFile%prev
          currentFile%prev%next => currentFile%next
          nullify(currentFile%prev)
          nullify(currentFile%next)
          deallocate(currentFile) ! arrays are deallocated automatically
       end if
       currentFile => nextFile
    end do
  end subroutine observation_removeFiles
  !
  ! Add bufr-file to the BUFR STACK
  !
  subroutine observation_stackpush(css,path250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(obs_file),pointer :: newFile
    logical  :: bok =.false.
    INTEGER(KIND=4), ALLOCATABLE, DIMENSION(:) :: start, vsize, atypes
    character(len=80), allocatable, dimension(:) :: dimnames
    integer :: nvalues, tsize, ndims
    integer :: ii,jj,kk,tt
    CHARACTER(LEN=80)               :: varname
    integer, external :: length
    integer :: lenc,leni,lenv,lens,lenp,lend
    logical :: bbok
    character*22 :: myname="observation_stackpush"
    if(obs_bdeb)write(*,*) myname,' Entering.',irc
    call chop0(path250,250)
    lenp=length(path250,250,20)
    write(*,*)myname," Pushing '"//path250(1:lenp)//"'"
    ! create new stack-item
    bok=.true.
    allocate(newFile,stat=irc)
    if (irc.ne.0) then
       bok=.false.
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Unable to allocate new stack item.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    newFile%firstCategory%next => newFile%lastCategory
    newFile%lastCategory%prev => newFile%firstCategory
    ! push onto stack
    if (bok) then
       css%nFileIndexes=css%nFileIndexes + 1
       css%stackReady=.false.
       newFile%prev => css%lastFile%prev
       newFile%next => css%lastFile
       newFile%prev%next => newFile
       newFile%next%prev => newFile
       ! set file name...
       newFile%fn250=path250
       call chop0(newFile%fn250,250)
       newFile%lenf=length(newFile%fn250,250,20)
       newFile%tablepath=css%tablepath
       !
       do jj=1,10
          newFile%ook(jj)=0
          newFile%orm(jj)=0
       end do
       !
       if (obs_bdeb) call observation_printStack(css,crc250,irc)
       css%currentFile=>newFile
    end if
    ! open file
    if (bok) then
       ! open file
       call observation_scanFile(css,bok,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_scanFile.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
    end if
    ! if (.not.bok) then
    !    if (associated(css%currentFile)) then
    !       call observation_stackpop(css,path250,crc250,irc)
    !       if (irc.ne.0) then
    !          call observation_errorappend(crc250,myname)
    !          call observation_errorappend(crc250," Error return from observation_stackpop.")
    !          call observation_errorappendi(crc250,irc)
    !          call observation_errorappend(crc250,"\n")
    !          return
    !       end if
    !    end if
    ! end if
    if (obs_bdeb) call observation_printStack(css,crc250,irc)
    if(obs_bdeb)write(*,*)myname,' Done.',irc
  end subroutine observation_stackpush

  !
  ! Remove last bufr-file on the BUFR STACK
  !
  subroutine observation_stackpop(css,path250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    type(obs_file), pointer :: prevFile => null()
    character*22 :: myname="observation_stackpop"
    logical :: bdone
    integer, external :: length
    integer :: lenp
    if(obs_bdeb)write(*,*)myname,' Entering.',irc
    call chop0(path250,250)
    lenp=length(path250,250,10)
    currentFile => css%lastFile%prev
    bdone=associated(currentFile,target=css%firstFile)
    do while (.not. bdone) 
       prevFile=>currentFile%prev
       if (currentFile%fn250(1:currentFile%lenf).eq.path250(1:lenp).or.lenp.eq.0) then
          if(obs_bdeb)write(*,*)myname,' *** Popping:',currentFile%fn250(1:currentFile%lenf)
          css%nFileIndexes=css%nFileIndexes - 1
          css%stackReady=.false.
          currentFile%next%prev => currentFile%prev
          currentFile%prev%next => currentFile%next
          nullify(currentFile%prev)
          nullify(currentFile%next)
          deallocate(currentFile) ! arrays are deallocated automatically
          css%currentFile => prevFile
          bdone=(lenp.eq.0)
       end if
       currentFile=>prevFile
       bdone=(bdone.or.associated(currentFile,target=css%firstFile))
    end do
    if(obs_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine observation_stackpop

  !
  ! Peek at last bufr-file put onto the BUFR STACK
  !
  subroutine observation_stackpeeklen(css,maxrep,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: maxrep
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    integer :: ii,jj
    character*22 :: myname="observation_stackpeeklen"
    maxrep=1
    currentFile => css%lastFile%prev
    ! report file-name
    if (.not.associated(currentFile,target=css%firstFile)) then
       call observation_getFileReportLen(css,currentFile,maxrep,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_getFileReportLen.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
    end if
    !if(obs_bdeb)write(*,*)myname,' Done.',associated(css%lastFile%prev,target=css%firstFile)
  end subroutine observation_stackpeeklen
  !
  subroutine observation_stackpeek(css,maxrep,nrep,rep250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: maxrep
    integer :: nrep
    character*250 :: rep250(maxrep)
    character*250 :: crc250
    integer :: irc
    character*50 :: s1, s2, s3
    integer, external :: length
    integer :: len1,len2,len3,lenm,lenv,lena,lenr,lend,lens
    type(obs_file), pointer :: currentFile => null()
    integer :: ii,jj
    character*80 :: varname
    character*22 :: myname="observation_stackpeek"
    if(obs_bdeb)write(*,*)myname,' Entering.'
    currentFile => css%lastFile%prev
    ! report file-name
    nrep=0
    if (.not.associated(currentFile,target=css%firstFile)) then
       call observation_getFileReport(css,currentFile,maxrep,nrep,rep250,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_getFileReport.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
    end if
    if(obs_bdeb)write(*,*)myname,' Done.',maxrep,nrep
  end subroutine observation_stackpeek

  subroutine observation_getFileReportLen(css,currentFile,maxrep,crc250,irc)
    type(obs_session), pointer :: css !  current session
    type(obs_file), pointer :: currentFile
    integer :: maxrep
    character*250 :: crc250
    integer :: irc
    type(obs_mainCategory), pointer :: cat
    type(obs_subCategory), pointer :: sub
    character*22 :: myname="observation_getFileReportLen"
    maxrep=2
    if (currentFile%time_lim) then
       maxrep=maxrep+2
    end if
    if (currentFile%ind_lim) then
       maxrep=maxrep+2
    end if
    cat => currentFile%firstCategory%next
    do while (.not.associated(cat,target=currentFile%lastCategory))
       maxrep=maxrep+1
       sub => cat%firstSubCategory%next
       do while (.not.associated(sub,target=cat%lastSubCategory))
          maxrep=maxrep+3
          maxrep=maxrep+4*sub%ktdexl
          sub => sub%next
       end do
       cat => cat%next
    end do
    !write(*,*)myname,'Maxrep:',maxrep
    return
  end subroutine observation_getFileReportLen

  subroutine observation_getFileReport(css,currentFile,maxrep,nrep,rep250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    type(obs_file), pointer :: currentFile
    integer :: maxrep
    integer :: nrep
    character*250 :: rep250(maxrep)
    character*250 :: crc250
    integer :: irc
    character*50 :: s1, s2, s3, s4
    integer, external :: length
    integer :: len1,len2,len3,len4,lenm,lenv,lena,lenr,lend,lens
    integer :: ii,jj
    character*80 :: varname
    type(obs_mainCategory), pointer :: cat
    type(obs_subCategory), pointer :: sub
    logical :: first
    character*22 :: myname="observation_getFileReport"
    ! file name
    call chop0(currentFile%fn250,250)
    lenm=length(currentFile%fn250,250,20)
    nrep=min(maxrep,nrep+1)               ! file name  +1
    rep250(nrep)="file"//sep//"name"//sep//currentFile%fn250(1:lenm)
    write(s1,'(I12)') currentFile%nsubset; call chop0(s1,50); len1=length(s1,50,10)
    nrep=min(maxrep,nrep+1)               ! number of observations  +1
    rep250(nrep)="file"//sep//"message count"//sep//s1(1:len1)
    ! sorting variable is available
    if (currentFile%time_lim) then
       write(s2,*) currentFile%time_start; call chop0(s2,50); len2=length(s2,50,10)
       write(s3,*) currentFile%time_stop; call chop0(s3,50); len3=length(s3,50,10)
       nrep=min(maxrep,nrep+1)          ! start time      +1
       rep250(nrep)="file"//sep//"time"//sep//"start"//sep//s2(1:len2)
       nrep=min(maxrep,nrep+1)          ! end time      +1
       rep250(nrep)="file"//sep//"time"//sep//"stop"//sep//s3(1:len3)
    end if
    if (currentFile%ind_lim) then
       write(s2,*) currentFile%ind_start; call chop0(s2,50); len2=length(s2,50,10)
       write(s3,*) currentFile%ind_stop; call chop0(s3,50); len3=length(s3,50,10)
       nrep=min(maxrep,nrep+1)          ! start time      +1
       rep250(nrep)="file"//sep//"index"//sep//"start"//sep//s2(1:len2)
       nrep=min(maxrep,nrep+1)          ! end time      +1
       rep250(nrep)="file"//sep//"index"//sep//"stop"//sep//s3(1:len3)
    end if
    cat => currentFile%firstCategory%next
    do while (.not.associated(cat,target=currentFile%lastCategory))
       nrep=min(maxrep,nrep+1)          ! cat      +1
       write(rep250(nrep),'("file",A,"type",A,I0,A,"message count",A,I0)') sep,sep,&
            & cat%category, sep,sep, cat%cnt
       first=.true.
       sub => cat%firstSubCategory%next
       do while (.not.associated(sub,target=cat%lastSubCategory))
          call observation_getType(cat%category,sub%subcategory,s2,s3,crc250,irc)
          call chop0(s2,50); len2=length(s2,50,10);call chop0(s3,50); len3=length(s3,50,10)
          if (len3.ne.0) then
             nrep=min(nrep+1,maxrep)
             write(rep250(nrep),'("file",A,"type",A,I0,A,"subtype",A,I0,A,"description",A,A)') sep,sep,&
                  & cat%category, sep,sep, sub%subcategory, sep,sep, s3(1:len3)
          end if
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'("file",A,"type",A,I0,A,"subtype",A,I0,A,"message count",A,I0)') sep,sep,&
               & cat%category, sep,sep, sub%subcategory, sep,sep, sub%cnt
          if (first.and.len2.ne.0) then
             first=.false.
             nrep=min(maxrep,nrep+1)          ! desc      +1
             write(rep250(nrep),'("file",A,"type",A,I0,A,"description",A,A)') sep,sep,&
                  & cat%category, sep,sep, s2(1:len2)
          end if
          do ii=1,min(sub%ktdexl,ktdexl_max)
             nrep=min(nrep+1,maxrep)
             write(rep250(nrep),'("file",A,"type",A,I0,A,"subtype",A,I0,A,"seqno",A,I0,A,I0)') sep,sep,&
                  & cat%category, sep,sep, sub%subcategory, sep,sep, ii,sep,sub%ktdexp(ii)
             nrep=min(nrep+1,maxrep)
             write(rep250(nrep),'("file",A,"type",A,I0,A,"subtype",A,I0,A,"name",A,I0,A,A)') sep,sep,&
                  & cat%category, sep,sep, sub%subcategory, sep,sep, ii,sep,sub%cnames(ii)
             nrep=min(nrep+1,maxrep)
             write(rep250(nrep),'("file",A,"type",A,I0,A,"subtype",A,I0,A,"unit",A,I0,A,A)') sep,sep,&
                  & cat%category, sep,sep, sub%subcategory, sep,sep, ii,sep,sub%cunits(ii)
             nrep=min(nrep+1,maxrep)
             if (sub%values(ii).eq.rvind) then
                s4="NA"
                len4=2
             else
                call observation_wash(sub%values(ii),s4,len4)
             end if
             write(rep250(nrep),'("file",A,"type",A,I0,A,"subtype",A,I0,A,"val1",A,I0,A,A)') sep,sep,&
                  & cat%category, sep,sep, sub%subcategory, sep,sep, ii,sep,s4(1:len4)
          end do
          sub => sub%next
       end do
       cat => cat%next
    end do

    if (obs_bdeb) then
       do ii=1,nrep
          call chop0(rep250(II),250)
          lenr=length(rep250(ii),250,100)
          write(*,*) myname,' REP:',ii,maxrep,rep250(ii)(1:lenr)
       end do
    end if

    return
  end subroutine observation_getFileReport

  !
  !###############################################################################
  !ROUTINES FOR MAINTAINING TARGET STACK
  !###############################################################################
  !
  subroutine observation_targetinit(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_targetinit"
    css%reportsReady=.false. ! we must redo report generation
    ! initialise chain
    if (.not.associated(css%firsttarget)) then
       allocate(css%firsttarget,css%lasttarget, stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250,"Unable to allocate 'firsttarget/lasttarget'.")
          call observation_errorappend(crc250,"\n")
          return
       end if
       css%firsttarget%next => css%lasttarget
       css%lasttarget%prev => css%firsttarget
       css%ntarget=0
       css%ndyn=0
       css%trg_set=.false.
       css%dyn_set=.false.
    end if
  end subroutine observation_targetinit
  !
  ! clear the target stack
  !
  subroutine observation_clearTargetStack(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_clearTargetStack"
    integer :: ii, lens
    integer, external :: length
    if(obs_bdeb)write(*,*)myname,' Entering.'
    css%reportsReady=.false. ! old reports are discarded...
    ! delete any existing Target-entries
    call observation_removeTarget(css,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from targetrmitem.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    if (css%ntarget .ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," System error B:")
       call observation_errorappendi(crc250,css%ntarget)
       call observation_errorappend(crc250,"\n")
       irc=940
       return
    end if
  end subroutine observation_clearTargetStack
  !
  ! add item to target list
  !
  subroutine observation_pushtarget(css,trg,pos,descr,info,&
       & min,max,crc250,irc)
    implicit none
    type(obs_session), pointer :: css !  current session
    character(len=*) :: trg      ! target name
    character(len=*) :: pos      ! target position
    character(len=*) :: descr    ! target description
    character(len=*) :: info     ! target info
    character(len=*) :: min      ! target min value
    character(len=*) :: max      ! target max value
    character*250 :: crc250
    integer :: irc
    type(obs_target),pointer :: newTarget
    integer :: ii,yy,mm,dd,hh,mi
    real:: sec
    integer :: lenc,lenp,lend,lens,lene
    integer, external :: length
    character*22 :: myname="observation_pushTarget"
    if(obs_bdeb)write(*,*)myname,' Adding: "'//trg(1:len_trim(trg))//'" "'//pos(1:len_trim(pos))//'"'
    if (len(trg).eq.0) then
       irc=983
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Invalid target name:")
       call observation_errorappend(crc250,trg(1:len(trg))//" "//pos(1:len(pos)))
       call observation_errorappend(crc250,"\n")
       return
    end if
    if (len(pos).eq.0.and.len(descr).eq.0.and.(len(min).eq.0.or.len(max).eq.0)) then
       irc=984
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Invalid target position:")
       call observation_errorappend(crc250,trg(1:len(trg))//" "//pos(1:len(pos)))
       call observation_errorappend(crc250,"\n")
       return
    end if
    css%reportsReady=.false. ! we must redo report generation
    ! create new pos-item
    allocate(newTarget,stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Unable to allocate new Target.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    newTarget%trg80=trg
    newTarget%pos250=pos
    newTarget%descr80=descr
    newTarget%info250=info
    newTarget%min80=min
    newTarget%max80=max
    newTarget%type=parse_type(pos,css%int_var,crc250,irc) ! get position type...
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from parse_type.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    ! push onto stack
    css%ntarget=css%ntarget + 1
    newTarget%prev => css%lasttarget%prev
    newTarget%next => css%lasttarget
    newTarget%prev%next => newTarget
    newTarget%next%prev => newTarget
    css%trg_set=.false.
    css%dyn_set=.false.
    if (newTarget%type.eq.parse_variable) then
       css%ndyn=css%ndyn+1
       newTarget%ind=css%ndyn
    else
       newTarget%ind=0
    end if
    nullify(newTarget)
    !if(obs_bdeb)write(*,*)myname,' Done.',trg
    return
  end subroutine observation_pushTarget
  !
  ! loop over target entries
  !
  logical function observation_looptarget(css,trg80,pos250,descr80,&
       & info250,min80,max80,crc250,irc)
    implicit none
    type(obs_session), pointer :: css !  current session
    character*80  :: trg80      ! target name
    character*250 :: pos250    ! position/sequence number
    character*80  :: descr80    ! descriptor
    character*250 :: info250   ! information
    character*80  :: min80      ! min value
    character*80  :: max80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_looptarget"
    observation_looptarget=.false. ! only true if all is ok...
    if (.not.associated(css%ctarget)) then
       css%ctarget =>  css%firstTarget%next 
    else
       css%ctarget =>  css%ctarget%next
    end if
    if (associated(css%ctarget,css%lastTarget)) then
       nullify(css%ctarget)
       observation_looptarget=.false.
    else
       trg80=css%ctarget%trg80
       pos250=css%ctarget%pos250
       descr80=css%ctarget%descr80
       info250=css%ctarget%info250
       min80=css%ctarget%min80
       max80=css%ctarget%max80
       observation_looptarget=.true.
    end if
    return
  end function observation_looptarget
  !
  ! get number of targets
  !
  integer function observation_targetCount(css,crc250,irc)
    type(obs_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_targetCount "
    observation_targetCount=css%ntarget
    return
  end function observation_targetCount
  !
  integer function observation_trgCount(css,crc250,irc)
    type(obs_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_trgCount "
    observation_trgCount=css%ntrg
    return
  end function observation_trgCount
  !
  ! get number of locations
  !
  integer function observation_locationCount(css,crc250,irc)
    type(obs_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_locationCount "
    observation_locationCount=css%nloc
    return
  end function observation_locationCount
  !
  ! make target list
  !
  subroutine observation_getTrg80(css,var80,offset,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*80, allocatable :: var80(:)
    integer :: offset
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="observation_getTrg80"
    integer ii
    do ii=1,css%ntrg
       var80(ii+offset)=css%trg80(ii)
    end do
    return
  end subroutine observation_getTrg80
  !
  ! get output values
  !
  subroutine observation_getVal(css,iloc,val,offset,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: iloc
    real, allocatable :: val(:)
    integer :: offset
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="observation_getVal"
    integer ii
    do ii=1,css%ntrg
       val(ii+offset)=css%locdata(iloc)%ptr%trg_val(ii)
    end do
    return
  end subroutine observation_getVal
  !
  ! check if session has index expression defined
  !
  logical function observation_hasValidIndex(css,crc250,irc)
    type(obs_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_hasValidIndex "
    observation_hasValidIndex=css%ind_eset
  end function observation_hasValidIndex
  !
  ! print stack
  !
  subroutine observation_printStack(css,crc250,irc) 
    type(obs_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_printStack "
    type(obs_target), pointer :: currenttarget => null()
    integer :: lent,lenp,lend,lens,lene,ii
    integer, external :: length
    ii=0
    if ( .not. css%trg_set ) then
       if(obs_bdeb)write(*,*)myname,' Targets:',css%ntrg
       currenttarget => css%firsttarget%next
       do while (.not.associated(currenttarget,target=css%lasttarget))
          ii=ii+1
          call chop0(currenttarget%trg80,80)
          call chop0(currenttarget%pos250,250)
          call chop0(currenttarget%descr80,80)
          call chop0(currenttarget%info250,250)
          call chop0(currenttarget%min80,80)
          call chop0(currenttarget%max80,80)
          lent=length(currenttarget%trg80,80,10)
          lenp=length(currenttarget%pos250,250,10)
          lend=length(currenttarget%descr80,80,10)
          lens=length(currenttarget%min80,80,10)
          lene=length(currenttarget%max80,80,10)
          write(*,*) myname,' Stack:',ii,' pos="'//currenttarget%pos250(1:lenp)//'" target="'//currenttarget%trg80(1:lent)//'"'
          currenttarget => currenttarget%next
       end do
    end if
    write(*,*) myname,' Stack entries:',ii
    return
  end subroutine observation_printStack

  !
  ! make target list from target chain
  !
  subroutine observation_clearTargetList(css,crc250,irc)
    type(obs_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    if (allocated(css%trg80)) deallocate(css%trg80)
    if (allocated(css%trg_lent)) deallocate(css%trg_lent)
    if (allocated(css%trg_pos250)) deallocate(css%trg_pos250)
    if (allocated(css%trg_lenp)) deallocate(css%trg_lenp)
    if (allocated(css%trg_type)) deallocate(css%trg_type)
    if (allocated(css%trg_seq)) deallocate(css%trg_seq)
    if (allocated(css%trg_ind)) deallocate(css%trg_ind)
    if (associated(css%trg_psp)) deallocate(css%trg_psp)
    if (allocated(css%trg_descr)) deallocate(css%trg_descr)
    if (allocated(css%trg_lval)) deallocate(css%trg_lval)
    if (allocated(css%trg_minval)) deallocate(css%trg_minval)
    if (allocated(css%trg_maxval)) deallocate(css%trg_maxval)
    if (allocated(css%trg_ook)) deallocate(css%trg_ook)
    if (allocated(css%trg_orm)) deallocate(css%trg_orm)
    if (allocated(css%trg_req)) deallocate(css%trg_req)
    if (allocated(css%trg_val)) deallocate(css%trg_val)
    if (allocated(css%trg_vok)) deallocate(css%trg_vok)
    if (associated(css%trg_ptr)) deallocate(css%trg_ptr)
    css%trg_set=.false.
    ! remove any message data...
    if (associated(css%msg)) then
       if (allocated(css%msg%trg_val)) deallocate(css%msg%trg_val)
       if (allocated(css%msg%trg_vok)) deallocate(css%msg%trg_vok)
       if (allocated(css%msg%trg_set)) deallocate(css%msg%trg_set)
       if (allocated(css%msg%trg_res)) deallocate(css%msg%trg_res)
       deallocate(css%msg)
       allocate(css%msg)
    end if
    return
  end subroutine observation_clearTargetList
  
  subroutine observation_makeTargetList(css,crc250,irc) 
    type(obs_session), pointer :: css   ! session structure
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_makeTargetList "
    type(obs_target), pointer :: currenttarget => null()
    integer :: lent,lenp,lend,ii
    integer, external :: length
    if(obs_bdeb)write(*,*)myname,' Entering.',irc,css%ntarget,css%trg_set,css%ind_eset
    if ( .not. css%trg_set ) then
       if (css%ind_eset) then
          css%ntrg=css%ntarget+1
       else
          css%ntrg=css%ntarget
       end if
       !
       ! set target arrays
       !
       if(obs_bdeb)write(*,*)myname,' Targets:',css%ntrg
       if (allocated(css%trg80)) deallocate(css%trg80)
       if (allocated(css%trg_lent)) deallocate(css%trg_lent)
       if (allocated(css%trg_pos250)) deallocate(css%trg_pos250)
       if (allocated(css%trg_lenp)) deallocate(css%trg_lenp)
       if (allocated(css%trg_type)) deallocate(css%trg_type)
       if (allocated(css%trg_seq)) deallocate(css%trg_seq)
       if (allocated(css%trg_ind)) deallocate(css%trg_ind)
       if (associated(css%trg_psp)) deallocate(css%trg_psp)
       if (allocated(css%trg_descr)) deallocate(css%trg_descr)
       if (allocated(css%trg_lval)) deallocate(css%trg_lval)
       if (allocated(css%trg_minval)) deallocate(css%trg_minval)
       if (allocated(css%trg_maxval)) deallocate(css%trg_maxval)
       if (allocated(css%trg_ook)) deallocate(css%trg_ook)
       if (allocated(css%trg_orm)) deallocate(css%trg_orm)
       if (allocated(css%trg_req)) deallocate(css%trg_req)
       if (allocated(css%trg_val)) deallocate(css%trg_val)
       if (allocated(css%trg_vok)) deallocate(css%trg_vok)
       if (associated(css%trg_ptr)) deallocate(css%trg_ptr)
       allocate(css%trg80(css%ntrg),css%trg_lent(css%ntrg),&
            & css%trg_pos250(css%ntrg),css%trg_lenp(css%ntrg),&
            & css%trg_type(css%ntrg),css%trg_seq(css%ntrg), &
            & css%trg_ind(css%ntrg),css%trg_psp(css%ntrg), &
            & css%trg_descr(css%ntrg),css%trg_lval(2,css%ntrg),&
            & css%trg_minval(css%ntrg),css%trg_maxval(css%ntrg),&
            & css%trg_ook(0:css%ntrg),css%trg_orm(0:css%ntrg),&
            & css%trg_req(css%ntrg),css%trg_val(css%ntrg), &
            & css%trg_vok(css%ntrg),css%trg_ptr(css%ntrg),stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250,"Unable to allocate 'targetList'.")
          call observation_errorappend(crc250,"\n")
          return
       end if
       !
       ! set dynamic variable arrays...
       !
       if (allocated(css%dyn_var)) deallocate(css%dyn_var)
       if (allocated(css%dyn_lenv)) deallocate(css%dyn_lenv)
       if (allocated(css%dyn_val)) deallocate(css%dyn_val)
       allocate(css%dyn_var(css%ndyn),css%dyn_lenv(css%ndyn),css%dyn_val(css%ndyn),stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250,"Unable to allocate 'intlist'.")
          call observation_errorappend(crc250,"\n")
          return
       end if
       css%dyn_pos=0 ! floating position
       css%dyn_cnt=0 ! floating position
       !
       ii=0 ! target
       css%trg_ook(ii)=0
       css%trg_orm(ii)=0
       currenttarget => css%firsttarget%next
       do while (.not.associated(currenttarget,target=css%lasttarget))
          ii=ii+1
          css%trg_ptr(ii)%ptr=>currenttarget
          call chop0(currenttarget%trg80,80)
          call chop0(currenttarget%pos250,250)
          call chop0(currenttarget%descr80,80)
          call chop0(currenttarget%info250,250)
          lent=length(currenttarget%trg80,80,10)
          lenp=length(currenttarget%pos250,250,10)
          lend=length(currenttarget%descr80,80,10)
          css%trg80(ii)=currenttarget%trg80(1:lent)
          css%trg_lent(ii)=lent
          css%trg_ook(ii)=0
          css%trg_orm(ii)=0
          css%trg_req(ii)=.false.           ! is target required?
          css%trg_type(ii)=currenttarget%type
          if (lend.eq.0.and.lenp.eq.0) then ! this is a delayed variable
             css%trg_type(ii)=parse_delay ! delay processing
             css%trg_descr(ii)=0
             if(obs_bdeb)write(*,*)myname,' Duplicator candidate at:',ii
          else if (css%trg_type(ii).ne.parse_internal) then ! no descriptor
             read(currenttarget%descr80(1:lend),*,iostat=irc) css%trg_descr(ii)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Unable to read descr from '"//currenttarget%descr80(1:lend)//"'")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
          end if
          css%trg_pos250(ii)=currenttarget%pos250
          css%trg_lenp(ii)=lenp
          select case (css%trg_type(ii)) ! process position (empty,const,var,expr=
          case (parse_delay) ! delayed processing
          case (parse_empty)
             css%trg_seq(ii)=0
             css%trg_ind(ii)=0
          case (parse_constant)
             css%trg_ind(ii)=0
             read(currenttarget%pos250(1:lenp),*,iostat=irc) css%trg_seq(ii)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Unable to read seq from '"&
                     & //currenttarget%pos250(1:lenp)//"'")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
          case (parse_internal); ! no descriptor allowed
             if (lend.ne.0) then
                irc=244
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Interal variable with descriptor: '"&
                     & //currenttarget%pos250(1:lenp)//"'")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
             css%trg_seq(ii)=0
             css%trg_ind(ii)=0
             call parse_open(css%trg_psp(ii)%ptr,crc250,irc)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from parse_open.")
                return
             end if
          case (parse_variable);
             css%trg_seq(ii)=0
             css%trg_ind(ii)=currenttarget%ind
             css%dyn_var(currenttarget%ind)=currenttarget%pos250(1:min(80,lenp))
             css%dyn_lenv(currenttarget%ind)=lenp
             css%dyn_val(currenttarget%ind)=0
          case (parse_expression);
             css%trg_seq(ii)=0
             css%trg_ind(ii)=0
             call parse_open(css%trg_psp(ii)%ptr,crc250,irc)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from parse_open.")
                return
             end if
          end select
          currenttarget => currenttarget%next
       end do
       if (css%ind_eset) then
          ii=ii+1
          nullify(css%trg_ptr(ii)%ptr)
          css%trg80(ii)=css%ind_trg80(1:css%ind_lent)
          css%trg_lent(ii)=css%ind_lent
          css%trg_lval(1,ii)=css%ind_lval(1)
          css%trg_lval(2,ii)=css%ind_lval(2)
          css%trg_minval(ii)=css%ind_minval
          css%trg_maxval(ii)=css%ind_maxval
          css%trg_req(ii)=(css%ind_lval(1).or.css%ind_lval(2)) ! is target required?
       end if
       css%trg_set=.true.
       css%dyn_set=.true.
    end if
    if(obs_bdeb)write(*,*)myname,' Done.',irc,css%ntarget,css%ntrg,css%ind_eset
    return
  end subroutine observation_makeTargetList
  !
  ! set target limits
  !
  subroutine observation_setTargetLimits(css,var,val,crc250,irc)
    implicit none
    type(obs_session), pointer :: css !  observation session
    character*80, allocatable :: var(:)
    real, allocatable :: val(:)
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    integer :: lens,lene
    integer, external :: length
    integer :: ii,jj
    type(obs_target), pointer :: currenttarget
    type(parse_session),pointer :: plim => null()  ! parse_session pointer must be se
    character*22 :: myname="observation_setTargetLimits "
    integer :: ind(css%ntrg),inc(0:css%ntrg)
    call parse_open(plim,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from parse_open.")
       return
    end if
    css%dyn_max=1
    jj=0
    inc(0)=1
    do ii=1,css%ntrg
       currenttarget => css%trg_ptr(ii)%ptr
       if (associated(currenttarget)) then
          call chop0(currenttarget%min80,80)
          call chop0(currenttarget%max80,80)
          lens=length(currenttarget%min80,80,10)
          lene=length(currenttarget%max80,80,10)
          if (lens.ne.0) then
             call parse_parsef(plim,currenttarget%min80(1:lens),var,crc250,irc)
             if (irc.ne.0) then
                if(obs_bdeb)then
                   write(*,*)myname," Compiling target limit: '"//&
                        & currenttarget%max80(1:lens)//"'",ii
                   do jj=1,size(var)
                      write(*,'(A,A,I0,A)')myname,"     var(",jj,") = '"//&
                           & trim(var(jj))//"'"
                   end do
                end if
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from parsef.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
             css%trg_req(ii)=.true. ! target is required
             if (obs_bdeb)write(*,*)myname,' Local:',val
             css%trg_minval(ii)=parse_evalf(plim,val,crc250,irc)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from evalf.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
             css%trg_lval(1,ii)=.true.
          else
             css%trg_lval(1,ii)=.false.
          end if
          if (lene.ne.0) then
             call parse_parsef(plim,currenttarget%max80(1:lene),var,crc250,irc)
             if (irc.ne.0) then
                if(obs_bdeb)then
                   write(*,*)myname," Compiling target limit: '"//&
                        & currenttarget%max80(1:lene)//"'",ii
                   do jj=1,size(var)
                      write(*,'(A,A,I0,A)')myname,"     var(",jj,") = '"//&
                           & trim(var(jj))//"'"
                   end do
                end if
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from parsef.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
             css%trg_req(ii)=.true. ! target is required
             if (obs_bdeb)write(*,*)myname,' Local:',val
             css%trg_maxval(ii)=parse_evalf(plim,val,crc250,irc)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from evalf.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
             css%trg_lval(2,ii)=.true.
          else
             css%trg_lval(2,ii)=.false.
          end if
          if (css%trg_lval(1,ii).and.css%trg_lval(2,ii)) then ! max min available
             if (css%trg_type(ii).eq.parse_delay) then ! no descriptor or position...
                if(obs_bdeb)write(*,*)myname,' Found duplicator at:',ii
                jj=jj+1
                ind(jj)=ii
                inc(jj)=abs(nint(css%trg_maxval(ii))-nint(css%trg_minval(ii))+1)*inc(jj-1)
                css%dyn_max=css%dyn_max*inc(jj)
             end if
          end if
       end if
    end do
    call parse_close(plim,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from parse_close.")
       return
    end if
    if (allocated(css%dup_ind)) deallocate(css%dup_ind)
    if (allocated(css%dup_inc)) deallocate(css%dup_inc)
    css%ndup=jj
    allocate(css%dup_ind(css%ndup),css%dup_inc(0:css%ndup),stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Unable to allocate 'duplicates'.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    css%dup_inc(0)=1
    do jj=1,css%ndup
       css%dup_ind(jj)=ind(jj)
       css%dup_inc(jj)=inc(jj)
    end do
    return
  end subroutine observation_setTargetLimits

  !
  ! clear target stack
  !
  subroutine observation_removeTarget (css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    type(obs_target), pointer :: currenttarget => null()
    type(obs_target), pointer :: nexntarget => null()
    character*22 :: myname="observation_removeTarget "
    if(obs_bdeb)write(*,*)myname,' Entering.'
    currenttarget => css%firsttarget%next
    do while (.not.associated(currenttarget,target=css%lasttarget))
       nexntarget => currenttarget%next
       if (associated(currenttarget)) then
          css%ntarget=css%ntarget - 1
          if (currenttarget%type.eq.parse_variable)then
             css%ndyn=css%ndyn - 1
          end if
          currenttarget%next%prev => currenttarget%prev
          currenttarget%prev%next => currenttarget%next
          nullify(currenttarget%prev)
          nullify(currenttarget%next)
          nullify(currenttarget)
       end if
       currenttarget => nexntarget
    end do
    if(obs_bdeb)write(*,*)myname,' Deallocating.'
    if (allocated(css%trg80)) deallocate(css%trg80)
    if (allocated(css%trg_lent)) deallocate(css%trg_lent)
    if (allocated(css%trg_pos250)) deallocate(css%trg_pos250)
    if (allocated(css%trg_lenp)) deallocate(css%trg_lenp)
    if (allocated(css%trg_type)) deallocate(css%trg_type)
    if (allocated(css%trg_seq)) deallocate(css%trg_seq)
    if (allocated(css%trg_ind)) deallocate(css%trg_ind)
    if(obs_bdeb)write(*,*)myname,' Deallocating trg_psp.'
    if (associated(css%trg_psp)) deallocate(css%trg_psp)
    if (allocated(css%trg_descr)) deallocate(css%trg_descr)
    if (allocated(css%trg_lval)) deallocate(css%trg_lval)
    if (allocated(css%trg_minval)) deallocate(css%trg_minval)
    if (allocated(css%trg_maxval)) deallocate(css%trg_maxval)
    if (allocated(css%trg_ook)) deallocate(css%trg_ook)
    if (allocated(css%trg_orm)) deallocate(css%trg_orm)
    if (allocated(css%trg_req)) deallocate(css%trg_req)
    if (allocated(css%trg_val)) deallocate(css%trg_val)
    if (allocated(css%trg_vok)) deallocate(css%trg_vok)
    if(obs_bdeb)write(*,*)myname,' Deallocating trg_ptr.'
    if (associated(css%trg_ptr)) deallocate(css%trg_ptr)
    if (allocated(css%dyn_var)) deallocate(css%dyn_var)
    if (allocated(css%dyn_lenv)) deallocate(css%dyn_lenv)
    if (allocated(css%dyn_val)) deallocate(css%dyn_val)
    css%ntrg = 0
    css%trg_set=.false.
    if(obs_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine observation_removeTarget
  !
  ! check if current reports are valid
  !
  subroutine observation_checkTarget(css,bok,crc250,irc)
    type(obs_session), pointer :: css
    logical:: bok
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_checkTarget"
    integer :: seq, ii
    if(obs_bdeb)write(*,*)myname,' Entering.'
    if (css%ntarget .eq. 0) then ! accept all reports if there is no target...
       bok=.true.
       return
    end if
    if (css%category .eq. ksec1(6) .and. &
         & css%subcategory .eq. ksec1(7)) then
       bok=.true.
       if(obs_bdeb)write(*,*)myname,' Found BUFR:',ksec1(6),ksec1(7)
       TRG: do ii=1,css%ntrg
          if (bok.and.css%trg_lval(1,ii).or.css%trg_lval(2,ii)) then
             if (bok.and.css%trg_lval(1,ii)) bok=(css%trg_val(ii).ge.css%trg_minval(ii))
             if (bok.and.css%trg_lval(2,ii)) bok=(css%trg_val(ii).le.css%trg_maxval(ii))
          end if
          if (bok) then
             css%trg_ook(ii)=css%trg_ook(ii)+1
          else
             css%trg_orm(ii)=css%trg_orm(ii)+1
          end if
          if(obs_bdeb.and..not.bok)write(*,*)myname,' Failed check:',ii,css%trg_val(ii)
          if (.not.bok) exit TRG
       end do TRG
       if (bok) then
          css%trg_ook(0)=css%trg_ook(0)+1
       else
          css%trg_orm(0)=css%trg_orm(0)+1
       end if
    else
       bok=.false.
    end if
    if(obs_bdeb)write(*,*)myname,' Done.',ksec1(6),ksec1(7),bok
    return
  end subroutine observation_checkTarget
  !
  subroutine findDelimiter(var80,del,pos)
    character*80 :: var80
    character*1 :: del
    integer :: pos
    logical :: bdone
    !write(*,*)'findDelimiter entering:',pos,'"',del,'" ',var80
    pos=min(80,pos+1)
    bdone=(pos.eq.80)
    do while (.not.bdone)
       !write(*,*)'findDelimiter:',pos,' "', &
       !     & var80(pos:pos),'" ',ichar(var80(pos:pos))
       if (var80(pos:pos).eq.del.or.var80(pos:pos).eq.char(0)) then
          bdone=.true.
       else
          pos=min(80,pos+1)
          bdone=(pos.eq.80)
       end if
    end do
    !write(*,*)'findDelimiter pos:',pos
  end subroutine findDelimiter
  !
  !###############################################################################
  !ROUTINES FOR HANDLING STACK
  !###############################################################################
  ! Forecasts from one analysis is reportsReady at a time... (=the same parameters)
  ! Used in this way
  ! 1) observation_setFileStackLimits: make index limits of files in stack
  ! 2) observation_loopFileStack: loop over files until false return...
  !
  ! Reset indexes for looping over analysis
  !
  subroutine observation_sortFiles(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    integer :: ii
    character*22 :: myname="observation_sortFiles"
    !
    ! make array of files
    if(obs_bdeb)write(*,*)myname,' Entering.'
    call observation_sortStack(css,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from observation_sortStack.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    css%stackReady = .true.
    return
  end subroutine observation_sortFiles
  !
  subroutine observation_setModelFileId(css,mid)
    type(obs_session), pointer :: css !  current session
    integer :: mid
    css%int_val(1)=mid
    return
  end subroutine observation_setModelFileId
  !
  ! get next observation file within limits...
  !
  logical function observation_loopFileStack(css,obs_lval,obs_minval,obs_maxval,crc250,irc)
    type(obs_session), pointer :: css !  current session
    logical :: obs_lval(2)
    real :: obs_minval
    real :: obs_maxval
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_loopFileStack"
    logical :: bdone,found
    if (obs_bdeb)write(*,*)myname,' Entering:',css%sortLimitsOk,css%currentFileSortIndex,&
         & css%leftFileSortIndex,css%rightFileSortIndex
    found=.false.
    bdone=(.not. css%sortLimitsOk)
    if (bdone) then ! index is not sorted..
       css%frm(1)=css%frm(1)+css%nFileIndexes ! no sort index
    else if (css%currentFileSortIndex.lt.css%leftFileSortIndex) then ! first
       css%fok(1)=css%fok(1)+css%nFileIndexes ! we have a sort index
       css%frm(2)=css%frm(2)+(css%leftFileSortIndex-1&
            & +css%nFileIndexes-css%rightFileSortIndex) ! outside index search
    end if
    do while (.not.bdone)
       css%currentFileSortIndex=max(css%currentFileSortIndex+1,css%leftFileSortIndex)
       if (css%currentFileSortIndex.gt.css%rightFileSortIndex) then
          css%currentFileSortIndex=0
          css%currentFileIndex=0
          nullify(css%currentFile)
          bdone=.true.
       else
          css%currentFileIndex=css%fileStackInd(css%currentFileSortIndex,2)
          css%currentFile => css%fileStack(css%currentFileIndex)%ptr
          ! check if inside limits
          if (.not.((obs_lval(1).and.obs_minval.gt.css%currentFile%ind_stop) .or.&
               & (obs_lval(2).and.obs_maxval.lt.css%currentFile%ind_start)).and. &
               & .not.((css%ind_lval(1).and.css%ind_minval.gt.css%currentFile%ind_stop) .or.&
               & (css%ind_lval(2).and.css%ind_maxval.lt.css%currentFile%ind_start)) &
               &) then 
             found=.true.
             bdone=.true.
             if (obs_bdeb) write(*,*)myname,' Found:',&
                  & css%currentFileSortIndex,css%leftFileSortIndex,css%rightFileSortIndex
             css%fok(3)=css%fok(3)+1 ! within index target range
          else
             css%frm(3)=css%frm(3)+1 ! outside index target range
          end if
          css%fok(2)=css%fok(2)+1 ! within index search
       end if
    end do
    css%int_val(2)=css%currentFileIndex ! observation file id
    css%int_val(3)=0 ! message id
    css%int_val(4)=0 ! obs id
    css%int_val(5)=0 ! location id
    observation_loopFileStack=found
    if (obs_bdeb)write(*,*)myname,' Done:',found,css%currentFileSortIndex,&
         & associated(css%currentFile)
    return
  end function observation_loopFileStack
  !
  ! sort the file stack
  !
  subroutine observation_sortStack(css,crc250,irc)
    use sort
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    integer :: ii,jj,kk
    character*22 :: myname="observation_sortStack"
    real :: buff
    logical :: luff
    !
    ! make array of files
    if(obs_bdeb)write(*,*)myname,' Entering.'
    if (associated(css%fileStack)) deallocate(css%fileStack)
    if (allocated(css%fileStackSort)) deallocate(css%fileStackSort)
    if (allocated(css%fileStackInd)) deallocate(css%fileStackInd)
    if (obs_bdeb) write(*,*)myname,'Allocating sort stack:',css%nFileIndexes
    allocate(css%fileStack(css%nFileIndexes),css%fileStackSort(css%nFileIndexes,2),&
         &css%fileStackInd(css%nFileIndexes,2),stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from allocate (")
       call observation_errorappendi(crc250,css%nFileIndexes)
       call observation_errorappend(crc250,")")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    if (obs_bdeb) write(*,*)myname,'Making sort stack list:',css%nFileIndexes
    currentFile => css%firstFile%next
    ii=0
    kk=0
    do while (.not.associated(currentFile, target=css%lastFile))
       ii=ii+1
       kk=kk+1
       if (ii.le.css%nFileIndexes) then
          css%fileStack(ii)%ptr => currentFile
          if (currentFile%ind_lim) then ! requested observations present?
             css%fileStackInd(ii,1)=ii
             css%fileStackInd(ii,2)=ii
             buff=css%trg_val(css%ntrg)
             luff=css%trg_vok(css%ntrg)
             css%trg_val(css%ntrg)=currentFile%ind_start
             css%trg_vok(css%ntrg)=.true.
             !if (obs_bdeb) then
             !   write(*,*)myname,' Eval:',css%ntrg,css%trg_val(css%ntrg),&
             !        & "'"//css%ind_pt%funcStr100(1:css%ind_pt%lenf)//"'"
             !   do jj=1,css%ntrg
             !      write(*,'(X,A,A,I0,A,F0.10)')myname,'  Trg(',jj,')=',css%trg_val(jj)
             !   end do
             !end if
             if (css%ind_tset) then
                !if (obs_bdeb)write(*,*)myname,' Sort targets:',css%trg_val
                css%fileStackSort(ii,1)=parse_evalf(css%ind_pt,css%trg_val,crc250,irc)
                if (irc.ne.0) then
                   call observation_errorappend(crc250,myname)
                   call observation_errorappend(crc250," Error return from evalf.")
                   call observation_errorappendi(crc250,irc)
                   call observation_errorappend(crc250,"\n")
                   return
                end if
             else
                css%fileStackSort(ii,1)=css%trg_val(css%ntrg)
             end if
             css%trg_val(css%ntrg)=currentFile%ind_stop
             css%trg_vok(css%ntrg)=.true.
             if (css%ind_tset) then
                !if (obs_bdeb)write(*,*)myname,' Sort targets:',css%trg_val
                css%fileStackSort(ii,2)=parse_evalf(css%ind_pt,css%trg_val,crc250,irc)
                if (irc.ne.0) then
                   call observation_errorappend(crc250,myname)
                   call observation_errorappend(crc250," Error return from evalf.")
                   call observation_errorappendi(crc250,irc)
                   call observation_errorappend(crc250,"\n")
                   return
                end if
             else
                css%fileStackSort(ii,2)=css%trg_val(css%ntrg)
             end if
             !if (obs_bdeb)write(*,*)myname,'Eval:',ii,css%fileStackSort(ii,1),css%fileStackSort(ii,2),&
              !    & currentFile%ind_start,currentFile%ind_stop
             css%trg_val(css%ntrg)=buff
             css%trg_vok(css%ntrg)=luff
          else
             if (obs_bdeb)then
                write(*,*)myname,"Missing index limits in '"//&
                     & currentFile%fn250(1:currentFile%lenf)//"', ignoring file."
                write(*,*)myname,'Indexes ',currentFile%ind_lim,&
                     & currentFile%ind_start,currentFile%ind_stop
             end if
             ii=ii-1 ! ignore file...
          end if
       end if
       currentFile => currentFile%next
    end do
    if (kk.ne.css%nFileIndexes) then
       irc=944
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," System error:")
       call observation_errorappendi(crc250,css%nFileIndexes)
       call observation_errorappend(crc250,"!=")
       call observation_errorappendi(crc250,kk)
       call observation_errorappend(crc250,"\n")
       return
    end if
    if (obs_bdeb) write(*,*)myname,'Sorting:',css%nFileIndexes
    ! make sorted index (chronologically)
    css%nFileIndexes=ii
    css%nFileSortIndexes=css%nFileIndexes
    css%newnFileSortIndexes(1)=css%nFileIndexes
    css%newnFileSortIndexes(2)=css%nFileIndexes
    if (.false..and.obs_bdeb)then
       do ii=1,css%nFileSortIndexes
          write(*,'(X,A,X,A,X,I0,2(X,I0,X,F15.1))') myname,"Before: ",ii,&
               & css%fileStackInd(ii,1),css%fileStackSort(ii,1),css%fileStackInd(ii,2),css%fileStackSort(ii,2)
       end do
    end if
    call sort_heapsort1r(css%nFileIndexes,css%fileStackSort(1,1),1.0D-5, &
         & css%newnFileSortIndexes(1),css%nFileSortIndexes,css%fileStackInd(1,1),.false.)
    call sort_heapsort1r(css%nFileIndexes,css%fileStackSort(1,2),1.0D-5, &
         & css%newnFileSortIndexes(2),css%nFileSortIndexes,css%fileStackInd(1,2),.false.)
    if (.false..and.obs_bdeb)then
       write(*,*)myname,'Indexes:',css%nFileSortIndexes,css%newnFileSortIndexes
       do ii=1,css%nFileSortIndexes
          write(*,'(X,A,X,A,X,I0,2(X,I0,X,F15.1))') myname,"After: ",ii,&
               & css%fileStackInd(ii,1),css%fileStackSort(ii,1),css%fileStackInd(ii,2),css%fileStackSort(ii,2)
       end do
    end if
    ! set index range
    if(obs_bdeb)write(*,*)myname,' Done.',css%newnFileSortIndexes
    return
  end subroutine observation_sortStack
  !
  subroutine observation_stackfirst(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_stackfirst"
    css%currentFileSortIndex=0
    css%currentFileIndex=0
    css%int_val(2)=css%currentFileIndex ! observation file id
    css%int_val(3)=0 ! message id
    css%int_val(4)=0 ! obs id
    css%int_val(5)=0 ! location id
  end subroutine observation_stackfirst
  !
  subroutine observation_findStackLimits(css,ind_lval,ind_minval,ind_maxval,crc250,irc)
    use sort
    type(obs_session), pointer :: css !  current session
    logical :: ind_lval(2)
    real :: ind_minval
    real :: ind_maxval
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_findStackLimits"
    integer :: leftmin,rightmin,leftmax,rightmax
    logical :: obs_lval(2)
    real :: obs_minval
    real :: obs_maxval
    ! leftFileSortIndex refers to fileStackSort(*,2)
    ! rightFileSortIndex refers to fileStackSort(*,2)
    ! check 
    obs_lval(1)=ind_lval(1)
    obs_minval=ind_minval
    if (obs_lval(1).and.css%ind_lval(1)) then
       obs_minval=max(obs_minval,css%ind_minval)
    else if (css%ind_lval(1)) then
       obs_lval(1)=.true.
       obs_minval=css%ind_minval
    end if
    obs_lval(2)=ind_lval(2)
    obs_maxval=ind_maxval
    if (obs_lval(2).and.css%ind_lval(2)) then
       obs_maxval=min(obs_maxval,css%ind_maxval)
    else if (css%ind_lval(2)) then
       obs_lval(2)=.true.
       obs_maxval=css%ind_maxval
    end if
    if (obs_lval(1)) then
       call sort_heapsearch1r(css%nFileIndexes,css%fileStackSort(1,2),1.0D-5, &
            & css%nFileSortIndexes,css%fileStackInd(1,2),obs_minval,leftmin,rightmin)
       rightmin=max(leftmin,rightmin) ! ignore before first entry
       if (obs_bdeb) write(*,*)myname,' Minval:',obs_minval,&
            & css%fileStackSort(1,2),css%fileStackInd(1,2),&
            & leftmin,rightmin
    else
       leftmin=1
       rightmin=1
    end if
    if (obs_lval(2)) then
       call sort_heapsearch1r(css%nFileIndexes,css%fileStackSort(1,1),1.0D-5, &
            & css%nFileSortIndexes,css%fileStackInd(1,1),obs_maxval,leftmax,rightmax)
       leftmax=min(rightmax,leftmax) ! ignore after last entry
       if (obs_bdeb) write(*,*)myname,' Maxval:',obs_maxval,&
            & css%fileStackSort(1,1),css%fileStackInd(1,1),&
            & leftmax,rightmax
    else
       leftmax=css%nFileSortIndexes
       rightmax=css%nFileSortIndexes
    end if
    css%sortLimitsOk= (leftmin.le.css%nFileSortIndexes.and.rightmax.ge.1) ! check for overlap...
    if (css%sortLimitsOk) then
       css%leftFileSortIndex=min(leftmin,rightmin)
       css%rightFileSortIndex=max(leftmax,rightmax)
    else
       css%leftFileSortIndex=0
       css%rightFileSortIndex=0
    end if
    css%currentFileIndex=0
    css%int_val(2)=css%currentFileIndex ! observation file id
    css%int_val(3)=0 ! message id
    css%int_val(4)=0 ! obs id
    css%int_val(5)=0 ! location id
    if (obs_bdeb)write(*,*)myname,' Done.', css%sortLimitsOk,&
         & css%leftFileSortIndex, css%rightFileSortIndex,css%nFileIndexes
    return
  end subroutine observation_findStackLimits
  !
  ! set index transformation
  !
  subroutine observation_setTransformation(css,pit,crc250,irc)
    type(obs_session), pointer :: css !  current session
    type(parse_session), pointer :: pit
    character*250 :: crc250
    integer :: irc
    character*30 :: myname="observation_setTransformation"
    if (obs_bdeb)write(*,*)myname," Transformation:'"//pit%funcStr100(1:pit%lenf)//"'", &
         & css%ind_eset,associated(css%ind_pt),css%ind_lval(1),css%ind_lval(2)
    css%ind_pt => pit
    css%ind_tset=associated(css%ind_pt)
    if (css%ind_eset .and. css%ind_tset .and. css%ind_lval(1)) then
       css%trg_val(css%ntrg)=css%ind_minval
       css%trg_vok(css%ntrg)=.true.
       if (obs_bdeb)write(*,*)myname,' Targets:',css%trg_val
       css%ind_minval=parse_evalf(css%ind_pt,css%trg_val,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from evalf.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
    end if
    if (css%ind_eset .and. css%ind_tset .and. css%ind_lval(2)) then
       css%trg_val(css%ntrg)=css%ind_maxval
       css%trg_vok(css%ntrg)=.true.
       if (obs_bdeb)write(*,*)myname,' Targets:',css%trg_val
       css%ind_maxval=parse_evalf(css%ind_pt,css%trg_val,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from evalf.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
    end if
    return
  end subroutine observation_setTransformation
  !
  ! set the observation time span
  !
  subroutine observation_getIndex(css,trg80,exp250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*80 :: trg80
    character*250 :: exp250
    character*250 :: crc250
    integer :: irc
    trg80=css%ind_trg80
    exp250=css%ind_exp250
    return
  end subroutine observation_getIndex
  !
  subroutine observation_setIndex(css,trg80,exp250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*80 :: trg80
    character*250 :: exp250
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    type(obs_file), pointer :: stackNext => null()
    integer, external :: length
    character*22 :: myname="observation_setIndex"
    if(obs_bdeb)write(*,*)myname,' Entering.'
    css%ind_trg80=trg80
    css%ind_exp250=exp250
    call chop0(css%ind_trg80,80)
    call chop0(css%ind_exp250,250)
    css%ind_lent=length(css%ind_trg80,80,10)
    css%ind_lene=length(css%ind_exp250,250,10)
    if(obs_bdeb)write(*,*)myname,' Index:'//css%ind_trg80(1:css%ind_lent)
    css%ind_eset=(css%ind_lene.gt.0)
    if(obs_bdeb)write(*,*)myname,' Done.',css%ind_eset
    !write(*,*)myname,'Setting index:',css%ind_trg80(1:css%ind_lent)
  end subroutine observation_setIndex
  !
  ! set the observation time span
  !
  subroutine observation_getIndexLimits(css,s25,e25,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*25 :: s25,e25
    character*250 :: crc250
    integer :: irc
    integer :: irc2
    write(s25,*,iostat=irc2) css%ind_minval
    write(e25,*,iostat=irc2) css%ind_maxval
    return
  end subroutine observation_getIndexLimits
  !
  subroutine observation_setIndexLimits(css,s25,e25,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*25 :: s25,e25
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    type(obs_file), pointer :: stackNext => null()
    integer :: lens, lene
    integer, external :: length
    type(parse_session),pointer :: plim => null()  ! parse_session pointer must be se
    character*80, allocatable :: var(:)
    real, allocatable :: val(:)
    integer :: ii,jj
    character*22 :: myname="observation_setIndexLimits"
    if(obs_bdeb)write(*,*)myname,' Entering.'
    call chop0(s25,25)
    lens=length(s25,25,10)
    call chop0(e25,25)
    lene=length(e25,25,10)
    if(obs_bdeb)write(*,*)myname,' Limits:'//s25(1:lens)//" -> "//e25(1:lene)
    call parse_open(plim,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from parse_open.")
       return
    end if
    if (lens.ne.0) then
       call parse_parsef(plim,s25(1:lens),var,crc250,irc)
       if (irc.ne.0) then
          if(obs_bdeb)then
             write(*,*)myname," Compiling target limit: '"//&
                  & s25(1:lens)//"'",ii
             do jj=1,size(var)
                write(*,'(A,A,I0,A)')myname,"     var(",jj,") = '"//&
                     & trim(var(jj))//"'"
             end do
          end if
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from parsef.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       css%ind_minval=parse_evalf(plim,val,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from evalf.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       css%ind_lval(1)=.true.
    else
       css%ind_lval(1)=.false.
    end if
    if (lene.ne.0) then
       call parse_parsef(plim,e25(1:lene),var,crc250,irc)
       if (irc.ne.0) then
          if(obs_bdeb)then
             write(*,*)myname," Compiling target limit: '"//&
                  & e25(1:lene)//"'",ii
             do jj=1,size(var)
                write(*,'(A,A,I0,A)')myname,"     var(",jj,") = '"//&
                     & trim(var(jj))//"'"
             end do
          end if
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from parsef.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       css%ind_maxval=parse_evalf(plim,val,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from evalf.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       css%ind_lval(2)=.true.
    else
       css%ind_lval(2)=.false.
    end if
    call parse_close(plim,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from parse_close.")
       return
    end if
    if(obs_bdeb)write(*,*)myname,' Done.',css%ind_lval,css%ind_minval,css%ind_maxval
    return
  end subroutine observation_setIndexLimits
  !
  ! ignore labels
  !
  subroutine observation_ignorelabel(css,lab250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: lab250
    character*250 :: crc250
    integer :: irc
    type(obs_file), pointer :: currentFile => null()
    type(obs_file), pointer :: stackNext => null()
    integer, external :: length
    integer :: lenl
    character*22 :: myname="observation_ignoreLabel"
    if(obs_bdeb)write(*,*)myname,' Entering.'
    call chop0(lab250,250)
    lenl=length(lab250,250,10)
    if (lenl.eq.0) then
       css%ignmis=.false.
       css%ignuni=.false.
       css%ignden=.false.
       css%ignder=.false.
       css%ignval=.false.
       css%ignsec=.false.
    else if (lab250(1:lenl).eq."missing") then
       css%ignmis=.true.
    else if (lab250(1:lenl).eq."unit") then
       css%ignuni=.true.
    else if (lab250(1:lenl).eq."description") then
       css%ignden=.true.
    else if (lab250(1:lenl).eq."descriptor") then
       css%ignder=.true.
    else if (lab250(1:lenl).eq."value") then
       css%ignval=.true.
    else if (lab250(1:lenl).eq."section") then
       css%ignsec=.true.
    else if (lab250(1:lenl).eq."array") then
       css%ignarr=.true.
    end if
    if(obs_bdeb)write(*,*)myname,' Done.'
  end subroutine observation_ignorelabel
  !
  ! set stack file limits
  !
  subroutine observation_setFileStackLimits(css,ind_lval,ind_minval,ind_maxval,crc250,irc)
    type(obs_session), pointer :: css !  current session
    logical :: ind_lval(2)
    real :: ind_minval,ind_maxval
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_setFileStackLimits"
    ! make sure file stack is sorted
    if (.not.css%stackReady) then
       call observation_sortStack(css,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_sortStack.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       css%stackReady = .true.
    end if
    ! find index start/stop...
    call observation_findStackLimits(css,ind_lval,ind_minval,ind_maxval,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from observation_makeStackLimits.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    css%currentFileSortIndex=0 ! reset index
    return
  end subroutine observation_setFileStackLimits
  !
  ! set index limits directly
  !
  subroutine observation_setIndexLimitsRaw(css,ind_lval,ind_minval,ind_maxval)
    type(obs_session), pointer :: css !  current session
    logical :: ind_lval(2)
    real :: ind_minval,ind_maxval
    character*22 :: myname="observation_setIndexLimitsRaw"
    ! set limits
    css%ind_lval(1)=ind_lval(1)
    css%ind_lval(2)=ind_lval(2)
    css%ind_minval=ind_minval
    css%ind_maxval=ind_maxval
    return
  end subroutine observation_setIndexLimitsRaw
  !
  !
  subroutine observation_getIndexLimitsRaw(css,ind_lval,ind_minval,ind_maxval)
    type(obs_session), pointer :: css !  current session
    logical :: ind_lval(2)
    real :: ind_minval,ind_maxval
    character*22 :: myname="observation_getIndexLimitsRaw"
    ind_lval(1)=css%ind_lval(1)
    ind_lval(2)=css%ind_lval(2)
    ind_minval=css%ind_minval
    ind_maxval=css%ind_maxval
    return
  end subroutine observation_getIndexLimitsRaw
  !
  !###############################################################################
  ! LOCATION ROUTINES
  !###############################################################################
  ! initialise the MODEL location
  !
  subroutine observation_locinit(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="observation_locinit"
    ! initialise chain
    if (.not.associated(css%firstLoc)) then
       allocate(css%firstLoc,css%lastLoc, stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250,"Unable to allocate 'firstLoc/lastLoc'.")
          call observation_errorappend(crc250,"\n")
          return
       end if
       css%firstLoc%next => css%lastLoc
       css%lastLoc%prev => css%firstLoc
       css%nloc=0
       css%locReady=.false.
    end if
  end subroutine observation_locinit
  !
  ! clear the location stack
  !
  subroutine observation_clearLocStack(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(obs_location), pointer :: currentLoc => null()
    type(obs_location), pointer :: locNext => null()
    character*25 :: myname="observation_clearLocStack"
    integer :: ii, lens
    integer, external :: length
    if(obs_bdeb)write(*,*)myname,' Entering.'
    call observation_locinit(css,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from locinit.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    ! delete any existing location-entries
    currentLoc => css%firstLoc%next
    do while (.not.associated(currentLoc,target=css%lastLoc))
       locNext => currentLoc%next
       call observation_deleteLoc(css,currentLoc,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from locrmitem.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       currentLoc => locNext
    end do
    if (css%nloc .ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," System error:")
       call observation_errorappendi(crc250,css%nloc)
       call observation_errorappend(crc250,"\n")
       irc=940
       return
    end if
    if(obs_bdeb)write(*,*)myname,' Done.'
  end subroutine observation_clearLocStack
  !
  ! delete loc
  !
  subroutine observation_deleteLoc (css,loc, crc250,irc)
    type(obs_session), pointer :: css !  current session
    type(obs_location), pointer :: loc
    character*250 :: crc250
    integer :: irc  ! error return code (0=ok)
    character*25 :: myname="observation_deleteLoc"
    if (associated(loc)) then
       css%nloc = css%nloc - 1
       loc%next%prev => loc%prev
       loc%prev%next => loc%next
       if (allocated(loc%trg_val)) deallocate(loc%trg_val)
       if (allocated(loc%trg_vok)) deallocate(loc%trg_vok)
       deallocate(loc)
    end if
    return
  end subroutine observation_deleteLoc
  !
  ! Add a "location", specified by target variables...
  !
  subroutine observation_locpushTarget(css,locid,bok,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: locid
    logical :: bok
    character*250 :: crc250
    integer :: irc
    type(obs_location),pointer :: newLoc
    character*80 :: var80
    real(KIND=8), allocatable :: values(:)
    integer :: ii,yy,mm,dd,hh,mi
    real:: sec
    integer :: lenc
    integer, external :: length
    character*25 :: myname="observation_locpushTarget"
    if(obs_bdeb)write(*,*)myname,' Entering.'
    ! initialise location stack
    if (css%nloc.eq.0) then
       css%locoffset=locid-1
    end if
    !
    call observation_locinit(css,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from locinit.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    ! create new location-item
    allocate(newLoc,stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Unable to allocate new location.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    newLoc%ntrg=css%ntrg
    allocate(newLoc%trg_val(newLoc%ntrg),newLoc%trg_vok(newLoc%ntrg),stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Unable to allocate newLoc%var.")
       call observation_errorappendi(crc250,newLoc%ntrg)
       call observation_errorappend(crc250,"\n")
       return
    end if
    newLoc%locid=locid
    do ii=1,newLoc%ntrg
       newLoc%trg_val(ii)=css%trg_val(ii)
       newLoc%trg_vok(ii)=css%trg_vok(ii)
    end do
    newLoc%bok=bok
    ! push onto stack
    css%nloc=css%nloc + 1
    newLoc%prev => css%lastLoc%prev
    newLoc%next => css%lastLoc
    newLoc%prev%next => newLoc
    newLoc%next%prev => newLoc
    css%locReady=.false.
    if (css%nloc+css%locoffset .ne. locid) then
       irc=346
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Non-sequential locid:")
       call observation_errorappendi(crc250,locid)
       call observation_errorappend(crc250,"<>")
       call observation_errorappendi(crc250,css%nloc+css%locoffset)
       call observation_errorappend(crc250,"\n")
       return
    end if
    if(obs_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine observation_locpushTarget
  !
  subroutine observation_makeLocList(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    type(obs_location), pointer :: currentLoc => null()
    character*25 :: myname="observation_makeLocList"
    integer :: ii
    if(obs_bdeb)write(*,*)myname,"ind_pe:",associated(css%ind_pe),css%sid
    if (associated(css%firstLoc).and..not.css%locready.and.css%nloc.gt.0) then
       if (allocated(css%locdata)) deallocate(css%locdata)
       allocate(css%locdata(css%nloc),stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Unable to allocate locid,lat,lon.")
          call observation_errorappendi(crc250,css%nloc)
          call observation_errorappend(crc250," , ")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       ii=0
       currentLoc => css%firstLoc%next
       do while (.not.associated(currentLoc,target=css%lastLoc))
          ii=ii+1
          css%locdata(ii)%ptr=>currentLoc
          css%locdata(ii)%ptr%iloc=ii
          currentLoc => currentLoc%next
       end do
       css%locReady=.true.
    end if
    return
  end subroutine observation_makeLocList
  !
  !###############################################################################
  ! ROUTINES FOR REPORTING OBSERVATIONS TO USER
  !###############################################################################
  !
  ! put next BUFR-message in memory
  !
  subroutine observation_getNextLoc(css,bok,crc250,irc)
    type(obs_session), pointer :: css !  current session
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    integer :: cnt
    character*22 :: myname="observation_getNextLoc"
    if(obs_bdeb)write(*,*)myname,' Entering.',bok
    if(obs_bdeb)write(*,*)myname,"ind_pe:",associated(css%ind_pe),css%sid
    ! get next observation from file
    if (.not.css%stackReady) then
       call observation_sortStack(css,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_sortStack.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       call observation_stackfirst(css,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_stackfirst.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       css%currentFileSortIndex=1
       css%stackReady = .true.
    end if
    if(obs_bdeb)write(*,*)myname,' OOK.',css%currentFile%ook
    cnt=0
    ! loop until we have valid message or EOF
    LOOP : do
       do while (css%msg%vobs .eq. 0 .and. bok) ! bok=.false. -> end of file
          ! read next message (can contain several observations)
          call observation_getMsgObs(css,bok,crc250,irc)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from getMsgObs.")
             return
          end if
          css%msg%check=.false. ! redo message check
       end do
       if (.not.css%msg%check .and. css%msg%nobs .ne. 0 .and. bok) then
          ! apply the observation filter on the whole message (possibly several observations)
          call observation_checkMsgObs(css,crc250,irc)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from checkMsgObs.")
             return
          end if
          css%msg%check=.true. ! message check completed
       end if
       if (css%msg%vobs .ne. 0 .and. bok) then
          ! return next valid observation from the message...
          if (observation_popMsgObs(css,crc250,irc)) then
             exit LOOP ! got a valid observation
          end if
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from popObs.")
             return
          end if
       else if (.not. bok) then ! end of file
          exit LOOP
       end if
    end do LOOP
    if(obs_bdeb)write(*,*)myname,' OOK.',css%currentFile%ook
    if(obs_bdeb)write(*,*)myname,' Done.',bok,cnt,isubset,nsubset
    return
  end subroutine observation_getNextLoc
  !
  ! put valid observations from message into the location chain
  !
  subroutine observation_getMsgObs(css,bok,crc250,irc)
    type(obs_session), pointer :: css !  current session
    logical :: bok           ! successful get (not EOF)
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_getMsgObs"
    integer :: cnt, mcnt, ii, jj
    integer :: tcnt=0
    logical :: bbok
    mcnt=0
    MSG: do
       ! increment isubset
       if(obs_bdeb)write(*,'(X,A,X,A,3(I0,A))')myname,' Incrementing isubset ',&
            &isubset,' -> ',isubset+1,' (',nsubset,')'
       isubset=isubset+1
       if (isubset > nsubset) then ! read next message into memory
          if(obs_bdeb)write(*,*)myname,' Reading message.',bok
          call observation_autoMessage(css,bok,crc250,irc) ! always returns isubset=1, nsubset=ksec3(3)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from observation_autoMessage.")
             call observation_errorappendi(crc250,irc)
             call observation_errorappend(crc250,"\n")
             return
          end if
          if (nsubset.gt.0.and.bok) call observation_updateObsCnt(css,nsubset)
          css%msg%nobs=0 ! number of obs
          css%msg%vobs=0 ! remaining valid obs
          css%msg%iobs=0 ! current obs
          if(obs_bdeb)write(*,*)myname,' Read message, EOF:',bok,isubset,nsubset
          if (.not.bok) exit MSG
       else
          bok=.true.
       end if
       if(obs_bdeb)write(*,*)myname,' Checking obs.',bok
       if (bok) then
          cnt=0
          OBS : DO ! loop over message observations
             css%int_val(4)=css%int_val(4)+1 ! obs id
             if (observation_checkObs(css,bbok,crc250,irc)) then
                cnt=cnt+1
                mcnt=mcnt+1
                tcnt=tcnt+1
                css%msg%nobs=css%msg%nobs+1
                if(obs_bdeb)write(*,*)myname,' Found obs.',bbok,cnt,css%msg%nobs,css%msg%cobs
                ! store location in message-location chain and loop...
                ! check if we must allocate more memory
                css%msg => observation_allocateMsg(css,css%msg,crc250,irc)
                if (irc.ne.0) then
                   call observation_errorappend(crc250,myname)
                   call observation_errorappend(crc250," Error return from observation_checkMsg.")
                   call observation_errorappendi(crc250,irc)
                   call observation_errorappend(crc250,"\n")
                   return
                end if
                if(obs_bdeb)write(*,*)myname,' Setting msg obs.',css%msg%nobs,&
                     & allocated(css%msg%trg_val),css%msg%ctrg,css%msg%cobs
                do ii=1,css%msg%ctrg
                   css%msg%trg_val(ii,css%msg%nobs)=css%trg_val(ii)
                   css%msg%trg_vok(ii,css%msg%nobs)=css%trg_vok(ii)
                   if (obs_bdeb) then
                      if (css%trg_val(ii).gt.1.0D10) then
                         write(*,*)myname,' xxxxxxxxxxxxxx INVALID obs:',&
                              & css%msg%nobs,ii,&
                              & "'"//css%trg80(ii)(1:css%trg_lent(ii))//"'", &
                              & css%trg_val(ii),css%trg_vok(ii),bbok
                      end if
                   end if
                end do
                css%msg%trg_set(css%msg%nobs)=bbok ! is obs valid?
                if (bbok) then
                   css%msg%vobs=css%msg%vobs+1
                end if
                if(obs_bdeb)write(*,*)myname,' CheckObs Read message.',bbok
             else ! no more locations in message
                exit OBS
             end if
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from observation_checkObs.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
          end do OBS
          if (cnt.gt.0) call observation_updateLocCnt(css,cnt)
       end if
       if (css%msg%nobs.ne.0.or..not.bok) exit MSG ! valid obs in matrix
    end do MSG
    if(obs_bdeb)write(*,*)myname,' OOK.',css%currentFile%ook
    ! if (bok) write(*,*)myname,' Added obs:',mcnt,tcnt,isubset,nsubset
    if(obs_bdeb)write(*,*)myname,' Done.',bok,mcnt,isubset,nsubset
    return
  end subroutine observation_getMsgObs
  ! check that message has enough memory
  function observation_allocateMsg(css,msg,crc250,irc)
    type(obs_message), pointer :: observation_allocateMsg
    type(obs_session), pointer :: css !  current session
    type(obs_message), pointer :: msg
    logical :: bok           ! successful get (not EOF)
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_allocateMsg"
    type(obs_message), pointer :: newmsg => null()
    integer :: cnt, ii, jj
    logical :: bbok
    if(obs_bdeb)write(*,*)myname,"ind_pe:",associated(css%ind_pe),css%sid
    if (css%msg%nobs.gt.css%msg%cobs) then ! allocate more memory
       allocate(newmsg,stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Unable to allocate newmsg:")
          call observation_errorappendi(crc250,newmsg%nobs)
          call observation_errorappendi(crc250,newmsg%cobs)
          call observation_errorappend(crc250,"\n")
          return
       end if
       newmsg%nobs=css%msg%nobs
       newmsg%vobs=css%msg%vobs
       newmsg%cobs=2*(css%msg%nobs)
       newmsg%ctrg=max(css%msg%ctrg,css%ntrg)
       allocate(newmsg%trg_val(newmsg%ctrg,newmsg%cobs),&
            & newmsg%trg_vok(newmsg%ctrg,newmsg%cobs),&
            & newmsg%trg_set(newmsg%cobs),newmsg%trg_res(newmsg%cobs),&
            & stat=irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Unable to allocate msg:")
          call observation_errorappendi(crc250,newmsg%ctrg)
          call observation_errorappendi(crc250,newmsg%cobs)
          call observation_errorappend(crc250,"\n")
          return
       end if
       if (allocated(css%msg%trg_val)&
            & .and.allocated(css%msg%trg_vok)&
            & .and.allocated(css%msg%trg_set)&
            & .and.allocated(css%msg%trg_res)) then
          do jj=1,css%msg%nobs-1
             do ii=1,css%msg%ctrg
                newmsg%trg_val(ii,jj)=css%msg%trg_val(ii,jj)
                newmsg%trg_vok(ii,jj)=css%msg%trg_vok(ii,jj)
             end do
             newmsg%trg_set(jj)=css%msg%trg_set(jj)
             newmsg%trg_res(jj)=0.0D0
          end do
          if (allocated(css%msg%trg_val)) deallocate(css%msg%trg_val)
          if (allocated(css%msg%trg_vok)) deallocate(css%msg%trg_vok)
          if (allocated(css%msg%trg_set)) deallocate(css%msg%trg_set)
          if (allocated(css%msg%trg_res)) deallocate(css%msg%trg_res)
       else if (obs_bdeb) then
          write(*,*)myname,' Not allocated: msg%trg_* ',&
               & css%msg%nobs,css%msg%cobs
       end if
       if (associated(css%msg)) deallocate(css%msg,stat=irc)
       observation_allocateMsg => newmsg
    else
       observation_allocateMsg => css%msg
    end if
    return
  end function observation_allocateMsg
  !
  ! check observations in message simulaneosul using observation filter
  !
  subroutine observation_checkMsgObs(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_checkMsgObs"
    integer :: ii
    logical :: bok
    ! loop over observations
    if (css%flt_set) then ! check if we have an observation filter...
       ! should probably reset the parser here if msg-functions are implemented...
       if (obs_bdeb)then
          write(*,*)myname,' Evaluating filter:',associated(css%psf),&
               & css%msg%ctrg,css%msg%cobs,&
               & size(css%msg%trg_val),size(css%msg%trg_set),size(css%msg%trg_res),&
               & allocated(css%msg%trg_val),allocated(css%msg%trg_set),&
               & allocated(css%msg%trg_res)
       end if
       call parse_evala(css%psf,css%msg%ctrg,css%msg%cobs,css%msg%nobs, &
            & css%msg%trg_val,css%msg%trg_set,css%msg%trg_res,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from evala.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       if (obs_bdeb)write(*,*)myname,' Looping over msg:',css%msg%nobs
       do ii=1,css%msg%nobs
          if (css%msg%trg_set(ii)) then
             ! evaluate filter
             bok=(nint(css%msg%trg_res(ii)).ne.0) ! NB bok is local, reject obs using trg_set->.false.
             if (obs_bdeb)write(*,*)myname,'Returned:',css%msg%trg_res(ii),bok
             if (bok) then
                css%currentFile%ook(5)=css%currentFile%ook(5)+1
             else
                css%currentFile%orm(5)=css%currentFile%orm(5)+1 ! search failed
                css%msg%vobs=css%msg%vobs-1
                css%msg%trg_set(ii)=.false. ! reject observation
             end if
          end if
       end do
    end if
    return
  end subroutine observation_checkMsgObs
  !
  ! pop next valid message obs to the session trg_val
  !
  logical function observation_popMsgObs(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_popMsgObs"
    logical :: bok
    integer :: ii
    bok=(css%msg%vobs.gt.0)
    if (bok) then
       css%msg%iobs=css%msg%iobs+1
       do while (css%msg%iobs.le.css%msg%nobs)
          css%int_val(5)=css%int_val(5)+1 ! location id
          if (css%msg%trg_set(css%msg%iobs)) then ! passed msg-check?
             css%msg%vobs=css%msg%vobs-1
             do ii=1,css%msg%ctrg
                css%trg_val(ii)=css%msg%trg_val(ii,css%msg%iobs)
                css%trg_vok(ii)=css%msg%trg_vok(ii,css%msg%iobs)
                if (obs_bdeb) then                
                   if (css%trg_val(ii).gt.1.0D10) then
                      write(*,*)myname,' yyyyyyyyyyyyyyyy Invalid obs:',&
                           & css%msg%iobs,ii,css%trg_val(ii),css%msg%trg_set(css%msg%iobs)
                   end if
                end if
             end do
             ! recalculate internal variables
             do ii=1,css%ntarget
                select case (css%trg_type(ii))
                case (parse_internal)
                   if (obs_bdeb)write(*,*)myname,' Internals:',css%int_val
                   css%trg_val(ii)=parse_evalf(css%trg_psp(ii)%ptr,css%int_val,crc250,irc)
                   if (irc.ne.0) then
                      call observation_errorappend(crc250,myname)
                      call observation_errorappend(crc250," Error return from evalf.")
                      call observation_errorappendi(crc250,irc)
                      call observation_errorappend(crc250,"\n")
                      return
                   end if
                   css%trg_vok(ii)=.true.
                   if (obs_bdeb)write(*,*)myname,' Internal:',&
                        & ii,css%trg_val(ii)
                end select
             end do
             observation_popMsgObs=.true.
             return
          else
             css%msg%iobs=css%msg%iobs+1
          end if
       end do
       if (css%msg%vobs.ne.0) then
          if (obs_bdeb) then
             write(*,*) myname,'Obs count=',css%msg%nobs,css%msg%vobs,css%msg%iobs
             do ii=1,css%msg%nobs
                write(*,*)myname,'Obs:',ii,css%msg%trg_set(ii)
             end do
          end if
          irc=844
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," System error.")
          call observation_errorappendi(crc250,css%msg%vobs)
          call observation_errorappend(crc250,"\n")
          return
       end if
    end if
    observation_popMsgObs=.false.
    return
  end function observation_popMsgObs
  !
  subroutine observation_setfilter(css,flt,crc250,irc)
    implicit none
    type(obs_session), pointer :: css !  current session
    character*(*) :: flt
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    character*22 :: myname="observation_setfilter"
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       css%flt250=trim(flt)
       call chop0(css%flt250,250)
       css%lenf=length(css%flt250,250,10)
       if(obs_bdeb)write(*,*)myname,"Filter:'"//css%flt250(1:css%lenf)//"'",irc
    end if
    return
  end subroutine observation_setfilter
  !
  !
  subroutine observation_compileFilter(css,crc250,irc)
    implicit none
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    integer :: jj
    character*22 :: myname="observation_ompileFilter"
    if (css%lenf.ne.0) then
       call parse_open(css%psf,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from parse_open.")
          return
       end if
       if(obs_bdeb)write(*,*)myname,"Parsing filter: '"//css%flt250(1:css%lenf)//"'",size(css%trg80)
       call parse_parsef(css%psf,css%flt250(1:css%lenf),css%trg80,crc250,irc)
       if (irc.ne.0) then
          if(obs_bdeb)then
             write(*,*)myname,"Unable to parse:'"//css%flt250(1:css%lenf)//"'"
             write(*,*)myname,' nvar:',css%ntrg
             do jj=1,css%ntrg
                write(*,*) myname,' var:',jj,css%trg80(jj)(1:css%trg_lent(jj))
             end do
          end if
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from parsef.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       call parse_used(css%psf,css%trg_req)
       css%flt_set=.true.
    end if
    if(obs_bdeb)write(*,*)myname,"Done."
    return
  end subroutine observation_compileFilter
  !
  subroutine observation_getfilter(css,flt,crc250,irc)
    implicit none
    type(obs_session), pointer :: css !  current session
    character*(*) :: flt
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_getfilter"
    if (associated(css)  .and. .not.associated(css,target=lastSession)) then
       flt=css%flt250(1:css%lenf)
       if(obs_bdeb)write(*,*)myname,"Filter:'"//css%flt250(1:css%lenf)//"'",irc
    end if
    return
  end subroutine observation_getfilter
  !
  !###############################################################################
  ! REPORT PROCESSING
  !###############################################################################
  !
  ! remove report generation-item
  !
  subroutine observation_clearReports(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    type(obs_reportitem), pointer :: item, nextItem
    css%currentReport => css%firstReport%next
    do while (.not.associated(css%currentReport,target=css%lastReport))
       if (associated(css%currentReport%firstItem)) then
          item=>css%currentReport%firstItem%next
          do while (.not.associated(item,target=css%currentReport%lastItem))
             nextItem=>item%next;
             deallocate(item)
             item=>nextItem;
          end do
       end if
       css%firstReport%next => css%currentReport%next
       css%currentReport%next%prev => css%firstReport
       deallocate(css%currentReport)
       css%currentReport=>css%firstReport%next
    end do
    css%nsubset=0
    nullify(css%currentReport)
  end subroutine observation_clearReports
  !
  subroutine observation_createReport(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    type(obs_report), pointer :: newReport
    character*22 :: myname="observation_createReport"
    allocate(newReport,stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Unable to allocate 'new report'.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    allocate(newReport%firstItem,newReport%lastitem,stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Unable to allocate 'first/lastitem'.")
       call observation_errorappend(crc250,"\n")
       return
    end if
    newReport%firstitem%next => newReport%lastitem
    newReport%lastitem%prev => newReport%firstitem
    newReport%prev => css%lastReport%prev
    newReport%next => css%lastReport
    css%lastReport%prev%next => newReport
    css%lastReport%prev => newReport
    css%currentReport => newReport
    css%nsubset = css%nsubset + 1
  end subroutine observation_createReport
  !
  subroutine observation_addReportItem(css,buff250,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: buff250
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    type(obs_reportItem), pointer :: newItem
    character*22 :: myname="observation_addReportItem"
    !write(*,*)myname,' Entering.',irc,buff250(1:10)
    allocate(newItem,stat=irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"observation_addReportItem")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    newItem%desc250=buff250
    newItem%prev => css%currentReport%lastItem%prev
    newItem%next => css%currentReport%lastItem
    css%currentReport%lastItem%prev%next => newItem
    css%currentReport%lastItem%prev => newItem
    css%currentReport%nitem = css%currentReport%nitem + 1
    !write(*,*)myname,' Done.',irc
  end subroutine observation_addReportItem
  !
  ! Read next message into memory, open/close file automatically
  !
  subroutine observation_autoMessage(css,bok,crc250,irc)
    type(obs_session), pointer :: css !  current session
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_autoMessage"
    !
    ! check if file is open, if not open it
    !
    bok=.true.
    if (.not.fopen) then
       call observation_openFile(css,bok,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_openFile.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       if (.not.bok) return
    end if
    !
    ! read next observation, make reports
    !
    call observation_readMessage(css,bok,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from observation_readObservation.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    !
    ! if last observation, close file
    !
    if (.not.bok) then
       call observation_closeFile(css,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_closeFile.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
    end if
    return
  end subroutine observation_autoMessage
  !
  ! make raw-array
  !
  subroutine observation_getArrayLen(css,maxarr,bok,crc250,irc)
    type(obs_session), pointer :: css
    integer :: maxarr        ! max number of array elements
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    if (isubset > nsubset) then
       bok=.false.
       maxarr=1
    else if (css%ignarr) then
       bok=.true.
       maxarr=1
    else
       bok=.true.
       maxarr = KTDEXL
    end if
    return
  end subroutine observation_getArrayLen
  subroutine observation_getArray(css,maxarr,narr,arr,bok,crc250,irc)
    type(obs_session), pointer :: css
    integer :: maxarr        ! max number of array elements
    integer :: narr          ! number of array elements
    real*8 :: arr(maxarr)      ! bufr array
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    integer, external :: length
    integer :: lenb,len0,len1,len2,len3
    character*50 :: s0,s1,s2,s3
    integer :: ii,ipos
    narr=0
    if (isubset > nsubset) then
       bok=.false.
    else if (css%ignarr) then
       bok=.true.
    else
       bok=.true.
       DO II=1,KTDEXL
          IPOS=II+(isubset-1)*KEL
          if (values(ipos).eq.RVIND) then
             narr=narr+1
             arr(narr)=values(ipos)
          else if (.not.css%ignval) then
             narr=narr+1
             arr(narr)=values(ipos)
          end if
       end do
    end if
    return
  end subroutine observation_getArray
  !
  ! Make report item
  !
  subroutine observation_getReportLen(css,maxrep,bok,crc250,irc)
    type(obs_session), pointer :: css
    integer :: maxrep        ! max number of reports
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    !
    integer, external :: length
    integer :: lenb,len0,len1,len2,len3
    character*50 :: s0,s1,s2,s3
    integer :: ii,jj,ipos,i,j
    real :: rlon1,rlat1,rlon2,rlat2
    integer :: iktype,idd,id
    CHARACTER*9 :: CIDENT
    character*22 :: myname="observation_getReportLen"
    maxrep=0
    if (isubset > nsubset) then
       bok=.false.
    else
       maxrep=maxrep+4
       !
       if (.not. css%ignsec) then
          maxrep=maxrep+16
          ! section 2
          !
          IF(KSUP(2).LE.1) THEN
             !WRITE(*,*)  'Prtkey : RDB key not defined in section 2.'
          else
             maxrep=maxrep+1
             IKTYPE=0
             IF(KEY(2).EQ.2) IKTYPE=2
             IF(KEY(2).EQ.3) IKTYPE=2
             IF(KEY(2).EQ.12)IKTYPE=2
             IF(KEY(2).EQ.08)IKTYPE=2
             IF(IKTYPE.EQ.0.AND.KSUP(6).GT.1) IKTYPE=2
             IF(IKTYPE.EQ.2) THEN
                IF(KEY(2).EQ.2.OR.KEY(2).EQ.3 &
                     & .OR.KEY(2).EQ.12) THEN
                   maxrep=maxrep+32
                ELSE
                   maxrep=maxrep+29
                END IF
             end if
          end if
          !
          ! section 3
          !
          maxrep=maxrep+4
       end if
       if (.not.css%ignder) maxrep=maxrep+KTDLEN
       if (.not.css%ignden) maxrep=maxrep+KTDEXL
       if (.not.css%ignuni) maxrep=maxrep+KTDEXL
       if (.not.css%ignval) maxrep=maxrep+2*KTDEXL
    end if
    !write(*,*)myname,' Done.',irc
  end subroutine observation_getReportLen
  subroutine observation_getReport(css,maxrep,nrep,rep250,bok,crc250,irc)
    type(obs_session), pointer :: css
    integer :: maxrep        ! max number of reports
    integer :: nrep          ! number of reports
    character*250 :: rep250(maxrep)  ! bufr report
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    !
    character*250 :: buff250
    integer, external :: length
    integer :: lenb,len0,len1,len2,len3
    character*50 :: s0,s1,s2,s3
    integer :: ii,jj,ipos,i,j
    real :: rlon1,rlat1,rlon2,rlat2
    integer :: iktype,idd,id
    CHARACTER*9 :: CIDENT
    type(obs_target), pointer :: currenttarget => null()
    logical :: bbok           ! was get successful?
    integer :: seq
    real :: val
    character*22 :: myname="observation_getReport"
    nrep=0
    if (isubset > nsubset) then
       bok=.false.
    else
       !write(*,*)myname,'Report A:',isubset
       write(s0,'(A,I0)') 'subset'//sep,isubset;call chop0(s0,50);
       len0=length(s0,50,10) ! subset/report identification
       if (.not. css%ignsec) then
          nrep=min(nrep+1,maxrep)
          WRITE(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '0'//sep//'Length of section 0 (bytes)'//sep,KSEC0(1)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '0'//sep//'Total length of Bufr message (bytes)'//sep,KSEC0(2)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '0'//sep//'Bufr Edition number'//sep,KSEC0(3)," "
          !
          ! section 1
          !
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Length of section 1 (bytes)'//sep,KSEC1( 1)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Bufr Edition number'//sep,KSEC1( 2)," "
          nrep=min(nrep+1,maxrep)
          if(ksec1(2).ge.3) then
             write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
                  & '1'//sep//'Originating sub-centre'//sep,KSEC1(16)," "
          end if
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Originating centre'//sep,KSEC1( 3)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Update sequence number'//sep,KSEC1( 4)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Flag (presence of section 2)'//sep,KSEC1( 5)," "
       end if
       call observation_getType(ksec1(6),ksec1(7),s2,s3,crc250,irc) 
       call chop0(s2,50); len2=length(s2,50,10)
       call chop0(s3,50); len3=length(s3,50,10)
       nrep=min(nrep+1,maxrep)
       write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
            & '1'//sep//'Bufr message type'//sep,KSEC1( 6)," "
       if (len2.ne.0) then
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,A,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Bufr message type description'//sep,S2(1:len2)," "
       end if
       nrep=min(nrep+1,maxrep)
       write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
            & '1'//sep//'Bufr message subtype'//SEP,KSEC1( 7)," "
       if (len3.ne.0) then
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,A,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Bufr message subtype description'//SEP,s3(1:len3)," "
       end if
       if (.not. css%ignsec) then
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Version number of local table'//SEP,KSEC1( 8)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Year'//SEP,KSEC1( 9)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Month'//SEP,KSEC1(10)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Day'//SEP,KSEC1(11)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Hour'//SEP,KSEC1(12)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Minute'//SEP,KSEC1(13)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Version number of Master table'//SEP,KSEC1(15)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '1'//sep//'Bufr Master table'//SEP,KSEC1(14)," "
          !
          ! section 2
          !
          IF(KSUP(2).LE.1) THEN
             !WRITE(*,*)  'Prtkey : RDB key not defined in section 2.'
          else
             nrep=min(nrep+1,maxrep)
             write(rep250(nrep),'(A,I9)')s0(1:len0)//sep//'section'//sep//&
                  & '2'//sep//'Length of section 2'//sep, KEY(1)
             IKTYPE=0
             IF(KEY(2).EQ.2) IKTYPE=2
             IF(KEY(2).EQ.3) IKTYPE=2
             IF(KEY(2).EQ.12)IKTYPE=2
             IF(KEY(2).EQ.08)IKTYPE=2
             IF(IKTYPE.EQ.0.AND.KSUP(6).GT.1) IKTYPE=2
             IF(IKTYPE.EQ.2) THEN
                IF(KEY(2).EQ.2.OR.KEY(2).EQ.3 &
                     & .OR.KEY(2).EQ.12) THEN
                   RLAT1=(KEY(11)-9000000)/100000.
                   RLON1=(KEY(10)-18000000)/100000.
                   RLAT2=(KEY(13)-9000000)/100000.
                   RLON2=(KEY(12)-18000000)/100000.
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'RDB data type'//sep, KEY(2)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'RDB data subtype'//sep, KEY(3)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Year'//sep, KEY(4)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Month'//sep, KEY(5)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Day'//sep, KEY(6)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Hour'//sep, KEY(7)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Minute'//sep, KEY(8)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Second'//sep, KEY(9)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,F0.2,A)')s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Latitude  1'//sep, RLAT1," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,F0.2,A)')s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Longitude 1'//sep, RLON1," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,F0.2,A)')s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Latitude  2'//sep, RLAT2," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,F0.2,A)')s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Longitude 2'//sep, RLON2," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Number of observations'//sep, KEY(14)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Identifier'//sep, KEY(15)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Total Bufr message length'//sep, KEY(25)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Day    (RDB insertion'//sep, KEY(26)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Hour   (RDB insertion'//sep, KEY(27)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Minute( (RDB insertion'//sep, KEY(28)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Second (RDB insertion'//sep, KEY(29)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Day    (MDB arrival'//sep, KEY(30)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Hour   (MDB arrival'//sep, KEY(31)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Minute (MDB arrival'//sep, KEY(32)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Second (MDB arrival'//sep, KEY(33)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Correction number'//sep, KEY(34)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Part of message'//sep, KEY(35)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Correction number'//sep, KEY(37)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Part of message'//sep, KEY(38)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Correction number'//sep, KEY(40)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Part of message'//sep, KEY(41)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Correction number'//sep, KEY(43)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Part of message'//sep, KEY(44)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Quality control % conf'//sep, KEY(46)," "
                ELSE
                   RLAT1=(KEY(11)-9000000)/100000.
                   RLON1=(KEY(10)-18000000)/100000.
                   IDD=0
                   CIDENT=' '
                   DO ID=16,24
                      IDD=IDD+1
                      CIDENT(IDD:IDD)=CHAR(KEY(ID))
                   end do
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'RDB data type'//sep, KEY(2)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'RDB data subtype'//sep, KEY(3)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Year'//sep, KEY(4)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Month'//sep, KEY(5)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Day'//sep, KEY(6)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Hour'//sep, KEY(7)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Minute'//sep, KEY(8)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Second'//sep, KEY(9)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,F0.2,A)')s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Latitude  1', RLAT1," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,F0.2,A)')s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Longitude 1', RLON1," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,A)')s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Identifier'//sep, CIDENT," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Total Bufr message length'//sep, KEY(25)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Day    (RDB insertion'//sep, KEY(26)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Hour   (RDB insertion'//sep, KEY(27)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Minute (RDB insertion'//sep, KEY(28)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Second (RDB insertion'//sep, KEY(29)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Day    (MDB arrival'//sep, KEY(30)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Hour   (MDB arrival'//sep, KEY(31)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Minute (MDB arrival'//sep, KEY(32)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Second (MDB arrival'//sep, KEY(33)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Correction number'//sep, KEY(34)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Part of message'//sep, KEY(35)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Correction number'//sep, KEY(37)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Part of message'//sep, KEY(38)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Correction number'//sep, KEY(40)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Part of message'//sep, KEY(41)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Correction number'//sep, KEY(43)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Part of message'//sep, KEY(44)," "
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,I0,A)') s0(1:len0)//sep//'section'//sep//&
                        & '2'//sep//'Quality control % conf'//sep, KEY(46)," "
                END IF
             end if
          end if
          !
          ! section 3
          !
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '3'//sep//'Length of section 3 (bytes)'//sep,KSEC3(1)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '3'//sep//'Reserved'//sep,KSEC3(2)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '3'//sep//'Number of data subsets'//sep,KSEC3(3)," "
          nrep=min(nrep+1,maxrep)
          write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
               & '3'//sep//'Flag (data type/data compression)'//sep,KSEC3(4)," "
          !
       end if
       !write(*,*)myname,'Report D:',KTDLEN
       if (.not.css%ignder) then
          DO I=1,KTDLEN
             write(s1,'(I0)') i; call chop0(s1,50); len1=length(s1,50,10)
             nrep=min(nrep+1,maxrep)
             write(rep250(nrep),'(A,I0,A)')s0(1:len0)//sep//'section'//sep//&
                  & '3'//sep//'unexpanded'//sep//s1(1:len1)//sep//'descriptor'//sep,KTDLST(I)," "
          end do
       end if
       !write(*,*)myname,'Report D:',KTDEXL
       !
       if (.not.css%ignuni.or..not.css%ignden.or..not.css%ignval) then
          DO II=1,KTDEXL
             IPOS=II+(isubset-1)*KEL
             if ((values(ipos).eq.rvind.and..not.css%ignmis).or.values(ipos).ne.rvind) then
                write(s1,'(I0)') ii; call chop0(s1,50); len1=length(s1,50,10)   ! element identification
                if (css%ignder) then
                   write(buff250,'(A)')s0(1:len0)//sep//'sequence'//sep//s1(1:len1)
                else
                   write(buff250,'(A,I0,A)')s0(1:len0)//sep//'sequence'//sep//s1(1:len1)//sep//&
                        & 'descriptor'//sep,KTDEXP(II)," "
                end if
                call chop0(buff250,250);lenb=length(buff250,250,20)
                if (.not.css%ignden) then
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,A,A)')buff250(1:lenb)//sep//&
                        & 'description'//sep,CNAMES(ii)," "
                end if
                if (.not.css%ignuni) then
                   nrep=min(nrep+1,maxrep)
                   write(rep250(nrep),'(A,A,A)')buff250(1:lenb)//sep//&
                        & 'unit'//sep,CUNITS(ii)," "
                end if
                if (.not.css%ignval) then
                   if (values(ipos).eq.RVIND) then
                      s2="MISSING";call chop0(s2,50); len2=length(s2,50,10) 
                      nrep=min(nrep+1,maxrep)
                      write(rep250(nrep),'(A,A,A)')buff250(1:lenb)//sep//&
                           & 'value'//sep,s2(1:len2)," "
                   else
                      write(s2,'(F0.14)') val; call chop0(s2,50); len2=length(s2,50,10)   ! element identification
                      if (len2.gt.1) then
                         OUTER: do JJ=1,len2
                            if (s2(JJ:JJ).eq.".") then
                               INNER: do while (len2.gt.JJ.and.(s2(len2:len2).eq."0".or.s2(len2:len2).eq."."))
                                  len2=len2-1
                               end do INNER
                               exit OUTER
                            end if
                         end do OUTER
                         if (len2.eq.1.and.s2(1:1).eq.".") then
                            s2="0"
                         else if (s2(len2:len2).eq.".") then
                            len2=len2-1
                         end if
                      end if
                      nrep=min(nrep+1,maxrep)
                      write(rep250(nrep),'(A,A,A)')buff250(1:lenb)//sep//&
                           & 'value'//sep,s2(1:len2)," "
                      s2=cvals(ii);call chop0(s2,50);len2=length(s2,50,10)
                      if (len2.gt.0)then
                         nrep=min(nrep+1,maxrep)
                         write(rep250(nrep),'(A,A,A)')buff250(1:lenb)//sep//&
                              & 'code'//sep,S2(1:len2)," "
                      end if
                   end if
                end if
             end if
          end do
       end if
       !
       ! add target values
       !
       if (css%ntarget .gt. 0) then
          if (css%category .eq. ksec1(6) .and. &
               & css%subcategory .eq. ksec1(7)) then
             do ii=1,css%ntarget
                seq=css%trg_seq(ii)
                bbok=(seq.le.ktdexl)
                if (bbok) bbok=(ktdexp(seq).eq.css%trg_descr(ii))
                if (css%trg_lval(1,ii).or.css%trg_lval(2,ii)) then
                   if (bbok.and.css%trg_lval(1,ii)) bbok=(values(seq).ge.css%trg_minval(ii))
                   if (bbok.and.css%trg_lval(1,ii)) bbok=(values(seq).le.css%trg_maxval(ii))
                end if
                if (bbok) then
                   s1=css%trg80(ii)(1:50) ; call chop0(s1,50); len1=length(s1,50,10)   ! element identification
                   write(s2,*) values(seq); call chop0(s1,50); len1=length(s1,50,10)
                   nrep=min(nrep+1,maxrep)
                   WRITE(rep250(nrep),'(A,A)')s0(1:len0)//sep//'target'//sep//&
                        & s1(1:len1)//sep//s2(1:len2)//" "
                end if
             end do
          end if
       end if
    end if
    !write(*,*)myname,' Done.',irc
  end subroutine observation_getReport
  !
  !###############################################################################
  ! ROUTINES FOR EXTRACTING BASIC DATA FROM ECMWF BUFR FILES -> FILE OBJECT
  !###############################################################################
  !
  subroutine observation_scanFile(css,bok,crc250,irc)
    type(obs_session), pointer :: css !  current session
    logical :: bok
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="observation_scanFile"
    integer :: cnt
    logical :: bbok
    if(obs_bdeb)write(*,*)myname,' Entering.',irc
    !
    ! open file
    !
    call observation_openFile(css,bok,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from observation_openFile.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    !
    ! loop over file
    !
    if (bok) then
       if(obs_bdeb)write(*,*)myname,' Calling readfile.'
       bok=.false. ! must read at least one observation
       bbok=.true.
       do while (bbok)
          call observation_readMessage(css,bbok,crc250,irc)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from observation_readMessage.")
             call observation_errorappendi(crc250,irc)
             call observation_errorappend(crc250,"\n")
             return
          end if
          if (bbok) then
             cnt=0
             do while (observation_checkObs(css,bok,crc250,irc))
                cnt=cnt+1
             end do
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from observation_checkObs.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
          end if
          if(obs_bdeb)write(*,'(X,A,X,A,3(I0,A))')myname,' Setting isubset ',&
               &isubset,' -> ',nsubset+1,' (',nsubset,')'
          isubset=nsubset+1 ! mark data "read"
       end do
       !write(*,*)myname,'Closing file.'
       !
       ! close file
       !
       call observation_closeFile(css,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_closeFile.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       if (css%currentFile%nsubset.eq.0) then
          if(obs_bdeb)write(*,*)myname,'No subsets found.'
       else
          !write(*,*)myname,'Subsets:',css%currentFile%nsubset
       end if
    end if
    if(obs_bdeb)write(*,*)myname,' Done.',irc
    return
  end subroutine observation_scanFile
  !
  ! check if obs is ok, store statistics. 
  ! Returns .false. if no more obs in message.
  ! bok is .true. if observation is ok
  !
  logical function observation_checkObs(css,bok,crc250,irc)
    type(obs_session), pointer :: css
    logical :: bok           ! is everything ok?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_checkObs"
    integer :: yy,mm,dd,hh,mi,cnt
    real :: sec, j2000
    if (observation_eval(css,bok,crc250,irc)) then
       css%currentfile%ook(1)=css%currentfile%ook(1)+1
       observation_checkObs=.true. ! we have a valid observation in memory
       ! store max/min values and counts
       if (bok) then
          css%currentfile%ook(2)=css%currentfile%ook(2)+1 ! successful evaluation
          if (css%ind_eset) then
             if (css%currentFile%ind_lim) then
                css%currentFile%ind_start=min(css%currentFile%ind_start,css%ind_val)
                css%currentFile%ind_stop=max(css%currentFile%ind_stop,css%ind_val)
             else
                css%currentFile%ind_lim=.true.
                css%currentFile%ind_start=css%ind_val
                css%currentFile%ind_stop=css%ind_val
             end if
          else if (obs_bdeb) then
             write(*,*)myname,'Index not set, no index limits available.'
          end if
          yy=KSEC1( 9)
          mm=KSEC1(10)
          dd=KSEC1(11)
          hh=KSEC1(12)
          mi=KSEC1(13)
          if (yy <= 99) then
             if (yy < 78) then
                yy = yy + 2000
             else
                yy = yy + 1900
             end if
          end if
          sec=0.0D0
          if(obs_bdeb)write(*,'(X,A,X,A,I4.4,4(A,I2.2),A)') myname,"Time: ",&
               & yy,"/",mm,"/",dd," ",hh,":",mi,"  => '"//&
               & css%currentFile%fn250(1:css%currentFile%lenf)//"'"
          call jd2000(j2000,yy,mm,dd,hh,mi,sec)
          !read file and get start/end indexs...
          if (css%currentFile%time_lim) then
             css%currentFile%time_start=min(css%currentFile%time_start,j2000)
             css%currentFile%time_stop=max(css%currentFile%time_stop,j2000)
          else
             css%currentFile%time_lim=.true.
             css%currentFile%time_start=j2000
             css%currentFile%time_stop=j2000
          end if
          !if(obs_bdeb)write(*,*)myname,"MaxMin:",css%ind_eset,css%ind_val,css%currentFile%ind_start,css%currentFile%ind_stop
          ! write(*,*) myname,"Value:",css%ind_val,css%currentFile%ind_start,css%currentFile%ind_stop
       else
          css%currentfile%orm(2)=css%currentfile%orm(2)+1 ! evaluation failed
       end if
       if(obs_bdeb)write(*,*)myname,' Index limits:',css%ind_eset,css%ind_val,&
            & css%currentFile%ind_lim,css%currentFile%ind_start,css%currentFile%ind_stop,bok
       !
       ! check against index limits
       !
       if (bok) then
          if (css%ind_eset) then
             if (css%ind_lval(1) .and. css%ind_lval(2)) then ! between
                bok= (css%ind_val.ge.css%ind_minval .and.css%ind_val.le.css%ind_maxval)
             else if (css%ind_lval(1)) then ! above
                bok= (css%ind_val.ge.css%ind_minval)
             else if (css%ind_lval(2)) then ! below
                bok= (css%ind_val.le.css%ind_maxval)
             end if
          end if
          if (bok) then
             css%currentfile%ook(3)=css%currentfile%ook(3)+1 ! inside index limits
          else
             if (obs_bdeb)write(*,*)myname,' Outside index limits:',&
                  & css%ind_lval,css%ind_val,css%ind_minval,css%ind_maxval
             css%currentfile%orm(3)=css%currentfile%orm(3)+1 ! out of index limits
          end if
       end if
       !
       ! check against targets
       !
       if (bok) then
          if(obs_bdeb)write(*,*)myname,' Checking target.'
          call observation_checkTarget(css,bok,crc250,irc)
          IF(IRC.NE.0) THEN
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from checkTarget.");
             call observation_errorappend(crc250,"\n")
             observation_checkObs=.false. ! exit loop
             RETURN
          END IF
          if (bok) then
             css%currentfile%ook(4)=css%currentfile%ook(4)+1 ! target check ok
          else
             css%currentfile%orm(4)=css%currentfile%orm(4)+1 ! target check failed
          end if
       else
       end if
    else
       bok=.false. ! "observation" is no good..
       observation_checkObs=.false. ! exit loop
    end if
    if(obs_bdeb)write(*,*)myname,'Done:',irc,observation_checkObs
    IF(IRC.NE.0) THEN
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from eval.");
       call observation_errorappend(crc250,"\n")
       observation_checkObs=.false. ! exit loop
       RETURN
    END IF
    return
  end function observation_checkObs
  !
  !###############################################################################
  ! ECMWF LIBEMOS ROUTINES FOR READING BUFR FILES
  !###############################################################################
  !
  ! open file
  !
  subroutine observation_openFile(css,bok,crc250,irc)
    type(obs_session), pointer :: css
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    integer :: lenf
    integer,external :: length
    character*250 :: fn250
    character*3 :: mode
    character*22 :: myname="observation_openFile"
    integer :: ii
    !
    !     MISSING VALUE INDICATOR
    ! 
    NBYTPW=JBPW/8
    NVIND=2147483647
    css%currentfile%NSUBSET=0
    css%currentFile%NMESSAGE=0
    if(obs_bdeb)write(*,*)myname,'Opening obsfile: ',css%currentfile%fn250(1:css%currentfile%lenf)
    CALL PBOPEN(UNIT,css%currentfile%fn250(1:css%currentfile%lenf),'R',irc)
    !if(obs_bdeb)write(*,*)myname,'Opened file: ',css%currentfile%fn250(1:css%currentfile%lenf)
    if (irc.ne.0) then
       if(obs_bdeb)write(*,*)myname,'Unable to open file.',irc
       call observation_errorappend(crc250,myname)
       IF(irc.EQ.-1) call observation_errorappend(crc250,'OPEN FAILED.')
       IF(irc.EQ.-2) call observation_errorappend(crc250,'INVALID FILE NAME.')
       IF(irc.EQ.-3) call observation_errorappend(crc250,'INVALID OPEN MODE SPECIFIED.')
       call observation_errorappend(crc250,"observation_openFile"//css%currentfile%fn250(1:css%currentfile%lenf));
       call observation_errorappend(crc250,"\n")
       bok=.false.
       return
    end if
    call observation_compile(css,crc250,irc)
    IF (IRC.NE.0) THEN
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Error compiling index expressions.");
       call observation_errorappend(crc250,"\n")
       return
    end if
    if (.not. css%keepstat) then
       do ii=1,10
          css%currentfile%mok(ii)=0
          css%currentfile%mrm(ii)=0
          css%currentfile%ook(ii)=0
          css%currentfile%orm(ii)=0
          css%currentfile%hint80(ii)=""
       end do
       do ii=1,css%ntrg
          css%trg_ook(ii)=0
          css%trg_orm(ii)=0
       end do
    end if
    css%int_val(3)=0 ! message id
    css%int_val(4)=0 ! obs id
    css%int_val(5)=0 ! location id
    call observation_clearCat(css%currentFile)
    fopen=.true.
    css%fopened=css%fopened+1
    return
  end subroutine observation_openFile
  !
  ! read next BUFR message
  !
  subroutine observation_readMessage(css,bok,crc250,irc)
    type(obs_session), pointer :: css
    logical :: bok           ! was get successful?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    integer :: ii, jj
    character*25 :: myname="observation_readMessage"
    if(obs_bdeb)write(*,*)myname,' Entering.'
    css%dyn_pos=0               ! reset dynamic position search index
    css%dyn_cnt=0               ! reset dynamic position search index
    irc=0
    msg: do
       bok=.true.
       KBUFL=0
       CALL PBBUFR(UNIT,KBUFF,JBUFL,KBUFL,irc)
       IF (IRC.EQ.-1) THEN ! EOF
          if(obs_bdeb)PRINT*,'NUMBER OF SUBSETS     ',css%currentFile%NSUBSET
          if(obs_bdeb)PRINT*,'NUMBER OF MESSAGES    ',css%currentFile%NMESSAGE
          IRC=0
          bok=.false.
          return
       end if
       IF (IRC.NE.0) THEN
          if(obs_bdeb)write(*,*)myname,'Unable to read file.',irc
          call observation_errorappend(crc250,myname)
          IF(irc.EQ.-2) call observation_errorappend(crc250,'FILE HANDLING PROBLEM.' )
          IF(irc.EQ.-3) call observation_errorappend(crc250,'ARRAY TOO SMALL FOR PRODUCT.')
          call observation_errorappend(crc250,"observation_readMessage"//css%currentFile%fn250(1:css%currentFile%lenf));
          call observation_errorappend(crc250,"\n")
          return
       end if
       bread=.true. ! new message in memory
       css%currentfile%nmessage=css%currentfile%nmessage+1
       css%int_val(3)=css%int_val(3)+1 ! message id
       css%int_val(4)=0 ! location id
       css%int_val(5)=0 ! location id
       !     PRINT*,'----------------------------------',N,' ',KBUFL
       KBUFL=KBUFL/NBYTPW+1
       !
       css%currentfile%mok(1)=css%currentfile%mok(1)+1
       ! if(obs_bdeb)WRITE(*,*)myname,'Calling BUS0123...',kbufl,nbytpw,jbufl,jbpw

       CALL BUS0123( KBUFL,KBUFF,KSUP,KSEC0,&
            & KSEC1,KSEC2,KSEC3,irc)
       !*KSUP*    -  ARRAY CONTAINING SUPLEMENTARY INFORMATION
       !-  KSUP( 1) -- IDIM1, DIMENSION OF KSEC1
       !-  KSUP( 2) -- IDIM2, DIMENSION OF KSEC2
       !-  KSUP( 3) -- IDIM3, DIMENSION OF KSEC3
       !-  KSUP( 4) -- IDIM4, DIMENSION OF KSEC4
       !-  KSUP( 5) -- M (NUMBER OF ELEMENTS IN VALUES ARRAY,FIRST INDEX)
       !-  KSUP( 6) -- N (NUMBER OF SUBSETS,SECOND INDEX OF VALUES ARRAY)
       !-  KSUP( 7) -- JVC (NUMBER OF ELEMENTS IN CVAL ARRAY)
       !-  KSUP( 8) -- TOTAL BUFR MESSAGE LENGTH IN BYTES
       !-  KSUP( 9) -- IDIM0, DIMENSION OF KSEC0
       ! KELEM < KSUP(5)
       ! KVALS < KSUP(6)*KSUP(5)
       ! check that we have enough space in arrays...
       IF(IRC.NE.0) THEN 
          if (css%currentfile%mrm(2).eq.1) write(*,*)myname,'Unable to decode a message header in:',&
               & css%currentFile%fn250(1:css%currentFile%lenf),irc
          if(obs_bdeb)write(*,*)'ERROR IN BUS012: CORRUPTED BUFR MESSAGE.',css%currentfile%nmessage,&
               & ' in file:',css%currentFile%fn250(1:css%currentFile%lenf)
          IRC=0
          css%currentfile%mrm(2)=css%currentfile%mrm(2)+1 ! unable to decode header
          cycle msg
       else
          css%currentfile%mok(2)=css%currentfile%mok(2)+1
       END IF
       !
       if(obs_bdeb)write(*,'(X,A,X,A,3(I0,A))')myname,' Setting nsubset ',&
            &nsubset,' -> ',ksec3(3),' (',isubset,')'
       nsubset=KSEC3(3)
       KEL=KVALS/nsubset
       IF(KEL.GT.KELEM) KEL=KELEM
       if(obs_bdeb)WRITE(*,*)myname,'KSUP:',ksup(5),ksup(6),KEL, nsubset
       !
       !write(*,*)myname,'Before BUFREX.'
       CALL BUFREX(KBUFL,KBUFF,KSUP,KSEC0 ,&
            & KSEC1,KSEC2 ,KSEC3 ,&
            & KSEC4,KEL,CNAMES,CUNITS,&
            & KVALS,VALUES,CVALS,irc)
       !write(*,*)myname,'After BUFREX.'
       if(obs_bdeb)write(*,*)myname,'Done BUFREX'
       IF(IRC.NE.0) THEN
          css%currentfile%mrm(3)=css%currentfile%mrm(3)+1 ! unable to decode body
          if (css%currentfile%mrm(3).eq.1) then
             write(*,*)myname,'Unable to decode a message body in:',&
                  & css%currentFile%fn250(1:css%currentFile%lenf),irc
          end if
          !call observation_errorappend(crc250,myname)
          !call observation_errorappend(crc250,"Unable to decode "//css%currentFile%fn250(1:css%currentFile%lenf));
          !call observation_errorappend(crc250,"\n")
          IRC=0
          cycle msg
       else
          css%currentfile%mok(3)=css%currentfile%mok(3)+1 ! able to decode body
       END IF
       css%currentfile%NSUBSET=css%currentfile%NSUBSET+nsubset
       if(obs_bdeb)write(*,'(X,A,X,A,3(I0,A))')myname,' Setting isubset ',&
            &isubset,' -> ',1,' (',nsubset,')'
       ISUBSET=1 ! start with first subset
       !write(*,*)myname,'G:'
       CALL BUSEL2(ISUBSET,KEL,KTDLEN,&
            & KTDLST,KTDEXL,KTDEXP(1), &
            & CNAMES,CUNITS,irc)

       !write(*,*)myname,'H:',ISUBSET
       if (irc.ne.0) then
          css%currentfile%mrm(4)=css%currentfile%mrm(4)+1 ! unable to decode description
          !write(*,*)myname,'Unable to decode message description.',irc
          if(obs_bdeb)write(*,*)'ERROR IN BUSEL2: CORRUPTED BUFR MESSAGE.',css%currentfile%nmessage,&
               & ' in file:',css%currentFile%fn250(1:css%currentFile%lenf)
          irc=0
          cycle msg
       else
          css%currentfile%mok(4)=css%currentfile%mok(4)+1 ! able to decode description
       end if
       ! store category:
       if(obs_bdeb)write(*,*)myname,'Found BUFR cat:',KSEC1( 6),KSEC1( 7)
       if (.not.css%igncat) call observation_storeCat(css%currentFile,KSEC1( 6),KSEC1( 7))
       ! CALL BUUKEY(KSEC1,KSEC2,KEY,KSUP,IRC)
       ! if (irc.ne.0) then
       !    write(*,*)myname,'Unable to decode message keys.',irc
       !    if(obs_bdeb)write(*,*)'ERROR IN BUUKEY: CORRUPTED BUFR MESSAGE.',css%currentfile%nmessage,&
       !         & ' in file:',css%currentFile%fn250(1:css%currentFile%lenf)
       !    irc=0
       !    cycle msg
       ! end if
       nitem=KTDEXL
       !
       ! check descr
       !
       if(obs_bdeb)write(*,*)myname,'Checking obs.'
       call observation_checkDescr(css,bok,crc250,irc)
       IF(IRC.NE.0) THEN
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from eval.");
          call observation_errorappend(crc250,"\n")
          RETURN
       END IF
       if(obs_bdeb)write(*,'(X,A,A,4(X,I0),X,L1)')myname,' Checked obs.',&
            & KSEC1( 6),KSEC1( 7),css%category,css%subcategory,bok
       if (.not. bok) then
          irc=0
          cycle msg
       else
          exit msg
       end if
    end do msg
    if(obs_bdeb)write(*,*)myname,' Done.',css%currentFile%ook
    return
  end subroutine observation_readMessage
  !
  ! close file
  !
  subroutine observation_closeFile(css,crc250,irc)
    type(obs_session), pointer :: css
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_closeFile"
    !
    CALL PBCLOSE(unit,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"observation_closeFile")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    unit=0
    isubset=1
    nsubset=0
    call observation_terminate(css,crc250,irc)
    IF (IRC.NE.0) THEN
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"Error compiling index expressions.");
       call observation_errorappend(crc250,"\n")
       return
    end if
    fopen=.false.
    !
  end subroutine observation_closeFile


  !######################################################
  subroutine observation_ignoreCat(css)
    type(obs_session), pointer :: css
    css%igncat=.true.
    !write(*,*) 'observation_clearCat Done.'
  end subroutine observation_ignoreCat
  !
  subroutine observation_clearCat(currentFile)
    type(obs_file), pointer :: currentFile
    type(obs_mainCategory),pointer :: currentCat, nextCat
    type(obs_subCategory),pointer :: currentSub, nextSub
    !write(*,*) 'observation_clearCat Entering.'
    if (associated(currentFile%firstCategory%next)) then
       currentCat=> currentFile%firstCategory%next
       do while (.not.associated(currentCat,target=currentFile%lastCategory)) 
          nextCat=>currentCat%next
          currentSub=> currentCat%firstSubCategory%next
          do while (.not.associated(currentSub,target=currentCat%lastSubCategory)) 
             nextSub=>currentSub%next
             if (allocated(currentSub%ktdexp)) deallocate(currentSub%ktdexp)
             if (allocated(currentSub%cnames)) deallocate(currentSub%cnames)
             if (allocated(currentSub%cunits)) deallocate(currentSub%cunits)
             if (allocated(currentSub%values)) deallocate(currentSub%values)
             deallocate(currentSub)
             currentSub=>nextSub
          end do
          deallocate(currentCat)
          currentCat=>nextCat
       end do
       currentFile%ncat=0
       currentFile%nsub=0
    end if
    currentFile%firstCategory%next => currentFile%lastCategory
    currentFile%lastCategory%prev => currentFile%firstCategory
    !write(*,*) 'observation_clearCat Done.'
  end subroutine observation_clearCat
  !
  subroutine observation_storeCat(currentFile,cat,subcat)
    type(obs_file), pointer :: currentFile
    integer :: cat
    integer :: subcat
    type(obs_mainCategory),pointer :: currentCat
    type(obs_subCategory),pointer :: currentSub
    integer ii,irc
    character*22 :: myname="observation_storeCat"
    currentCat=> currentFile%firstCategory%next
    do while (.not.associated(currentCat,target=currentFile%lastCategory)) 
       if (currentCat%category .eq. cat) then
          currentCat%cnt=currentCat%cnt+1
          currentSub=> currentCat%firstSubCategory%next
          do while (.not.associated(currentSub,target=currentCat%lastSubCategory)) 
             if (currentSub%subCategory .eq. subcat) then
                currentSub%cnt=currentSub%cnt+1
                return
             else
                currentSub=>currentSub%next
             end if
          end do
          ! found cat but not subcat
          currentFile%nsub=currentFile%nsub+1
          currentCat%nsub=currentCat%nsub+1
          allocate(currentSub)
          currentSub%subcategory=subcat
          currentSub%next => currentCat%lastSubCategory
          currentSub%prev => currentCat%lastSubCategory%prev
          currentCat%lastSubCategory%prev%next => currentSub
          currentCat%lastSubCategory%prev => currentSub
          currentSub%cnt=currentSub%cnt+1
          ! store data sequence
          currentSub%ktdexl=KTDEXL
          allocate(currentSub%ktdexp(currentSub%ktdexl),currentSub%cnames(currentSub%ktdexl),&
               & currentSub%cunits(currentSub%ktdexl),currentSub%values(currentSub%ktdexl),stat=irc)
          if (irc.ne.0) then
             currentSub%ktdexl=0
             write(*,*) myname,"Unable to allocate 'sub-sequence'."
             !call observation_errorappend(crc250,myname)
             !call observation_errorappend(crc250,"Unable to allocate 'sub-sequence'.")
             !call observation_errorappend(crc250,"\n")
             !return
          end if
          do ii=1,currentSub%ktdexl
             currentSub%ktdexp(ii)=ktdexp(ii)
             currentSub%cnames(ii)=cnames(ii)
             currentSub%cunits(ii)=cunits(ii)
             currentSub%values(ii)=values(ii)
          end do
          return
       else
          currentCat=>currentCat%next
       end if
    end do
    ! did not find cat nor subcat
    currentFile%ncat=currentFile%ncat+1
    allocate(currentCat)
    currentCat%category=cat
    currentCat%next => currentFile%lastCategory
    currentCat%prev => currentFile%lastCategory%prev
    currentFile%lastCategory%prev%next => currentCat
    currentFile%lastCategory%prev => currentCat
    currentCat%lastSubCategory%prev => currentCat%firstSubCategory
    currentCat%firstSubCategory%next => currentCat%lastSubCategory
    currentCat%cnt=currentCat%cnt+1
    !
    currentFile%nsub=currentFile%nsub+1
    currentCat%nsub=currentCat%nsub+1
    allocate(currentSub)
    currentSub%subcategory=subcat
    currentSub%next => currentCat%lastSubCategory
    currentSub%prev => currentCat%lastSubCategory%prev
    currentCat%lastSubCategory%prev%next => currentSub
    currentCat%lastSubCategory%prev => currentSub
    currentSub%cnt=currentSub%cnt+1
    ! store data sequence
    currentSub%ktdexl=KTDEXL
    allocate(currentSub%ktdexp(currentSub%ktdexl),currentSub%cnames(currentSub%ktdexl),&
         & currentSub%cunits(currentSub%ktdexl),currentSub%values(currentSub%ktdexl),stat=irc)
    if (irc.ne.0) then
       currentSub%ktdexl=0
       write(*,*) myname,"Unable to allocate 'sub-sequence'."
       !call observation_errorappend(crc250,myname)
       !call observation_errorappend(crc250,"Unable to allocate 'sub-sequence'.")
       !call observation_errorappend(crc250,"\n")
       !return
    end if
    do ii=1,currentSub%ktdexl
       currentSub%ktdexp(ii)=ktdexp(ii)
       currentSub%cnames(ii)=cnames(ii)
       currentSub%cunits(ii)=cunits(ii)
       currentSub%values(ii)=values(ii)
    end do
    return
  end subroutine observation_storeCat
  !
  ! returns time as character-string
  !
  character*21 function observation_gettime(j2000) 
    implicit none
    real :: j2000
    integer :: yy,mm,dd,hh,mi
    real :: sec
    character*4 :: csec
    integer, external :: length
    integer :: lenp,lenc
    character*22 :: myname="observation_gettime"
    call dj2000(j2000,yy,mm,dd,hh,mi,sec)
    write(csec,'(F4.1)') sec
    call chop0(csec,4)
    lenc=length(csec,4,4)
    if (sec.lt.10.0D0)  csec="0"//csec(1:lenc)
    write(observation_gettime,'(I4.4,"/",I2.2,"/",I2.2," ",I2.2,":",I2.2,":",A4)') yy,mm,dd,hh,mi,csec
!!!!! write(*,*) myname,j2000,observation_gettime
  end function observation_gettime

  real function  observation_getj2000(time50,crc250,irc) 
    implicit none
    character*50 :: time50
    character*250 :: crc250
    integer :: irc
    real :: j2000
    integer, external :: length
    integer :: lenp,lent
    character*22 :: myname="observation_getj2000"
    integer :: yy,mm,dd,hh,mi
    real :: sec
    ! first try to read as formatted time
    read(time50,'(I4,X,I2,X,I2,X,I2,X,I2,X,F4.1)',iostat=irc)yy,mm,dd,hh,mi,sec
    if (irc.eq.0) then
       call jd2000(j2000,yy,mm,dd,hh,mi,sec)
    else
       read(time50,*,iostat=irc)j2000
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Unable to determine time from:")
          call observation_errorappend(crc250,time50)
          call observation_errorappend(crc250,"\n")
          return
       end if
    end if
    observation_getj2000=j2000
    !lent=length(time50,50,10)
    if(obs_bdeb)write(*,*)myname,' Time:',time50(1:lent)," Found:",j2000
  end function observation_getj2000

  !
  ! B U F R   C O D E T A B L E   R O U T I N E S
  !
  subroutine observation_getType(icode,isubcode,typ50,sub50,crc250,irc) 
    implicit none
    integer :: icode
    integer :: isubcode
    character*50 :: typ50, sub50
    character*250 :: crc250
    integer :: irc
    integer :: left,right,bingo
    type(obs_table), pointer :: ptable
    character*22 :: myname="observation_getType"
    if (icode.eq.0) then ! surface
       typ50="Surface"
       if (isubcode.eq.1) then
          sub50="synop land"
       else if (isubcode.eq.2) then
          sub50="synop land record 2"
       else if (isubcode.eq.3) then
          sub50="synop land (auto)"
       else if (isubcode.eq.4) then
          sub50="synop land (auto) 2"
       else if (isubcode.eq.7) then
          sub50="soil temperatures"
       else if (isubcode.eq.108) then
          sub50="climat synop"
       else if (isubcode.eq.116) then
          sub50="soil temperatures USA"
       else if (isubcode.eq.117) then
          sub50="soil temperatures"
       else if (isubcode.eq.140) then
          sub50="metar"
       else
          sub50=""
       end if
    else if (icode.eq.1) then ! surface
       typ50="Surface"
       if (isubcode.eq.9) then
          sub50="synop ship abbreviated "
       else if (isubcode.eq.11) then
          sub50="synop ship"
       else if (isubcode.eq.12) then
          sub50="synop ship record 2"
       else if (isubcode.eq.13) then
          sub50="synop ship (auto)"
       else if (isubcode.eq.14) then
          sub50="synop ship (auto) 2"
       else if (isubcode.eq.19) then
          sub50="synop ship reduced"
       else if (isubcode.eq.21) then
          sub50="surface buoy"
       else if (isubcode.eq.22) then
          sub50="surface bathy"
       else if (isubcode.eq.23) then
          sub50="surface tesac"
       else if (isubcode.eq.27) then
          sub50="buoy argos"
       else
          sub50=""
       end if
    else if (icode.eq.3) then ! Tovs
       typ50="Tovs"
       if (isubcode.eq.51) then
          sub50="80 km"
       else if (isubcode.eq.53) then
          sub50="rtovs"
       else if (isubcode.eq.54) then
          sub50="tovs1b"
       else if (isubcode.eq.55) then
          sub50="atovs"
       else if (isubcode.eq.56) then
          sub50="atovs product"
       else if (isubcode.eq.57) then
          sub50="airs"
       else if (isubcode.eq.58) then
          sub50="avhrr"
       else if (isubcode.eq.61) then
          sub50="500 km low level"
       else if (isubcode.eq.62) then
          sub50="500 km water"
       else if (isubcode.eq.63) then
          sub50="500 km high level"
       else if (isubcode.eq.71) then
          sub50="250 km low level"
       else if (isubcode.eq.72) then
          sub50="250 km water"
       else if (isubcode.eq.73) then
          sub50="250 km high level"
       else if (isubcode.eq.129) then
          sub50="trmm bt"
       else if (isubcode.eq.130) then
          sub50="trmra rain"
       else if (isubcode.eq.206) then
          sub50="gomos"
       else
          sub50=""
       end if
    else if (icode.eq.5) then ! Geostationay
       typ50="Geostationary"
       if (isubcode.eq.82) then
          sub50="satob section 2"
       else if (isubcode.eq.83) then
          sub50="satob section3"
       else if (isubcode.eq.84) then
          sub50="satob section 4"
       else if (isubcode.eq.85) then
          sub50="satob secrion 5"
       else if (isubcode.eq.86) then
          sub50="HR wind"
       else if (isubcode.eq.87) then
          sub50="HR wind + qc"
       else if (isubcode.eq.88) then
          sub50="radiances (geostat)"
       else if (isubcode.eq.89) then
          sub50="radiences (geostat)"
       else if (isubcode.eq.212) then
          sub50="meris"
       else
          sub50=""
       end if
    else if (icode.eq.2) then ! Wind profile, temperature, profile
       if (isubcode.eq.91) then
          sub50="pilot"
          typ50="Wind profile"
       else if (isubcode.eq.92) then
          sub50="pilot ship"
          typ50="Wind profile"
       else if (isubcode.eq.95) then
          sub50="wind profiler (usa)"
          typ50="Wind profile"
       else if (isubcode.eq.96) then
          sub50="wind profiler (Europe)"
          typ50="Wind profile"
       else if (isubcode.eq.97) then
          sub50="wind profiler (Europe)"
          typ50="Wind profile"
       else if (isubcode.eq.101) then
          sub50="temp"
          typ50="Temperature"
       else if (isubcode.eq.102) then
          sub50=" temp ship"
          typ50="profile"
       else if (isubcode.eq.103) then
          sub50=" temp drop"
          typ50="profile"
       else if (isubcode.eq.104) then
          sub50=" rocob"
          typ50="profile"
       else if (isubcode.eq.105) then
          sub50=" rocob ship"
          typ50="profile"
       else if (isubcode.eq.106) then
          sub50=" temp mobile"
          typ50="profile"
       else if (isubcode.eq.107) then
          sub50=" climat temp"
          typ50="profile"
       else
          sub50=""
          typ50="profile"
       end if
    else if (icode.eq.31) then ! Oceanographic 
       typ50="Oceanographic"
       if (isubcode.eq.131) then
          sub50=" dribu/buoy"
       else if (isubcode.eq.132) then
          sub50=" bathy"
       else if (isubcode.eq.133) then
          sub50=" tesac"
       else
          sub50=""
       end if
    else if (icode.eq.4) then ! Single level 
       typ50="Single level"
       if (isubcode.eq.141) then
          sub50=" codar"
       else if (isubcode.eq.142) then
          sub50=" airep"
       else if (isubcode.eq.143) then
          sub50=" colba"
       else if (isubcode.eq.144) then
          sub50=" amdar"
       else if (isubcode.eq.145) then
          sub50=" acar"
       else
          sub50=""
       end if
    else if (icode.eq.12) then ! Satellite 
       typ50="Satellite"
       if (isubcode.eq.121) then
          sub50=" uwa"
       else if (isubcode.eq.122) then
          sub50=" uwi"
       else if (isubcode.eq.123) then
          sub50=" ura"
       else if (isubcode.eq.124) then
          sub50=" uat"
       else if (isubcode.eq.126) then
          sub50=" ssmi (mapped)"
       else if (isubcode.eq.127) then
          sub50=" ssbt (ssmi brightness T)"
       else if (isubcode.eq.136) then
          sub50=" nwi (nsqat)"
       else if (isubcode.eq.138) then
          sub50=" qwi (qscat )"
       else if (isubcode.eq.210) then
          sub50=" asar"
       else if (isubcode.eq.213) then
          sub50=" ra-2"
       else if (isubcode.eq.220) then
          sub50=" aatsr"
       else if (isubcode.eq.214) then
          sub50=" jason"
       else
          sub50=""
       end if
    else if (icode.eq.7) then ! Tropical 
       typ50="Tropical"
       if (isubcode.eq.31) then
          sub50=" tropical storm"
       else
          sub50=""
       end if
    else if (icode.eq.8) then ! Chemical 
       typ50="Chemical"
       if (isubcode.eq.157) then
          sub50=" Surface ozone"
       else if (isubcode.eq.158) then
          sub50=" Surface ozone average"
       else if (isubcode.eq.159) then
          sub50=" Vertical sounding ozone"
       else if (isubcode.eq.170) then
          sub50=" O3 layers"
       else
          sub50=""
       end if
    else if (icode.eq.253) then ! Bogus 
       typ50="Bogus"
       if (isubcode.eq.164) then
          sub50=" paob"
       else
          sub50=""
       end if
    else
       typ50=""
       sub50=""
   end if
   ! write(*,*)myname,'Debug:',icode,isubcode,typ50,sub50
 end subroutine observation_getType

  character*250 function observation_getCodeValue(icode,isubcode,crc250,irc) 
    use sort
    implicit none
    integer :: icode
    integer :: isubcode
    character*250 :: crc250
    integer :: irc
    integer :: left,right,bingo
    type(obs_table), pointer :: ptable
    character*22 :: myname="observation_getCodeValue"
    if (.not.ctableInit) then
       !
       call observation_initCodeTable(irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from observation_initCodeTable.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       ctableInit=.true.
    end if
    call sort_heapsearch1i(ctable%maxnn,ctable%codes, &
         & ctable%nn,ctable%index,icode,left,right)
    if (left.eq.right) then
       bingo=left
       call sort_heapsearch1i(ctable%tables(bingo)%maxnn,ctable%tables(bingo)%subcodes, &
            & ctable%tables(bingo)%nn,ctable%tables(bingo)%index,isubcode,left,right)
       if (left.eq.right) then
          observation_getCodeValue=ctable%tables(bingo)%values(left)
       else
          observation_getCodeValue=""
       end if
    else
       observation_getCodeValue=""
    end if
    return
  end function observation_getCodeValue
  !
  subroutine observation_initCodeTable(irc) 
    integer :: irc
    integer :: iunit
    integer, external :: ftunit
    character*250 :: val250
    integer :: code,scnt,subcode,lcnt,cnt,ii
    integer :: lent,lenv,pos,line
    integer, external :: length
    logical :: bdone
    character*22 :: myname="observation_initCodeTable"
    call chop0(c250,250)
    lent=length(c250,250,10)
    if (lent.ne.0) then
       do ii=1,2
          cnt=0
          unit=ftunit(irc)
          ! open file
          open(unit=iunit,file=c250(1:lent),iostat=irc,status="old",&
               & FORM='FORMATTED',ACCESS='SEQUENTIAL')
          if (irc.ne.0) then
             if(obs_bdeb)write(*,*) myname,"Unable to open '"//c250(1:lent)//"'"
             return
          end if
          line=0
          read(iunit,'(I6,X,I4,X,I8,X,I2,X,A)',iostat=irc) code, scnt, subcode, lcnt, val250
          if (irc.ne.0) then
             return
          end if
          line=line+1
          if (irc.ne.0) then
             if(obs_bdeb)write(*,*) myname,'Unable to read: ',c250(1:lent)
             return
          end if
          bdone=irc.ne.0
          do while (.not. bdone) 
             call getRest(val250,iunit,lcnt-1)
             line=line+lcnt-1
             cnt=cnt+1
             if (ii.eq.2) then
                ctable%codes(cnt) = code
                allocate(ctable%tables(cnt),stat=irc)
                ctable%index(cnt) = cnt
                ctable%tables(cnt)%code=code
                ctable%tables(cnt)%maxnn=scnt;
                ctable%tables(cnt)%nn=scnt;
                allocate(ctable%tables(cnt)%subcodes(scnt),ctable%tables(cnt)%values(scnt),ctable%tables(cnt)%index(scnt),stat=irc);
                ctable%tables(cnt)%subcodes(1)=subcode;
                ctable%tables(cnt)%values(1)=val250;
                ctable%tables(cnt)%index(1)=1;
             end if
             do pos = 2,scnt
                read(iunit,'(12X,I8,X,I2,X,A)',iostat=irc) subcode, lcnt, val250
                if (irc.ne.0) then
                   return
                end if
                line=line+1
             if (irc.eq.0) then
                   call getRest(val250,iunit,lcnt-1)
                   line=line+lcnt-1
                   call chop0(val250,250)
                   lenv=length(val250,250,10)
                   if (lenv>80) then
                      val250=val250(1:75)//"..."
                   end if
                   if (ii.eq.2) then
                      ctable%tables(cnt)%subcodes(pos)=subcode
                      ctable%tables(cnt)%values(pos)=val250
                      ctable%tables(cnt)%index(pos)=pos
                   end if
                else if (obs_bdeb) then
                   write(*,*)myname,'Error reading line:',line
                end if
             end do
             read(iunit,'(I6,X,I4,X,I8,X,I2,X,A)',iostat=irc) code, scnt, subcode, lcnt, val250
             if (irc.ne.0) then
                return
             end if
             bdone=(irc.ne.0)
             line=line+1
             irc=0
          end do
          close(iunit,iostat=irc)
          if (irc.ne.0) then
             return
          end if
          if (ii.eq.1) then
             ctable%maxnn=cnt;
             ctable%nn=cnt;
             allocate(ctable%codes(cnt),ctable%tables(cnt),ctable%index(cnt),stat=irc);
          end if
       end do
    end if
  end subroutine observation_initCodeTable

  subroutine getRest(val250,iunit,lcnt)
    character*250 :: val250
    integer :: iunit
    integer :: lcnt
    integer :: irc
    character*250 :: buff250
    integer :: lenv
    integer, external :: length
    lenv=10
    call chop0(val250,250)
    lenv=length(val250,250,lenv)
    do while (lcnt.gt.0)
       read(iunit,'(22X,A)',iostat=irc) buff250
       val250=val250(1:lenv)//buff250
       call chop0(val250,250)
       lenv=length(val250,250,lenv)
       lcnt = lcnt-1;
    end do
  end subroutine getRest
  !
  ! keep track of locations per message
  !
  subroutine observation_updateObsCnt(css,cnt)
    type(obs_session), pointer :: css
    integer :: cnt
    if (css%ocnt.eq.0.or.cnt.lt.css%omin) css%omin=cnt
    if (css%ocnt.eq.0.or.cnt.gt.css%omax) css%omax=cnt
    css%osum=css%osum+cnt
    css%ocnt=css%ocnt+1
    return
  end subroutine observation_updateObsCnt
  !
  subroutine observation_updateLocCnt(css,cnt)
    type(obs_session), pointer :: css
    integer :: cnt
    if (css%lcnt.eq.0.or.cnt.lt.css%lmin) css%lmin=cnt
    if (css%lcnt.eq.0.or.cnt.gt.css%lmax) css%lmax=cnt
    css%lsum=css%lsum+cnt
    css%lcnt=css%lcnt+1
    return
  end subroutine observation_updateLocCnt
  !
  subroutine observation_resetStat(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    integer :: ii
    type(obs_file), pointer :: cfile
    character*22 :: myname="observation_resetStat"
    if (obs_bdeb) write(*,*)myname,'Entering.',irc
    css%fopened = 0
    do ii=1,10
       css%fok(ii)=0
       css%frm(ii)=0
    end do
    css%keepstat=.true.
    if (associated(css%firstFile)) then
       cfile => css%firstFile%next
       do while (.not.associated(cfile,target=css%lastFile))
          ! update statistics
          do ii=1,10
             cfile%ook(ii)=0
             cfile%orm(ii)=0
             cfile%mok(ii)=0
             cfile%mrm(ii)=0
          end do
          cfile  => cfile%next
       end do
    end if
    do ii=0,css%ntrg
       css%trg_orm(ii)=0
       css%trg_ook(ii)=0
    end do
    css%ocnt=0
    css%osum=0
    css%lcnt=0
    css%lsum=0
    if (obs_bdeb) write(*,*)myname,'Done.',irc
    return
  end subroutine observation_resetStat
 !
  subroutine observation_printStat(css,crc250,irc)
    type(obs_session), pointer :: css !  current session
    character*250 :: crc250
    integer :: irc
    integer :: ii
    integer :: ook(10),orm(10),mok(10),mrm(10)
    real :: pst(10),pp
    type(obs_file), pointer :: cfile
    character*22 :: myname="observation_printStat"
    do ii=1,10
       ook(ii)=0
       orm(ii)=0
       mok(ii)=0
       mrm(ii)=0
    end do
    !
    ! file statistics
    do ii=1,10
       pst(ii)=dfloat(css%frm(ii))/max(1.0d0,dfloat(css%frm(ii)+css%fok(ii)))*100
    end do
    WRITE(*,*)
    WRITE(*,998) MYNAME,                     'Possible obs file matches: ', css%fok(1)+css%frm(1)
    IF (CSS%FRM(1).NE.0) WRITE(*,999) MYNAME,'No overlap:                ', -CSS%FRM(1),PST(1)
    IF (CSS%FRM(2).NE.0) WRITE(*,999) MYNAME,'Out of range for sure:     ', -CSS%FRM(2),PST(2)
    IF (CSS%FRM(3).NE.0) WRITE(*,999) MYNAME,'Out of range fine check:   ', -CSS%FRM(3),PST(3)
    WRITE(*,997) MYNAME,     '--------------------------------------------------'
    pp=dfloat(css%fok(3))/max(1.0d0,dfloat(css%frm(1)+css%fok(1)))*100
    WRITE(*,999) MYNAME,                     'Obs file matches:          ', css%fok(3),pp
    !
    if (css%fopened.eq.0) then
       WRITE(*,*)
       write(*,*)myname,'No obs files were opened. How strange!'
    else
       write(*,'(X,A,X,A,I0)')myname,'Obs files opened:',css%fopened
    end if
    ! accumulate file statistics...
    if (associated(css%firstFile)) then
       cfile => css%firstFile%next
       do while (.not.associated(cfile,target=css%lastFile))
          ! update statistics
          do ii=1,10
             ook(ii)=ook(ii)+cfile%ook(ii)
             orm(ii)=orm(ii)+cfile%orm(ii)
             mok(ii)=mok(ii)+cfile%mok(ii)
             mrm(ii)=mrm(ii)+cfile%mrm(ii)
          end do
          cfile  => cfile%next
       end do
    end if
    ! message statistics
    do ii=1,10
       pst(ii)=dfloat(mrm(ii))/max(1.0d0,dfloat(mrm(ii)+mok(ii)))*100
    end do
    WRITE(*,*)
    WRITE(*,998) MYNAME,                 'BUFR messages:               ', mok(1)+mrm(1)
    IF (MRM(2).NE.0) WRITE(*,999) MYNAME,'Unable to decode header:     ', -mRM(2),PST(2)
    IF (MRM(3).NE.0) WRITE(*,999) MYNAME,'Unable to decode body:       ', -mRM(3),PST(3)
    IF (MRM(4).NE.0) WRITE(*,999) MYNAME,'Unable to decode description:', -mRM(4),PST(4)
    IF (MRM(5).NE.0) WRITE(*,999) MYNAME,'Other BUFR/sub-type:         ', -mRM(5),PST(5)
    IF (MRM(6).NE.0) WRITE(*,999) MYNAME,'DESCR out of range:          ', -mRM(6),PST(6)
    IF (MRM(7).NE.0) WRITE(*,999) MYNAME,'DESCR mismatch:              ', -mRM(7),PST(7)
    WRITE(*,997) MYNAME,     '----------------------------------------------------'
    pp=dfloat(mok(7))/max(1.0d0,dfloat(mrm(1)+mok(1)))*100
    WRITE(*,999) MYNAME,                 'Accepted BUFR messages:      ', mok(7),pp
    ! MESSAGE -> OBS -> Location
    if (css%lcnt.ne.0) then
       write(*,*)
       write(*,'(X,A12,X,A,I0,A,I0,A,F0.2,A,I0)') myname,&
            & "Obs per message, min:",css%omin," max:",css%omax," avg:",&
            real(css%osum)/max(1.0D0,real(css%ocnt))," valid:",css%ocnt
       write(*,'(X,A12,X,A,I0,A,I0,A,F0.2,A,I0)') myname,&
            & "Loc per obs,     min:",css%lmin," max:",css%lmax," avg:",&
            real(css%lsum)/max(1.0D0,real(css%lcnt))," valid:",css%lcnt
    end if
    ! location statistics
    do ii=1,10
       pst(ii)=dfloat(orm(ii))/max(1.0d0,dfloat(orm(ii)+ook(ii)))*100
    end do
    WRITE(*,*)
    WRITE(*,998) MYNAME,                 'Locations:                   ', ook(1)+orm(1)
    IF (ORM(2).NE.0) WRITE(*,999) MYNAME,'Evaluation error:            ', -orm(2),PST(2)
    IF (ORM(3).NE.0) WRITE(*,999) MYNAME,'Index filter:                ', -orm(3),PST(3)
    do ii=1,css%ntrg
       pp=dfloat(css%trg_orm(ii))/max(1.0d0,dfloat(css%trg_orm(0)+css%trg_ook(0)))*100
       IF (css%trg_orm(ii).NE.0) WRITE(*,996) MYNAME,"'"//css%trg80(ii)(1:css%trg_lent(ii))//"' filter:", &
            & -css%trg_orm(ii),PP
    end do
    IF (ORM(5).NE.0) WRITE(*,999) MYNAME,'Obs filter:                  ', -orm(5),PST(5)
    WRITE(*,997) MYNAME,     '----------------------------------------------------'
    pp=dfloat(ook(5))/max(1.0d0,dfloat(orm(1)+ook(1)))*100
    WRITE(*,999) MYNAME,                 'Accepted locations:          ', ook(5),pp
    !
999 FORMAT(X,A12,X,A,I13,' (',F6.2,'%)')
998 FORMAT(X,A12,X,A,I13)
997 FORMAT(X,A12,X,A)
996 FORMAT(X,A12,X,A30,I13,' (',F6.2,'%)')
    
    return
  end subroutine observation_printStat
  !
  ! E R R O R    R O U T I N E S
  !
  subroutine observation_errorappend(crc250,string)
    implicit none
    character*250 :: crc250
    character*(*) :: string
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    character*22 :: myname="observation_errorappend"
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    lenb=len(trim(string))
    buff250=string(1:lenb)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//""//buff250(1:min(250-lenc-1,lenb))
    end if
    call chop0(crc250,250)
  end subroutine observation_errorappend
  subroutine observation_errorappendi(crc250,inum)
    implicit none
    character*250 :: crc250
    integer :: inum
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    character*22 :: myname="observation_errorappendi"
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    write(buff250,'(I12)')inum
    call chop0(buff250,250)
    lenb=length(buff250,250,1)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//""//buff250(1:min(250-lenc-1,lenb))
    end if
    call chop0(crc250,250)
  end subroutine observation_errorappendi

  character*250 function observation_diff(dt)
    real :: dt
    character*250 :: buff250
    character*25 :: siff25
    integer, external :: length
    integer :: lenb,lens
    integer :: dd
    integer :: hh
    integer :: mi
    integer :: ss
    lenb=0
    call chop0(buff250,250)
    ss=nint(dt*86400.0D0)
    if (ss.gt.86400) then
       if (lenb.gt.0) then
          buff250=buff250(1:lenb)//" "
          lenb=lenb+1
       end if
       dd=int(ss/86400)
       ss=ss-dd*86400
       write(siff25,*)dd
       call chop0(siff25,25)
       lens=length(siff25,25,5)
       buff250=buff250(1:lenb)//siff25(1:lens)//"d"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end if
    if (ss.gt.3600) then
       if (lenb.gt.0) then
          buff250=buff250(1:lenb)//" "
          lenb=lenb+1
       end if
       hh=int(ss/3600)
       ss=ss-hh*3600
       write(siff25,*)hh
       call chop0(siff25,25)
       lens=length(siff25,25,5)
       buff250=buff250(1:lenb)//siff25(1:lens)//"h"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end if
    if (ss.gt.60) then
       if (lenb.gt.0) then
          buff250=buff250(1:lenb)//" "
          lenb=lenb+1
       end if
       mi=int(ss/60)
       ss=ss-mi*60
       write(siff25,*)mi
       call chop0(siff25,25)
       lens=length(siff25,25,5)
       buff250=buff250(1:lenb)//siff25(1:lens)//"m"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end if
    if (ss.gt.0) then
       if (lenb.gt.0) then
          buff250=buff250(1:lenb)//" "
          lenb=lenb+1
       end if
       write(siff25,*)ss
       call chop0(siff25,25)
       lens=length(siff25,25,5)
       buff250=buff250(1:lenb)//siff25(1:lens)//"s"
       call chop0(buff250,250)
       lenb=length(buff250,250,lenb)
    end if
    observation_diff=buff250
    return
  end function observation_diff

  character*250 function observation_pretty(varname,ndims,dimnames,start,vsize)
    character*80 :: varname
    integer :: ndims
    character*80 :: dimnames(ndims)
    integer :: start(ndims)
    integer :: vsize(ndims)
    integer, external :: length
    integer :: lenv, lend, lenb, lenx
    character*250 :: xuff250, yuff250,buff250
    integer :: ii
    character*22 :: myname="observation_pretty"
    buff250=""
    lenb=0
    do ii=1,ndims
       lend=length(dimnames(ii),80,10)
       if(obs_bdeb)write(*,*) "observation_pretty  dimnames:",dimnames(ii)(1:lend),start(ii),vsize(ii)
       if (vsize(ii).gt.1) then
          write(yuff250,*)vsize(ii);call chop0(yuff250,250);lenx=length(yuff250,250,2)
          write(xuff250,'(I8,"+",A)')start(ii),yuff250(1:lenx);call chop0(xuff250,250);lenx=length(xuff250,250,2)
       else
          write(xuff250,'(I8)')start(ii);call chop0(xuff250,250);lenx=length(xuff250,250,2)
       end if
       xuff250=dimnames(ii)(1:lend)//"["//xuff250(1:lenx)//"]";call chop0(xuff250,250);lenx=length(xuff250,250,2)
       if(obs_bdeb)write(*,*)myname,'XUFF:',xuff250(1:lenx)
       if (lenb.eq.0) then
          buff250=xuff250(1:lenx)
       else
          buff250=buff250(1:lenb)//","//xuff250(1:lenx)
       end if
       call chop0(buff250,250)
       lenb=length(buff250,250,10)
    end do
    lenb=length(buff250,250,10)
    if(obs_bdeb)write(*,*)myname,'Buff:',buff250(1:lenb)
    lenv=length(varname,80,10)
    xuff250=varname(1:lenv)//"("//buff250(1:lenb)//")";
    call chop0(xuff250,250);
    observation_pretty=xuff250
  end function observation_pretty
  !
  ! parse and compile index expression
  !
  subroutine observation_compile(css,crc250,irc)
    type(obs_session), pointer :: css   ! session structure
    character*250 :: crc250         ! error message string
    integer :: irc                  ! error return code (0=ok)
    character*22 :: myname="observation_compile"
    integer :: ii,jj
    type(obs_target), pointer :: currenttarget => null()
    if(obs_bdeb)write(*,*)myname,' Entering.',obs_bdeb
    call observation_makeTargetList(css,crc250,irc)
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," Error return from maketargetlist.")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    if(obs_bdeb)write(*,*)myname,' Parsing.',css%ind_eset
    if (css%ind_eset) then
       call parse_open(css%ind_pe,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from parse_open.")
          return
       end if
       call parse_parsef(css%ind_pe,css%ind_exp250(1:css%ind_lene),css%trg80,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from parsef.")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       call parse_used(css%ind_pe,css%trg_req)
       if(obs_bdeb)write(*,*)myname,' Parsed.',css%ind_exp250(1:css%ind_lene),associated(css%ind_pe)
    end if
    if (css%dyn_set) then
       ! parse position expressions
       do ii=1,css%ntarget
          select case (css%trg_type(ii)) ! process position
          case (parse_internal)
             call parse_parsef(css%trg_psp(ii)%ptr,&
                  & css%trg_pos250(ii)(1:css%trg_lenp(ii)),&
                  & css%int_var,crc250,irc)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from parsef.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
          case (parse_expression)
             if(obs_bdeb)then
                write(*,*)myname," Compiling pos: '"//&
                     & css%trg_pos250(ii)(1:css%trg_lenp(ii))//"'",ii
                do jj=1,size(css%dyn_var)
                   write(*,'(A,A,I0,A)')myname,"     dyn_var(",jj,") = '"//&
                        & css%dyn_var(jj)(1:css%dyn_lenv(jj))//"'"
                end do
             end if
             if (obs_bdeb)write(*,*)myname,' Dynamic var:',ii,&
                  & (" "//css%dyn_var(jj)(1:css%dyn_lenv(jj)),jj=1,size(css%dyn_var))
             call parse_parsef(css%trg_psp(ii)%ptr,&
                  & css%trg_pos250(ii)(1:css%trg_lenp(ii)),&
                  & css%dyn_var,crc250,irc)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from parsef.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
          end select
       end do
    end if
    if(obs_bdeb)write(*,*)myname,' Done.'
    return
  end subroutine observation_compile
  !
  ! check if descr match observation targets, and evaluate expression
  ! ...load next target into memory...
  !
  logical function observation_eval(css,bok,crc250,irc)
    type(obs_session), pointer :: css
    logical :: bok           ! is everything ok?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_eval"
    integer :: ii,dyn_pos,ipos
    logical :: bbok
    if(obs_bdeb) write(*,*)myname,' Entering.',css%int_val
    if(obs_bdeb)write(*,*)myname,"ind_pe:",associated(css%ind_pe),css%sid
    !if(obs_bdeb) write(*,*)myname,'Position.',ntarget,css%dyn_pos,css%dyn_cnt,css%dyn_max
    !
    ! get next position
    !
    bbok=(css%dyn_pos.le.ktdexl)
    observation_eval=bbok
    if (.not.bbok) return
    bok=.true.
    if (css%ntarget== 0) then ! no targets to evaluate
       return
    else
       if (css%dyn_cnt.eq.0.or.css%dyn_cnt.ge.css%dyn_max) then ! read next observation
          if (obs_bdeb)write(*,*)myname,' Assigning:',css%ntarget,ktdexl
          css%dyn_cnt=1
          do ii=1,css%ntarget
             select case (css%trg_type(ii))
             case (parse_delay) ! delayed processing
             case (parse_empty)
                if (observation_getPos(css,css%trg_descr(ii))) then ! find next descr
                   css%trg_seq(ii)=css%dyn_pos
                   ipos=css%trg_seq(ii)+(isubset-1)*KEL
                   css%trg_val(ii)=values(ipos)
                   css%trg_vok(ii)=(values(ipos).ne.rvind)
                   if (.not.css%trg_vok(ii).and.css%trg_req(ii)) then
                      write(css%currentfile%hint80(2),'(A," (",I0,"), value=undefined")')&
                           & css%trg80(ii)(1:css%trg_lent(ii)),ii,dyn_pos
                      bok=.false. ! missing target value
                   end if
                   if (obs_bdeb)write(*,*)myname,' Found:',ii,css%trg_seq(ii),css%trg_descr(ii)
                else
                   bbok=.false.
                end if
             case (parse_constant)
                ipos=css%trg_seq(ii)+(isubset-1)*KEL
                css%trg_val(ii)=values(ipos)
                css%trg_vok(ii)=(values(ipos).ne.rvind)
                if (.not.css%trg_vok(ii).and.css%trg_req(ii)) then
                   write(css%currentfile%hint80(2),'(A," (",I0,"), value undefined at:",I0)')&
                        & css%trg80(ii)(1:css%trg_lent(ii)),ii,css%trg_seq(ii)
                   bok=.false. ! missing target value
                end if
             case (parse_internal)
                if (obs_bdeb)write(*,*)myname,' Internals:',css%int_val
                css%trg_val(ii)=parse_evalf(css%trg_psp(ii)%ptr,css%int_val,crc250,irc)
                if (irc.ne.0) then
                   call observation_errorappend(crc250,myname)
                   call observation_errorappend(crc250," Error return from evalf.")
                   call observation_errorappendi(crc250,irc)
                   call observation_errorappend(crc250,"\n")
                   return
                end if
                css%trg_vok(ii)=.true.
                if (obs_bdeb)write(*,*)myname,' Internal:',ii,css%trg_val(ii)
             case (parse_variable)
                if (observation_getPos(css,css%trg_descr(ii))) then ! find next descr
                   css%trg_seq(ii)=css%dyn_pos
                   ipos=css%trg_seq(ii)+(isubset-1)*KEL
                   css%trg_val(ii)=values(ipos)
                   css%trg_vok(ii)=(values(ipos).ne.rvind)
                   css%dyn_val(css%trg_ind(ii))=css%dyn_pos
                   if (.not.css%trg_vok(ii).and.css%trg_req(ii)) then
                      write(css%currentfile%hint80(2),'(A," (",I0,"), value undefined at:",I0)')&
                           & css%trg80(ii)(1:css%trg_lent(ii)),ii,css%trg_seq(ii)
                      bok=.false. ! missing target value
                   end if
                   if (obs_bdeb)write(*,*)myname,' Found:',css%trg_seq(ii),css%trg_descr(ii)
                else
                   bbok=.false.
                end if
             case (parse_expression)
                dyn_pos=nint(parse_evalf(css%trg_psp(ii)%ptr,css%dyn_val,crc250,irc))
                if (irc.ne.0) then
                   call observation_errorappend(crc250,myname)
                   call observation_errorappend(crc250," Error return from evalf.")
                   call observation_errorappendi(crc250,irc)
                   call observation_errorappend(crc250,"\n")
                   return
                end if
                if (obs_bdeb)write(*,*)myname,' Dynamic pos:',ii,dyn_pos,nint(css%dyn_val)
                if (dyn_pos.ge.1.and.dyn_pos.le.ktdexl) then ! out of bounds...
                   css%trg_seq(ii)=dyn_pos
                   if (css%trg_descr(ii).ne.ktdexp(dyn_pos)) then
                      write(css%currentfile%hint80(2),&
                           & '(A," (",I0,"), DESCR(",I0,")=",I0," expected ",I0)')&
                           & css%trg80(ii)(1:css%trg_lent(ii)),ii,dyn_pos,&
                           & ktdexp(dyn_pos),css%trg_descr(ii)
                      bok=.false.
                   else
                      ipos=css%trg_seq(ii)+(isubset-1)*KEL
                      css%trg_val(ii)=values(ipos)
                      css%trg_vok(ii)=(values(ipos).ne.rvind)
                      if (.not.css%trg_vok(ii).and.css%trg_req(ii)) then
                         write(css%currentfile%hint80(2),'(A," (",I0,"), value undefined at:",I0)')&
                              & css%trg80(ii)(1:css%trg_lent(ii)),ii,css%trg_seq(ii)

                         bok=.false. ! missing target value
                      end if
                   end if
                else
                   write(css%currentfile%hint80(2),'(A," (",I0,"), out of bounds at:",I0)')&
                        & css%trg80(ii)(1:css%trg_lent(ii)),ii,dyn_pos
                   bok=.false. ! reject observation...
                end if
             end select
             if (obs_bdeb) then
                if (css%trg_val(ii).gt.1.0D10) then
                   write(*,*)myname,' zzzzzzzzzzzzzz Invalid value:',&
                        & ii,css%trg_vok(ii),css%trg_val(ii),(css%trg_val(ii).eq.rvind),bok
                end if
             end if
          end do
          if (bok.and.css%ind_eset) then
             if(obs_bdeb)write(*,*)myname,"ind_pe:",associated(css%ind_pe),css%sid
             if(obs_bdeb)write(*,*)myname,"Calling parse_evals.",&
                  & associated(css%ind_pe),allocated(css%trg_val),css%dyn_pos
             call parse_evals(css%ind_pe,css%trg_val,css%trg_vok,&
                  & css%trg_val(css%ntrg),css%trg_vok(css%ntrg),crc250,irc)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from evals.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
          end if
          if(obs_bdeb)write(*,*)myname,"Here ind_pe:",associated(css%ind_pe),css%sid
          if (bok.and.css%ind_tset) then
             call parse_evals(css%ind_pt,css%trg_val,css%trg_vok,&
                  & css%trg_val(css%ntrg),css%trg_vok(css%ntrg),crc250,irc)
             if (irc.ne.0) then
                call observation_errorappend(crc250,myname)
                call observation_errorappend(crc250," Error return from evals.")
                call observation_errorappendi(crc250,irc)
                call observation_errorappend(crc250,"\n")
                return
             end if
          end if
          if (bok) then
             css%ind_val=css%trg_val(css%ntrg)
          end if
          ! extract duplicate indexes...
          call observation_pullTargets(css,crc250,irc)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from pullTargets.")
             call observation_errorappend(crc250,"\n")
             return
          end if
          if (css%dyn_pos.eq.0) then ! no search, i.e. 1 iteration only
             css%dyn_pos=ktdexl+1 ! force stop next time...
          end if
          css%dyn_bok=bok
       else ! make duplicate of existing obs
          css%dyn_cnt=css%dyn_cnt+1
          ! extract duplicate indexes...
          call observation_pullTargets(css,crc250,irc)
          if (irc.ne.0) then
             call observation_errorappend(crc250,myname)
             call observation_errorappend(crc250," Error return from pullTargets.")
             call observation_errorappend(crc250,"\n")
             return
          end if
          bok=css%dyn_bok
       end if
    end if
    observation_eval=bbok
    if(obs_bdeb)write(*,*)myname,"Done ind_pe:",associated(css%ind_pe),css%sid
    return
  end function observation_eval
  !
  ! calculate the duplicate target locations from count
  !
  subroutine observation_pullTargets(css,crc250,irc)
    type(obs_session), pointer :: css
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_pulltargets"
    integer :: ii,jj,kk
    jj=css%dyn_cnt
    do ii=css%ndup,1,-1
       css%trg_val(css%dup_ind(ii))=int(jj/css%dup_inc(ii-1)) + &
            & nint(css%trg_minval(css%dup_ind(ii)))-1
       if (obs_bdeb) write(*,'(X,A,X,A,I0,A,I0,3X,I0)')myname,' Target(',css%dup_ind(ii),') = ',&
            & nint(css%trg_val(css%dup_ind(ii))),ii
       jj=mod(jj,css%dup_inc(ii-1))
    end do
    return
  end subroutine observation_pullTargets
  !
  ! search for next descriptor
  !
  logical function observation_getPos(css,descr)
    type(obs_session), pointer :: css
    integer :: descr
    SEARCH : do
       css%dyn_pos=css%dyn_pos+1
       if (css%dyn_pos.gt.ktdexl) then
          observation_getPos=.false.
          exit SEARCH
       else if (descr.eq.KTDEXP(css%dyn_pos)) then
          observation_getPos=.true.
          exit SEARCH
       end if
    end do SEARCH
    return
  end function observation_getPos
  !
  ! check if message descriptors match target descriptors
  !
  subroutine observation_checkDescr(css,bok,crc250,irc)
    type(obs_session), pointer :: css
    logical :: bok           ! is everything ok?
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_checkDescr"
    integer :: ii,jj
    logical bok1,bok2
    if(obs_bdeb) write(*,*)myname,'Entering.',css%ntarget,css%category,ksec1(6),css%subcategory,ksec1(7)
    bok=.true.
    if (css%category .eq. ksec1(6) .and.css%subcategory .eq. ksec1(7)) then
       !if(obs_bdeb) write(*,*)myname,'Here.'
       css%currentfile%mok(5)=css%currentfile%mok(5)+1 ! other BUFRtype/subtype
       if (css%ntarget== 0) then ! no targets to evaluate
          return
       else
          bok1=.true.
          bok2=.true.
          do ii=1,css%ntarget
             ! if(obs_bdeb) write(*,*)myname,'There.',ii
             select case (css%trg_type(ii))
             case (parse_empty)
             case (parse_constant)
                if (bok) then
                   if (css%trg_seq(ii).lt.1.or.css%trg_seq(ii).gt.ktdexl) then
                      if(obs_bdeb)write(*,*)myname,'Failed limit:',ii,ktdexl,css%trg_seq(ii)
                      bok1=.false.
                      bok=.false.
                   end if
                end if
                if (bok) then
                   if (ktdexp(css%trg_seq(ii)).ne.css%trg_descr(ii)) then
                      if(obs_bdeb)then
                         do jj=1,css%ntarget
                            if (ktdexp(css%trg_seq(jj)).ne.css%trg_descr(jj)) then
                               write(*,'(X,I3,X,A20,I8,A,I0,A)') &
                                    & jj,css%trg80(jj)(1:css%trg_lent(jj))//'=',css%trg_descr(jj),&
                                    & ' (',ktdexp(css%trg_seq(jj)),') !!'
                            else 
                               write(*,'(X,I3,X,A20,I8,A,I0,A)') &
                                    & jj,css%trg80(jj)(1:css%trg_lent(jj))//'=',css%trg_descr(jj),&
                                    & ' (',ktdexp(css%trg_seq(jj)),')'
                            end if
                         end do
                         write(*,'(X,A,3(2X,A,I0))')&
                              & myname,'Failed sanity:',ii,&
                              & css%trg80(ii)(1:css%trg_lent(ii))//'=',css%trg_descr(ii),&
                              & ' found=',ktdexp(css%trg_seq(ii))
                      end if
                      
                      bok2=.false.
                      css%currentfile%hint80(7)=css%trg80(ii)(1:25)
                      bok=.false.
                      ! ! bah... abort anyway...
                      ! irc=945
                      ! call observation_errorappend(crc250,myname)
                      ! call observation_errorappendi(crc250,ii)
                      ! call observation_errorappend(crc250,"Failed sanity check for target "// &
                      !      & css%trg80(ii)(1:css%trg_lent(ii))//",")
                      ! call observation_errorappendi(crc250,css%trg_descr(ii))
                      ! call observation_errorappend(crc250,"!=")
                      ! call observation_errorappendi(crc250,ktdexp(css%trg_seq(ii)))
                      ! RETURN
                   end if
                end if
             case (parse_internal)
             case (parse_variable)
             case (parse_expression)
             end select
          end do
          if (bok1) then
             css%currentfile%mok(6)=css%currentfile%mok(6)+1 ! limits are ok
             if (bok2) then
                css%currentfile%mok(7)=css%currentfile%mok(7)+1 ! descriptors match
             else
                !write(*,*)myname,'***FAILED SANITY:',ii,ktdexp(css%trg_seq(ii)),css%trg_descr(ii)
                css%currentfile%mrm(7)=css%currentfile%mrm(7)+1 ! descriptors do not match
             end if
          else
             css%currentfile%mrm(6)=css%currentfile%mrm(6)+1 ! limits not ok
          end if
       end if
    else
       css%currentfile%mrm(5)=css%currentfile%mrm(5)+1 ! other BUFRtype/subtype
       bok=.false.
    end if
    if(obs_bdeb) write(*,*)myname,'OK.',css%currentfile%mok
    if(obs_bdeb) write(*,*)myname,'RM.',css%currentfile%mrm
    if(obs_bdeb) write(*,*)myname,'Done.',bok
    return
  end subroutine observation_checkDescr
  !
  ! terminate evaluation and parsing session
  !
  subroutine observation_terminate(css,crc250,irc)
    type(obs_session), pointer :: css
    character*250 :: crc250  ! error message string
    integer :: irc           ! error return code (0=ok)
    character*22 :: myname="observation_terminate"
    if (css%ind_eset) then
       if(obs_bdeb)write(*,*)myname,'Closing ind_pe:',associated(css%ind_pe),css%sid
       call parse_close(css%ind_pe,crc250,irc)
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," Error return from parse_close.")
          return
       end if
    end if
    return
  end subroutine observation_terminate
  !
  subroutine observation_filestartxml(css,ounit,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: ounit
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="observation_fileStartXml"
    if (associated(css%currentFile)) then
       write(ounit,'(2X,A)',iostat=irc)"<observationFile file='"//css%currentFile%fn250(1:css%currentFile%lenf)//"'>"
    else
       write(ounit,'(2X,A)',iostat=irc)"<observationFile>"
    end if
    if (irc.ne.0) then
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250," unable to write to file ")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
       return
    end if
    return
  end subroutine observation_filestartxml
  !
  subroutine observation_writexml(css,ounit,locid,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: ounit
    integer :: locid
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="observation_writexml"
    character*250 :: buff250
    character*50 :: s1, s2, s3, s4
    integer :: ii,jj
    integer :: len1,len2,len3,len4,lenb=0
    integer, external :: length
    integer :: iktype,id,idd,seq,ipos
    logical :: bbok
    character*9 :: cident
    integer :: cnt
    logical :: bok
    real :: rlat1,rlat2,rlon1,rlon2,rlat,rlon
    if (isubset .le. nsubset.and.bread) then ! isubset .le. nsubset (always true)
       bread=.false. ! wait for next message...
       ! IF (observation_eval(css,bok,crc250,irc)) THEN
       !   ! valid obs-target in memory
       ! END IF
       ! IF(IRC.NE.0) THEN
       !    call observation_errorappend(crc250,myname)
       !    call observation_errorappend(crc250," Error return from eval.");
       !    call observation_errorappend(crc250,"\n")
       !    RETURN
       ! END IF
       write(s1,'(I0)') locid
       call chop0(s1,50)
       len1=length(s1,50,10)
       write(ounit,'(3X,A,I0,A)',iostat=irc)"<message id='"//s1(1:len1)//"' subset='",isubset,"'>"
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," unable to write to file ")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       !
       ! add target values
       !
       do ii=1,css%ntrg
          s1=css%trg80(ii)(1:50) ; call chop0(s1,50); len1=length(s1,50,10)   ! element identification
          IF (len1.ne.0) then
             s1=" name='"//s1(1:len1)//"'"
             len1=len1+8
          end if
          call observation_wash(css%trg_val(ii),s2,len2)
          if (len2.ne.0) then
             s2=" value='"//s2(1:len2)//"'"
             len2=len2+9
          end if
          if (css%trg_lval(1,ii)) then
             call observation_wash(css%trg_minval(ii),s3,len3)
             if (len3.ne.0) then
                s3=" min='"//s3(1:len3)//"'"
                len3=len3+7
             end if
          else
             len3=0
          end if
          if (css%trg_lval(2,ii)) then
             call observation_wash(css%trg_maxval(ii),s4,len4)
             if (len4.ne.0) then
                s4=" max='"//s4(1:len4)//"'"
                len4=len4+7
             end if
          else
             len4=0
          end if
          write(buff250,'(A)')"<target "//s1(1:len1)//s2(1:len2)//s3(1:len3)//s4(1:len4)//"/>"
          call wo(ounit,4,buff250)
       end do
       !
       ! write BUFR sequence
       !
       if (obs_bdeb) then
          !
          ! section 0
          write(buff250,'(A,I0,A)')"<sec0 pos='1' info='Length of section 0 (bytes)' val='",ksec0(1),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec0 pos='2' info='Total length of Bufr message (bytes)' val='",ksec0(2),"'/>";
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec0 pos='3' info='Bufr Edition number' val='",ksec0(3),"'/>"
          call wo(ounit,4,buff250)
          !
          ! section 1
          write(buff250,'(A,I0,A)')"<sec1 pos='1' info='Length of section 1 (bytes)' val='",ksec1(1),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='2' info='Bufr Edition number' val='",ksec1(2),"'/>"
          call wo(ounit,4,buff250)
          if(ksec1(2).ge.3) then
             write(buff250,'(A,I0,A)')"<sec1 pos='16' info='Originating sub-centre' val='",ksec1(16),"'/>"
             call wo(ounit,4,buff250)
          end if
          write(buff250,'(A,I0,A)')"<sec1 pos='3' info='Originating centre' val='",ksec1(3),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='4' info='Update sequence number' val='",ksec1(4),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='5' info='Flag (presence of section 2)' val='",ksec1(5),"'/>"
          call wo(ounit,4,buff250)
       end if
       call observation_getType(ksec1(6),ksec1(7),s1,s2,crc250,irc) 
       call chop0(s1,50); len1=length(s1,50,10)
       call chop0(s2,50); len2=length(s2,50,10)
       !
       if (len1.eq.0) then
          write(buff250,'(A,I0,A)')"<sec1 pos='6' info='Bufr message type' val='",ksec1(6),"'/>"
       else
          write(buff250,'(A,I0,A)')"<sec1 pos='6' info='Bufr message type' val='",ksec1(6),"' type='"//s1(1:len1)//"'/>"
       end if
       call wo(ounit,4,buff250)
       if (len2.eq.0) then
          write(buff250,'(A,I0,A)')"<sec1 pos='7' info='Bufr message subtype' val='",ksec1(7),"'/>"
       else
          write(buff250,'(A,I0,A)')"<sec1 pos='7' info='Bufr message subtype' val='",ksec1(7),"' type='"//s2(1:len2)//"'/>"
       end if
       call wo(ounit,4,buff250)
       if (obs_bdeb) then
          write(buff250,'(A,I0,A)')"<sec1 pos='8' info='Version number of local table' val='",ksec1(8),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='9' info='Year' val='",ksec1(9),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='10' info='Month' val='",ksec1(10),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='11' info='Day' val='",ksec1(11),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='12' info='Hour' val='",ksec1(12),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='13' info='Minute' val='",ksec1(13),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='15' info='Version number of Master table' val='",ksec1(15),"'/>"
          call wo(ounit,4,buff250)
          write(buff250,'(A,I0,A)')"<sec1 pos='14' info='Bufr Master table' val='",ksec1(14),"'/>"
          call wo(ounit,4,buff250)
          !
          ! section 2
          IF(KSUP(2).LE.1) THEN
             write(buff250,'(A)')"<sec2 info='RDB key not defined in section 2'/>"
             call wo(ounit,4,buff250)
          else
             write(buff250,'(A,I0,A)')"<sec3 pos='1' info='Length of section 2' val='",key(1),"'/>"
             call wo(ounit,4,buff250)
             IKTYPE=0
             IF(KEY(2).EQ.2) IKTYPE=2
             IF(KEY(2).EQ.3) IKTYPE=2
             IF(KEY(2).EQ.12)IKTYPE=2
             IF(KEY(2).EQ.08)IKTYPE=2
             IF(IKTYPE.EQ.0.AND.KSUP(6).GT.1) IKTYPE=2
             IF(IKTYPE.EQ.2) THEN
                IF(KEY(2).EQ.2.OR.KEY(2).EQ.3 &
                     & .OR.KEY(2).EQ.12) THEN
                   RLAT1=(KEY(11)-9000000)/100000.
                   RLON1=(KEY(10)-18000000)/100000.
                   RLAT2=(KEY(13)-9000000)/100000.
                   RLON2=(KEY(12)-18000000)/100000.
                   write(s1,*) rlat1; call chop0(s1,50); len1=length(s1,50,10)
                   write(s2,*) rlon1; call chop0(s2,50); len2=length(s2,50,10)
                   write(s3,*) rlat2; call chop0(s3,50); len3=length(s3,50,10)
                   write(s4,*) rlon2; call chop0(s4,50); len4=length(s4,50,10)
                   write(buff250,'(A,I0,A)')"<sec2 pos='2' info='RDB data type' val='",key(2),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='3' info=''RDB data subtype' val='",key(3),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='4' info='Year' val='",key(4),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='5' info='Month' val='",key(5),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='6' info='Day' val='",key(6),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='7' info='Hour' val='",key(7),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='8' info='Minute' val='",key(8),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='9' info='Second' val='",key(9),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A)')"<sec2 pos='10' info='Longitude 1' val='"//s2(1:len2)//"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A)')"<sec2 pos='11' info='Latitude  1' val='"//S1(1:len1)//"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A)')"<sec2 pos='12' info='Longitude 2' val='"//S4(1:len4)//"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A)')"<sec2 pos='13' info='Latitude  2' val='"//S3(1:len3)//"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='14' info='Number of observations' val='",key(14),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='15' info='Identifier' val='",key(15),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='25' info='Total Bufr message length' val='",key(25),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='26' info='Day    (RDB insertion' val='",key(26),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='27' info='Hour   (RDB insertion' val='",key(27),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='28' info='Minute( (RDB insertion' val='",key(28),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='29' info='Second (RDB insertion' val='",key(29),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='30' info='Day    (MDB arrival' val='",key(30),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='31' info='Hour   (MDB arrival' val='",key(31),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='32' info='Minute (MDB arrival' val='",key(32),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='33' info='Second (MDB arrival' val='",key(33),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='34' info='Correction number' val='",key(34),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='35' info='Part of message' val='",key(35),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='37' info='Correction number' val='",key(37),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='38' info='Part of message' val='",key(38),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='40' info='Correction number' val='",key(40),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='41' info='Part of message' val='",key(41),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='43' info='Correction number' val='",key(43),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='44' info='Part of message' val='",key(44),"'/>"
                   call wo(ounit,4,buff250)
                   write(buff250,'(A,I0,A)')"<sec2 pos='46' info='Quality control % conf' val='",key(46),"'/>"
                   call wo(ounit,4,buff250)
                ELSE
                   RLAT1=(KEY(11)-9000000)/100000.
                   RLON1=(KEY(10)-18000000)/100000.
                   write(s1,*) rlat1; call chop0(s1,50); len1=length(s1,50,10)
                   write(s2,*) rlon1; call chop0(s2,50); len2=length(s2,50,10)
                   IDD=0
                   CIDENT=' '
                   DO ID=16,24
                      IDD=IDD+1
                      CIDENT(IDD:IDD)=CHAR(KEY(ID))
                   end do
                   write(buff250,'(A,I0,A)')"<sec2 pos='2' info='RDB data type' val='", KEY(2),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='3' info='RDB data subtype' val='", KEY(3),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='4' info='Year' val='", KEY(4),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='5' info='Month' val='", KEY(5),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='6' info='Day' val='", KEY(6),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='7' info='Hour' val='", KEY(7),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='8' info='Minute' val='", KEY(8),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='9' info='Second' val='", KEY(9),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A)')"<sec2 pos='11' info='Latitude  1'"//s1(1:len1)//"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A)')"<sec2 pos='10' info='Longitude 1'"//s2(1:len2)//"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 info='Identifier' val='", CIDENT,"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='25' info='Total Bufr message length' val='", KEY(25),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='26' info='Day    (RDB insertion' val='", KEY(26),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='27' info='Hour   (RDB insertion' val='", KEY(27),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='28' info='Minute (RDB insertion' val='", KEY(28),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='29' info='Second (RDB insertion' val='", KEY(29),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='30' info='Day    (MDB arrival' val='", KEY(30),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='31' info='Hour   (MDB arrival' val='", KEY(31),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='32' info='Minute (MDB arrival' val='", KEY(32),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='33' info='Second (MDB arrival' val='", KEY(33),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='34' info='Correction number' val='", KEY(34),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='35' info='Part of message' val='", KEY(35),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='37' info='Correction number' val='", KEY(37),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='38' info='Part of message' val='", KEY(38),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='40' info='Correction number' val='", KEY(40),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='41' info='Part of message' val='", KEY(41),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='43' info='Correction number' val='", KEY(43),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='44' info='Part of message' val='", KEY(44),"'/>"
                   call wo(ounit,4,buff250);
                   write(buff250,'(A,I0,A)')"<sec2 pos='46' info='Quality control % conf'", KEY(46),"'/>"
                   call wo(ounit,4,buff250);
                END IF
             end if
          end if
          !
          ! section 3
          !
          write(buff250,'(A,I0,A)')"<sec3 pos='1' info='Length of section 3 (bytes)'", ksec3(1),"'/>"
          call wo(ounit,4,buff250);
          write(buff250,'(A,I0,A)')"<sec3 pos='2' info='Reserved'", ksec3(2),"'/>"
          call wo(ounit,4,buff250);
          write(buff250,'(A,I0,A)')"<sec3 pos='3' info='Number of data subsets'", ksec3(3),"'/>"
          call wo(ounit,4,buff250);
          write(buff250,'(A,I0,A)')"<sec3 pos='4' info='Flag (data type/data compression)'", ksec3(4),"'/>"
          call wo(ounit,4,buff250);
       end if
       !write(*,*)myname,'Report D:',KTDLEN
       if (obs_bdeb) then
          write(buff250,'(A,I0,A)')"<sec3 type='unexpanded' count='",KTDLEN,"'>"
          call wo(ounit,4,buff250);
          DO II=1,KTDLEN
             write(buff250,'(A,I0,A,I0,A)')"<unexpanded pos='",ii,"' descr='",KTDLST(II),"'/>"
             call wo(ounit,4,buff250);
          end do
          write(buff250,'(A)')"</sec3>"
          call wo(ounit,4,buff250);
       end if
       !write(*,*)myname,'Report D:',KTDEXL
       !
       if (.not.css%ignuni.or..not.css%ignden.or..not.css%ignval) then
          write(buff250,'(A,I0,A)')"<sec3 type='expanded' count='",KTDEXL,"'>"
          call wo(ounit,4,buff250);
          cnt=0
          EXPANDED: DO II=1,KTDEXL
             IPOS=II+(isubset-1)*KEL
             if ((values(ipos).eq.rvind.and..not.css%ignmis).or.values(ipos).ne.rvind) then
                write(buff250,'(A,I0,A)') "<expanded pos='",ii,"'"
                call chop0(buff250,250)
                lenb=length(buff250,250,20)
                if (.not. css%ignder) then
                   write(s1,'(A,I0,A)')"descr='",KTDEXP(II),"'";call chop0(s1,50); len1=length(s1,50,10) 
                   buff250=buff250(1:lenb)//" "//s1(1:len1)
                   lenb=lenb+1+len1
                end if
                if (.not.css%ignval) then
                   if (ii.gt.1.and.ktdexp(ii).eq.ktdexp(max(1,ii-1)).and.&
                        & values(ipos).eq.values(max(1,ipos-1))) then
                      ! do nothing
                   else if (values(ipos).eq.RVIND) then ! missing
                      s1="MISSING";call chop0(s1,50); len2=length(s1,50,10) 
                      buff250=buff250(1:lenb)//" value='"//s1(1:len2)//"'"
                      call chop0(buff250,250)
                      lenb=length(buff250,250,20)
                      if (.not.css%ignden) then
                         buff250=buff250(1:lenb)//" name='"//cnames(ii)//"'"
                         call chop0(buff250,250)
                         lenb=length(buff250,250,20)
                      end if
                   else
                      call observation_wash(values(ipos),s1,len1)
                      buff250=buff250(1:lenb)//" value='"//s1(1:len1)//"'"
                      call chop0(buff250,250)
                      lenb=length(buff250,250,20)
                      if (.not.css%ignden) then
                         buff250=buff250(1:lenb)//" name='"//cnames(ii)//"'"
                         call chop0(buff250,250)
                         lenb=length(buff250,250,20)
                      end if
                      if (.not.css%ignuni) then
                         buff250=buff250(1:lenb)//" unit='"//cunits(ii)//"'"
                         call chop0(buff250,250)
                         lenb=length(buff250,250,20)
                      end if
                      s1=cvals(ii);call chop0(s1,50);len1=length(s1,50,10)
                      if (len1.gt.0)then
                         buff250=buff250(1:lenb)//" code='"//s1(1:len1)//"'"
                         call chop0(buff250,250)
                         lenb=length(buff250,250,20)
                      end if
                      buff250=buff250(1:lenb)//"/>"
                      call wo(ounit,4,buff250);
                      cnt=cnt+1
                      !if (cnt.gt.5000) exit EXPANDED
                   end if
                end if
             end if
          end do EXPANDED
          write(buff250,'(A)')"</sec3>"
          call wo(ounit,4,buff250);
       end if
       write(ounit,'(3X,A)')"</message>"
    else if (isubset .gt. nsubset) then
       if(obs_bdeb)write(*,'(X,A,X,A,2(I0,A))')myname,' Invalid isubset ',&
            &isubset,' (',nsubset,')'
       irc=845
       call observation_errorappend(crc250,myname)
       call observation_errorappend(crc250,"This should never happen...")
       call observation_errorappendi(crc250,irc)
       call observation_errorappend(crc250,"\n")
    end if
    return
  end subroutine observation_writexml
  !
  subroutine wo(ounit,ind,buff250)
    integer :: ounit
    integer :: ind
    character*250 :: buff250
    integer :: lenb
    integer, external :: length
    character*20 :: blank20="                    "
    call chop0(buff250,250)
    lenb=length(buff250,250,10)
    write(ounit,'(A)')blank20(1:max(0,min(20,ind)))//buff250(1:lenb)
    return
  end subroutine wo
  !
  subroutine observation_filestopxml(css,ounit,crc250,irc)
    type(obs_session), pointer :: css !  current session
    integer :: ounit
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="observation_fileStopXml"
    integer :: ii
    integer :: len1,len2,len3,len4
    integer, external :: length
    character*50 :: s1,s2,s3,s4
    type(obs_mainCategory), pointer :: currentCat !  current file
    type(obs_subCategory), pointer :: currentSub !  current file
    ! write summary
    if (associated(css%currentFile)) then
       write(ounit,'(3X,A)',iostat=irc)"<summary>"
       if (irc.ne.0) then
          call observation_errorappend(crc250,myname)
          call observation_errorappend(crc250," unable to write to file ")
          call observation_errorappendi(crc250,irc)
          call observation_errorappend(crc250,"\n")
          return
       end if
       if (css%currentFile%mok(1).eq.css%currentFile%mok(7)) then
          write(ounit,'(4X,A,I0,A,I0,A)')"<messages found='",css%currentFile%mok(1),&
               & "' accepted='",css%currentFile%mok(7),"'/>"
       else
          do ii=1,10
             call chop0(css%currentFile%hint80(ii),80)
             css%currentFile%lenh(ii)=length(css%currentFile%hint80(ii),80,1)
          end do
          write(ounit,'(4X,A,4(I0,A))')"<messages found='",css%currentFile%mok(1),&
               & "' accepted='",css%currentFile%mok(7),&
               & "' type='",css%category,"' subtype='",css%subcategory,"'>"
          if (css%currentFile%mrm(2).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
               & css%currentFile%mrm(2),&
               & "' reason='unable to decode header.'/>"
          if (css%currentFile%mrm(3).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
               & css%currentFile%mrm(3),&
               & "' reason='unable to decode body.'/>"
          if (css%currentFile%mrm(4).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
               & css%currentFile%mrm(4),&
               & "' reason='unable to decode description.'/>"
          if (css%currentFile%mrm(5).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
               & css%currentFile%mrm(5),&
               & "' reason='Other BUFR/sub-type.'/>"
          if (css%currentFile%mrm(6).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
               & css%currentFile%mrm(6),&
               & "' reason='DESCR out of range.'/>"
          if (css%currentFile%lenh(7).eq.0) then     
             if (css%currentFile%mrm(7).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
                  & css%currentFile%mrm(7),&
                  & "' reason='DESCR mismatch.'"
          else
             if (css%currentFile%mrm(7).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
                  & css%currentFile%mrm(7),&
                  & "' reason='DESCR mismatch.' hint='"//&
                  & css%currentFile%hint80(7)(1:css%currentFile%lenh(7))//"'/>"
          end if
          ! make list of the messages found
          currentCat=>css%currentFile%firstCategory%next
          do while (.not.associated(currentCat,target=css%currentFile%lastCategory)) 
             call observation_getType(currentCat%category,0,s1,s2,crc250,irc) 
             call chop0(s1,50); len1=length(s1,50,10)
             call chop0(s2,50); len2=length(s2,50,10)
             if (len1.ne.0) then
                write(ounit,'(5X,A,3(I0,A))',iostat=irc) "<msg type='",currentCat%category,&
                     & "' cnt='",currentCat%cnt,"' nsub='",currentCat%nsub,"' info='"//s1(1:len1)//"'>"
             else
                write(ounit,'(5X,A,3(I0,A))',iostat=irc) "<msg type='",currentCat%category,&
                     & "' cnt='",currentCat%cnt,"' nsub='",currentCat%nsub,"'>"
             end if
             currentSub=> currentCat%firstSubCategory%next
             do while (.not.associated(currentSub,target=currentCat%lastSubCategory)) 
                call observation_getType(currentCat%category,currentSub%subcategory,s1,s2,crc250,irc) 
                call chop0(s1,50); len1=length(s1,50,10)
                call chop0(s2,50); len2=length(s2,50,10)
                if (len2.ne.0) then
                   write(ounit,'(7X,A,2(I0,A))',iostat=irc) "<sub type='",&
                        & currentSub%subcategory,"' cnt='",currentSub%cnt,"' info='"//s2(1:len2)//"'/>"
                else
                   write(ounit,'(7X,A,2(I0,A))',iostat=irc) "<sub type='",&
                        & currentSub%subcategory,"' cnt='",currentSub%cnt,"'/>"
                end if
                currentSub=>currentSub%next
             end do
             write(ounit,'(5X,A)',iostat=irc) "</msg>"
             currentCat=>currentCat%next
          end do
          !
          write(ounit,'(4X,A)')"</messages>"
       end if
       if (css%currentFile%ook(1).eq.css%currentFile%ook(5)) then
          write(ounit,'(4X,A,I0,A,I0,A)')"<locations found='",css%currentFile%ook(1),&
               & "' accepted='",css%currentFile%ook(5),"'/>"
       else
          do ii=1,10
             call chop0(css%currentFile%hint80(ii),80)
             css%currentFile%lenh(ii)=length(css%currentFile%hint80(ii),80,1)
          end do
          write(ounit,'(4X,A,I0,A,I0,A)')"<locations found='",css%currentFile%ook(1),&
               & "' accepted='",css%currentFile%ook(5),"'>"
          if (css%currentFile%orm(2).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
               & css%currentFile%orm(2),&
               & "' reason='evaluation error.' hint='"//&
               & css%currentFile%hint80(2)(1:css%currentFile%lenh(2))//"'/>"
          if (css%currentFile%orm(3).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
               & css%currentFile%orm(3),&
               & "' reason='outside index limits.'/>"
          if (css%currentFile%orm(4).ne.0) then
             write(ounit,'(5X,A,I0,A)')"<check removed='",css%currentFile%orm(4),&
                  & "' reason='outside target limits.'>"
             do ii=1,css%ntrg
                if (css%trg_orm(ii).ne.0) then
                   s1=css%trg80(ii)(1:50) ; call chop0(s1,50); &
                        & len1=length(s1,50,10)   ! element identification
                   IF (len1.ne.0) then
                      s1=" name='"//s1(1:len1)//"'"
                      len1=len1+8
                   end if
                   if (css%trg_lval(1,ii)) then
                      call observation_wash(css%trg_minval(ii),s3,len3)
                      if (len3.ne.0) then
                         s3=" min='"//s3(1:len3)//"'"
                         len3=len3+7
                      end if
                   else
                      len3=0
                   end if
                   if (css%trg_lval(2,ii)) then
                      call observation_wash(css%trg_maxval(ii),s4,len4)
                      if (len4.ne.0) then
                         s4=" max='"//s4(1:len4)//"'"
                         len4=len4+7
                      end if
                   else
                      len4=0
                   end if
                   write(ounit,'(6X,A,I0,A)')"<target removed='",css%trg_orm(ii),&
                        & "'"//s1(1:len1)//s3(1:len3)//s4(1:len4)//"/>"
                end if
             end do
             write(ounit,'(5X,A)')"</check>"
          end if
          if (css%currentFile%orm(5).ne.0) write(ounit,'(5X,A,I0,A)')"<check removed='",&
               & css%currentFile%orm(5),&
               & "' reason='rejected by obs filter.'/>"
          write(ounit,'(4X,A)')"</locations>"
       end if
       write(ounit,'(3X,A)')"</summary>"
    end if
    write(ounit,'(2X,A)')"</observationFile>"
    return
  end subroutine observation_filestopxml
  !
  ! convert real to pretty string
  !
  subroutine observation_wash(val,s2,len2)
    real :: val
    character*50 :: s2
    integer :: len2
    integer, external :: length
    integer :: jj
    write(s2,'(F0.10)') val; call chop0(s2,50); len2=length(s2,50,10) ! ignore last digit...
    if (len2.gt.1) then
       OUTER: do JJ=1,len2
          if (s2(JJ:JJ).eq.".") then
             INNER: do while (len2.gt.JJ.and.(s2(len2:len2).eq."0".or.s2(len2:len2).eq."."))
                len2=len2-1
             end do INNER
             exit OUTER
          end if
       end do OUTER
       if (len2.eq.1.and.s2(1:1).eq.".") then
          s2="0"
       else if (s2(len2:len2).eq.".") then
          len2=len2-1
       end if
    end if
    return
  end subroutine observation_wash
  !
end module observations
#__file: 'libobs/obs_getTableCValue.F90' 0100644    **DO NOT DELETE**
subroutine obs_getTableCValue(sid, code, subcode, val250, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  integer :: code
  integer :: subcode
  character*250 :: val250      ! bufr table c path
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "obs_getTableCValue"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  val250=observation_getCodeValue(code,subcode,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_getCodeValue.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_getTableCValue
#__file: 'libobs/obs_ignoreLabel.F90' 0100644    **DO NOT DELETE**
subroutine obs_ignoreLabel(sid, lab250, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: lab250      ! bufr table path
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "obs_ignoreLabel"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_ignorelabel(css,lab250,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_ignoreLabel.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_ignoreLabel
#__file: 'libobs/obs_loadCache.F90' 0100644    **DO NOT DELETE**
subroutine obs_loadCache(sid, path, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: path
  character*250 :: crc250
  integer :: irc
  character*250 :: buff250
  integer :: lenc
  character*25 :: myname = "obs_loadCache"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc,sid,path
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_loadcache(css,path,crc250,irc)
  if (irc.ne.0) then
     !write(*,*) 'pushFile Error.'
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_loadcache.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.',irc,sid
  return
end subroutine obs_loadCache
#__file: 'libobs/obs_makeCache.F90' 0100644    **DO NOT DELETE**
subroutine obs_makeCache(sid, path, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: path
  character*250 :: crc250
  integer :: irc
  character*250 :: buff250
  integer :: lenc
  character*25 :: myname = "obs_makeCache"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc,sid,path
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_makecache(css,path,crc250,irc)
  if (irc.ne.0) then
     !write(*,*) 'pushFile Error.'
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_makecache.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.',irc,sid
  return
end subroutine obs_makeCache
#__file: 'libobs/obs_openSession.F90' 0100644    **DO NOT DELETE**
subroutine obs_opensession(sid, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "obs_opensession"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call observation_opensession(sid,css,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_openSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.',sid
  return
end subroutine obs_opensession
#__file: 'libobs/obs_peekFile.F90' 0100644    **DO NOT DELETE**
subroutine obs_peekfile(sid,maxrep, nrep, rep250, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  integer :: maxrep
  integer :: nrep
  character*250 :: rep250(maxrep)
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "peekFile"
  type(obs_session), pointer :: css !  current session
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_stackpeek(css,maxrep,nrep,rep250,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_stackpeek.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  return
end subroutine obs_peekfile
#__file: 'libobs/obs_peekFileLen.F90' 0100644    **DO NOT DELETE**
subroutine obs_peekfilelen(sid,maxrep, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  integer :: maxrep
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "peekFileLen"
  type(obs_session), pointer :: css !  current session
  !write(*,*)myname,'Entering.'
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_stackpeeklen(css,maxrep,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_stackpeeklen.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*)myname,'Done.',maxrep
  return
end subroutine obs_peekfilelen
#__file: 'libobs/obs_popFile.F90' 0100644    **DO NOT DELETE**
subroutine obs_popfile(sid,path250,crc250,irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: path250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "popFile"
  type(obs_session), pointer :: css !  current session
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Entering.',irc
  call observation_stackpop(css,path250,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_stackpop.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.'
  return
end subroutine obs_popfile
#__file: 'libobs/obs_pushFile.F90' 0100644    **DO NOT DELETE**
subroutine obs_pushfile(sid, path250, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: path250
  character*250 :: crc250
  integer :: irc
  character*250 :: buff250
  integer :: lenc
  character*25 :: myname = "obs_pushFile"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc,sid,path250
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_stackpush(css,path250,crc250,irc)
  if (irc.ne.0) then
     !write(*,*) 'pushFile Error.'
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_stackpush.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.',irc,sid
  return
end subroutine obs_pushfile
#__file: 'libobs/obs_pushtarget.F90' 0100644    **DO NOT DELETE**
subroutine obs_pushtarget(sid,trg,pos,descr,info,&
     & min,max,crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character(len=*) :: trg      ! target name
  character(len=*) :: pos      ! target name
  character(len=*) :: descr      ! target name
  character(len=*) :: info      ! target name
  character(len=*) :: min      ! target name
  character(len=*) :: max      ! target name
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "pushtarget"
  !write(*,*) myname, 'Entering.',irc,sid
  type(obs_session), pointer :: css !  current session
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_pushtarget(css,trg,pos,descr,info,&
       & min,max,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_pushtarget.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_pushtarget
#__file: 'libobs/obs_setBufrType.F90' 0100644    **DO NOT DELETE**
subroutine obs_setBufrType(sid, category, subCategory, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  integer :: category
  integer :: subCategory
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setBufrType"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_setBufrType(css,category,subCategory,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_setBufrType.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setBufrType
#__file: 'libobs/obs_setFilter.F90' 0100644    **DO NOT DELETE**
subroutine obs_setfilter(sid, flt, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*(*) :: flt
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setfilter"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,filter250,
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_setfilter(css,flt,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from col_setobscache.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setfilter
#__file: 'libobs/obs_setIndex.F90' 0100644    **DO NOT DELETE**
subroutine obs_setIndex(sid, trg80, exp250, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*80 :: trg80      ! target name
  character*250 :: exp250    ! expression
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setIndex"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_setIndex(css,trg80,exp250,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_setIndex.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setIndex
#__file: 'libobs/obs_setIndexLimits.F90' 0100644    **DO NOT DELETE**
subroutine obs_setIndexLimits(sid, s25,e25, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*25 :: s25,e25      ! start/end index
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setIndexLimits"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_setIndexLimits(css,s25,e25,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_setIndexLimits.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setIndexLimits
#__file: 'libobs/obs_setIndexSpan.F90' 0100644    **DO NOT DELETE**
subroutine obs_setIndexSpan(sid, s25,e25, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*25 :: s25,e25      ! start/end index
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearFileStack"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_setIndexSpan(css,s25,e25,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_setIndexSpan.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setIndexSpan
#__file: 'libobs/obs_setTableC.F90' 0100644    **DO NOT DELETE**
subroutine obs_setTableC(sid, path250, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: path250      ! bufr table c path
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "obs_setTableC"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_settablec(css,path250,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_settablec.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setTableC
#__file: 'libobs/obs_setTablePath.F90' 0100644    **DO NOT DELETE**
subroutine obs_setTablePath(sid, path250, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*250 :: path250      ! bufr table path
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "obs_setTablePath"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_settablepath(css,path250,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_stackclear.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setTablePath
#__file: 'libobs/obs_setTimeSpan.F90' 0100644    **DO NOT DELETE**
subroutine obs_setTimeSpan(sid, s25,e25, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*25 :: s25,e25      ! start/end time
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearFileStack"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_setTimeSpan(css,s25,e25,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_setTimeSpan.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setTimeSpan
#__file: 'libobs/obs_setType.F90' 0100644    **DO NOT DELETE**
subroutine obs_setType(sid, category, subCategory, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  integer :: category
  integer :: subCategory
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setType"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_setType(css,category,subCategory,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_setType.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setType
#__file: 'libobs/setIndexLimits.F90' 0100644    **DO NOT DELETE**
subroutine obs_setIndexLimits(sid, s25,e25, crc250, irc)
  use observations
  implicit none
  integer :: sid             ! session id
  character*25 :: s25,e25    ! start/end index
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearFileStack"
  type(obs_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc,sid
  call observation_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from getSession.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  call observation_setIndexLimits(css,s25,e25,crc250,irc)
  if (irc.ne.0) then
     call observation_errorappend(crc250,myname)
     call observation_errorappend(crc250," Error return from observation_setIndexLimits.")
     call observation_errorappendi(crc250,irc)
     call observation_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine obs_setIndexLimits
#__file: 'libparse/par_clearShapeFile.F90' 0100644    **DO NOT DELETE**
subroutine par_clearshapefile(crc250, irc)
  use parse
  implicit none
  character*250 :: fn250
  character*11 :: cn11
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearshapefile"
  !write(*,*) myname, 'Entering.',irc
  call parse_clearshapefile(crc250,irc)
  if (irc.ne.0) then
     call parse_errorappend(crc250,myname)
     call parse_errorappend(crc250," Error return from parse_clearshapefile.")
     call parse_errorappendi(crc250,irc)
     call parse_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine par_clearshapefile
#__file: 'libparse/parse.F90' 0100644    **DO NOT DELETE**
module parse
  IMPLICIT NONE
  !
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  ! Global constants
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  !
  INTEGER, PARAMETER :: rn = KIND(0.0d0)          ! Precision of real numbers
  INTEGER, PARAMETER :: is = 4                    ! Data type of bytecode
  logical     :: parse_bdeb=.false.
  logical     :: parse_init=.false.
  real(rn)    :: secperday = 86400.0D0
  integer,dimension(8) :: val8    
  real :: days
  real    :: eps  = 0.0D0
  logical :: leps = .false.
  real    :: t0 = 273.15
  real    :: t1 = 273.16
  !
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  ! Fortran 90 function parser v1.1
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  !
  ! This function parser module is intended for applications where a set of mathematical
  ! fortran-style expressions is specified at runtime and is then evaluated for a large 
  ! number of variable values. This is done by compiling the set of function strings 
  ! into byte code, which is interpreted efficiently for the various variable values. 
  !
  ! The source code is available from http://fparser.sourceforge.net
  !
  ! Please send comments, corrections or questions to the author:
  ! Roland Schmehl <roland.schmehl@alumni.uni-karlsruhe.de>
  !
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  ! The function parser concept is based on a C++ class library written by  Juha 
  ! Nieminen <warp@iki.fi> available from http://warp.povusers.org/FunctionParser/
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  PUBLIC                     :: parse_open,    & ! Open parse session
       parse_close,   & ! Close parse session
       parse_parsef,   & ! Parse single function string
       parse_evalf,    & ! Evaluate single function
       parse_evals,    & ! Evaluate single function
       parse_used,     & ! which targets are used?
       parse_EvalErrMsg  ! Error message (Use only when EvalErrType>0)
  INTEGER, PUBLIC            :: EvalErrType ! =0: no error occured, >0: evaluation error
  !  !------- -------- --------- --------- --------- --------- --------- --------- -------
  !  PRIVATE
  !  SAVE
  integer,                                  PARAMETER :: parse_laa=ichar('a')
  integer,                                  PARAMETER :: parse_lzz=ichar('z')
  integer,                                  PARAMETER :: parse_uaa=ichar('A')
  integer,                                  PARAMETER :: parse_uzz=ichar('Z')
  integer,                                  PARAMETER :: parse_und=ichar('_')
  INTEGER(is),                              PARAMETER :: parse_delay       = 0,&
       parse_empty       = 1,&
       parse_constant    = 2,&
       parse_internal    = 3,&
       parse_variable    = 4,&
       parse_expression  = 5
  INTEGER(is),                              PARAMETER :: cImmed     = 1,          &
       cNeg       = 2,          &
       cAdd       = 3,          & 
       cSub       = 4,          & 
       cMul       = 5,          & 
       cDiv       = 6,          & 
       cPow       = 7,          & 
       cAbs       = 8,          &
       cExp       = 9,          &
       cLog10     = 10,         &
       cLog       = 11,         &
       cSqrt      = 12,         &
       cmsgmax    = 13,         &
       cmsgmin    = 14,         &
       cmsgclosest= 15,         &
       cismember  = 16,         &
       cisbelow   = 17,         &
       cisabove   = 18,         &
       cisbetween = 19,         &
       cthinned   = 20,         &
       cand       = 21,         &
       cor        = 22,         &
       cnot       = 23,         &
       c1970yy    = 24,         &
       c1970mm    = 25,         &
       c1970dd    = 26,         &
       c1970hh    = 27,         &
       c1970mi    = 28,         &
       c1970      = 29,         &
       cjulianyy  = 30,         &
       cjulianmm  = 31,         &
       cjuliandd  = 32,         &
       cjulianhh  = 33,         &
       cjulianmi  = 34,         &
       cjulian    = 35,         &
       cMidnight  = 36,         &
       cNow       = 37,         &
       cRound     = 38,         &
       cVarName   = 39,         &
       cValidRange= 40,         &
       cShpPre    = 41,         &
       cShpVic    = 42,         &
       ctd2q      = 43,         &
       crh2td     = 44,         &
       ctd2rh     = 45,         &
       cq2rh      = 46,         &
       ck2c       = 47,         &
       cc2k       = 48,         &
       cSinh      = 49,         &
       cCosh      = 50,         &
       cTanh      = 51,         &
       cSin       = 52,         &
       cCos       = 53,         &
       cTan       = 54,         &
       cAsin      = 55,         &
       cAcos      = 56,         &
       cAtan2     = 57,         &
       cAtan      = 58,         &
       VarBegin   = 59
  CHARACTER (LEN=1), DIMENSION(cAdd:cPow),  PARAMETER :: Ops        = (/ '+',     &
       '-',     &
       '*',     &
       '/',     &
       '^' /)
  CHARACTER (LEN=10), DIMENSION(cAbs:cAtan), PARAMETER :: Funcs      = (/ 'abs       ', &
       'exp       ', &
       'log10     ', &
       'log       ', &
       'sqrt      ', &
       'msgmax    ', &
       'msgmin    ', &
       'msgclosest', &
       'ismember  ', &
       'isbelow   ', &
       'isabove   ', &
       'isbetween ', &
       'thinned   ', &
       'and       ', &
       'or        ', &
       'not       ', &
       'sec1970yy ', &
       'sec1970mm ', &
       'sec1970dd ', &
       'sec1970hh ', &
       'sec1970mi ', &
       'sec1970   ', &
       'julianyy  ', &
       'julliamm  ', &
       'juliandd  ', &
       'julianhh  ', &
       'julianmi  ', &
       'julian    ', &
       'midnight  ', &
       'now       ', &
       'round     ', &
       'name      ', &
       'range     ', &
       'precinct  ', &
       'vicinity  ', &
       'td2q      ', &
       'rh2td     ', &
       'td2rh     ', &
       'q2rh      ', &
       'k2c       ', &
       'c2k       ', &
       'sinh      ', &
       'cosh      ', &
       'tanh      ', &
       'sin       ', &
       'cos       ', &
       'tan       ', &
       'asin      ', &
       'acos      ', &
       'atan2     ', &
       'atan      ' /)
  integer :: nconst =0
  CHARACTER (LEN=25), allocatable :: Const(:)
  real(rn), allocatable  :: constval(:)
  type :: parse_shape
     integer :: index =0                    ! shape index 
     CHARACTER(len=:), allocatable :: name  ! name of shape...
     integer :: lenn =0                     ! length of name
     real :: minxx,maxxx,minyy,maxyy    ! bounding box
     real :: map(3,3), minzz, maxrad
     logical :: offset = .false.            !
     integer :: nll = 0                     ! number of nodes in shape
     real, allocatable :: yy(:),xx(:)       ! shape node in degrees
     integer :: npos = 0                    ! number of pos nodes in shape
     real, allocatable :: pos(:,:)          ! position of nodes
     real :: mimi(3),mima(3),mami(3),mama(3)! bounding box (lon,lat)
     logical, allocatable :: actual(:)      ! is segment actual
  end type parse_shape
  !
  type :: parse_shapefile
     character*250 :: shp250=""             ! default shapefile
     integer ::  lens = 0                   ! length of shapefile name
     character*11 :: cname11                ! db field name
     integer ::  lenc = 0                   ! length of db field name
     integer ::  lenn = 0                   ! allocated length of names
     integer :: nshp =0                     ! number of shapes
     type(parse_shape),allocatable :: shp(:)
     real ::    shapeidlat = -999.0D0
     real ::    shapeidlon = -999.0D0
     integer :: shapeid = 0
     real ::    vicinitylat = -999.0D0
     real ::    vicinitylon = -999.0D0
     integer :: vicinity = 0
  end type parse_shapefile
  type(parse_shapefile) :: sf

  !
  TYPE,PUBLIC ::  parse_session
     INTEGER(is), DIMENSION(:), POINTER   :: ByteCode => null()
     INTEGER                              :: ByteCodeSize
     REAL(rn),    DIMENSION(:), POINTER   :: Immed => null()
     INTEGER                              :: ImmedSize
     REAL(rn),    DIMENSION(:), POINTER   :: Stack => null()
     integer                              :: nPos=0
     REAL(rn),    DIMENSION(:,:), POINTER :: Stacka => null()
     INTEGER                              :: StackSize,StackPtr
     real(rn),    DIMENSION(:), POINTER   :: Wrka => null()
     INTEGER                              :: ArgsSize
     INTEGER,     DIMENSION(:), POINTER   :: ArgsByte => null()
     INTEGER                              :: ArgsPtr
     character(len=:), allocatable        :: cbuff   ! some functions write to the string buffer
     integer                              :: clen=0  ! length of cbuff
     integer :: VarEnd                         ! VarBegin+nVar
     character*100 :: funcStr100=""
     integer :: lenf =0
  END TYPE parse_session
  type parse_pointer
     type(parse_session), pointer  :: ptr => null()
  end type parse_pointer
  !
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  ! Rerun variables
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  ! 
  integer :: rerun_nvar = 0
  character*80,allocatable :: rerun_var80(:)
  integer,allocatable :: rerun_lenv(:)
  real,allocatable :: rerun_value(:)
  character*250 :: rerun_off250 =""
  integer :: rerun_leno=0
  type(parse_session), pointer :: rerun_offset => null()  ! offset parse pointer
  !
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  ! Source code
  !------- -------- --------- --------- --------- --------- --------- --------- -------
  !
CONTAINS
  !	
  subroutine parse_initialise()
    if (parse_init) return
    call date_and_time(VALUES=val8)
    call parse_date2jd( days,&
         & real(val8(1)),real(val8(2)),&
         & real(val8(3)),real(val8(5)),&
         & real(val8(6)),real(val8(7)))
    parse_init=.true.
    return
  end subroutine parse_initialise

  subroutine parse_date_and_time(values)
    integer,dimension(8) :: values
    character*250 :: crc250
    integer :: irc
    real :: offset
    call parse_init()
    offset=parse_getTimeOffset(crc250,irc)
    ! retrieve date from julian days...
    call parse_jd2date( days+offset,&
         & real(values(1)),real(values(2)),&
         & real(values(3)),real(values(5)),&
         & real(values(6)),real(values(7)))
    return
  end subroutine parse_date_and_time

  SUBROUTINE parse_open (css,crc250,irc)
    IMPLICIT NONE
    type(parse_session), pointer :: css
    character*250 :: crc250
    integer :: irc
    integer :: ii,nshp
    character*22 :: myname ="parse_open"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    if(parse_bdeb)write(*,*)myname,"Opening"
    if (.not.allocated(const).or..not.allocated(constval)) then
       if (allocated(const))deallocate(const)
       if (allocated(constval))deallocate(constval)
       ! create a constant variable with name shp%name... and value shp%index
       nshp=0
       do ii=1,sf%nshp
          if (sf%shp(ii)%index.eq.ii) then ! only count unique indexes
             nshp=nshp+1
          end if
       end do
       nconst=3+nshp+rerun_nvar
       allocate(const(0:nconst),constval(0:nconst))
       const(0)='unknown'
       constval(0)=0
       nshp=0
       do ii=1,sf%nshp
          if (parse_bdeb) write(*,*) ">>",ii,sf%shp(ii)%index,trim(sf%shp(ii)%name)
          if (sf%shp(ii)%index.eq.ii) then ! only count unique indexes
             nshp=nshp+1
             const(nshp)=camelCase(sf%shp(ii)%name,25)
             constval(nshp)=sf%shp(ii)%index
             if (parse_bdeb) write(*,*) "  ",nshp,nint(constval(nshp)),trim(const(nshp))
          end if
       end do
       const(1+nshp)='pi'
       const(2+nshp)='e'
       const(3+nshp)='na'
       do ii=1,rerun_nvar
          const(3+nshp+ii)=rerun_var80(ii)
       end do
       constval(1+nshp)=3.14159265359
       constval(2+nshp)=2.71828182846
       constval(3+nshp)=1.7D38
       do ii=1,rerun_nvar
          constval(3+nshp+ii)=rerun_value(ii)
       end do
       if(parse_bdeb)write(*,*)myname,"Added constants:",nconst
    end if
    ! css must be nullified if not declared...
    if (.not.associated(css)) ALLOCATE (css)
    if (associated(css%ByteCode)) deallocate(css%ByteCode)
    if (associated(css%Immed)) deallocate(css%Immed)
    if (associated(css%Stack)) deallocate(css%Stack)
    if (associated(css%Stacka)) deallocate(css%Stacka)
    if (associated(css%Wrka)) deallocate(css%Wrka)
    if (associated(css%ArgsByte)) deallocate(css%ArgsByte)
    if (allocated(css%cbuff)) deallocate(css%cbuff)
    NULLIFY (css%ByteCode,css%Immed,css%Stack,css%Stacka,css%Wrka,css%ArgsByte)
    !css%parse_laa=ichar('a')
    !css%parse_lzz=ichar('z')
    !css%parse_uaa=ichar('A')
    !css%parse_uzz=ichar('Z')
    !css%parse_und=ichar('_')
    !if(parse_bdeb)write(*,*)myname,"Done"
    css%npos=0
    call parse_initialise()
    return
  END SUBROUTINE parse_open
  !
  SUBROUTINE parse_close (css,crc250,irc)
    IMPLICIT NONE
    type(parse_session), pointer :: css
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="parse_close"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    if (associated(css)) then
       IF (ASSOCIATED(css%ByteCode)) DEALLOCATE ( css%ByteCode,stat=irc)
       IF (ASSOCIATED(css%Immed))    DEALLOCATE ( css%Immed,   stat=irc)
       IF (ASSOCIATED(css%Stack))    DEALLOCATE ( css%Stack,   stat=irc)
       IF (ASSOCIATED(css%Stacka))   DEALLOCATE ( css%Stacka,  stat=irc)
       IF (ASSOCIATED(css%Wrka))     DEALLOCATE ( css%Wrka,    stat=irc)
       IF (ASSOCIATED(css%ArgsByte)) DEALLOCATE ( css%ArgsByte,stat=irc)
       if (allocated(css%cbuff)) deallocate(css%cbuff)
       deallocate(css,stat=irc)
       nullify(css)
    end if
    return
  END SUBROUTINE parse_close
  !
  subroutine parse_setshapefile(path250,cname11,crc250,irc)
    USE,INTRINSIC :: ISO_C_BINDING
    USE shape
    implicit none
    character*250 :: path250
    character*11 :: cname11
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    INTEGER                         :: nvar = 0
    TYPE(shpfileobject) :: shphandle
    TYPE(shpobject) :: shpobj
    INTEGER :: ii, jj, kk, iname, lendec
    INTEGER :: nshpr, tshpr, nfield, nrec, nd, ftype
    REAL(kind=c_double) :: minbound(4), maxbound(4)
    real :: rr
    character(len=11) :: cname
    character*22 :: myname="parse_setshapefile"
    real :: north(3) =(/0.0D0,0.0D0,1.0D0/)
    logical :: first
    real :: spos(3),epos(3)
    !
    if(parse_bdeb)write(*,*)myname,' Entering.',irc
    sf%shp250=path250
    call chop0(sf%shp250,250)
    sf%lens=length(sf%shp250,250,10)
    sf%cname11 = cname11 !  "SOVEREIGNT"
    sf%lenc=length(sf%cname11,11,10)
    if (sf%lenc.eq.0) then
       sf%cname11 =  "SOVEREIGNT"
       sf%lenc=length(sf%cname11,11,10)
    end if
    if(parse_bdeb)write(*,*)myname," Path: '"//sf%shp250(1:sf%lens)//"'"
    ! remove old shapefile data
    call parse_clearshapefile(crc250,irc)
    if (irc.ne.0) then
       call parse_errorappend(crc250,myname//" Error return from clearshapeFile")
       call parse_errorappendi(crc250,irc)
       call parse_errorappend(crc250,"\n")
       return
    end if
    ! read new shape file...
    shphandle = shpopen(sf%shp250(1:sf%lens), 'rb')
    ! error check
    IF (shpfileisnull(shphandle) .OR. dbffileisnull(shphandle)) THEN
       call parse_errorappend(crc250,myname//" Error opening '"//sf%shp250(1:sf%lens)//"' for reading\n")
       irc=458
       return
    ENDIF
    ! get general information about the shapefile object
    CALL shpgetinfo(shphandle, nshpr, tshpr, minbound, maxbound, nfield, nrec)
    if (parse_bdeb) then
       write(*,*)myname,'Shpgetinfo, shapes:',nshpr
       write(*,*)myname,'shpgetinfo, type of shapes:',tshpr,'(Polygon=',shpt_polygon,')'
       write(*,*)myname,'shpgetinfo, number of db-fields',nfield
       write(*,*)myname,'shpgetinfo, number of db-records',nrec
    end if
    ! get field "name" index
    iname=dbfgetfieldindex (shphandle,sf%cname11)
    if (iname.eq.-1) then
       call parse_errorappend(crc250,myname//" Error in dbfgetfieldindex ")
       call parse_errorappendi(crc250,ii)
       call parse_errorappend(crc250,"\n")
       irc=458
    end if
    cname="" ! use iname to identify field...
    ftype=dbfgetfieldinfo (shphandle, iname, cname, sf%lenn, lendec)
    sf%nshp=nshpr
    allocate(sf%shp(sf%nshp),stat=irc)
    if (irc.ne.0) then
       call parse_errorappend(crc250,myname//" Unable to allocate shape:")
       call parse_errorappendi(crc250,sf%nshp)
       call parse_errorappendi(crc250,irc)
       call parse_errorappend(crc250,"\n")
       return
    end if
    ! read the nshp shapes
    DO ii = 1, nshpr
       jj=ii-1
       sf%shp(ii)%index=ii
       allocate(character(len=sf%lenn) :: sf%shp(ii)%name)
       if (irc.ne.0) then
          call parse_errorappend(crc250,myname//" Unable to allocate shape-name:")
          call parse_errorappendi(crc250,sf%lenn)
          call parse_errorappendi(crc250,irc)
          call parse_errorappend(crc250,"\n")
          return
       end if
       ! read databse attribute
       CALL dbfreadattribute(shphandle, jj, iname, sf%shp(ii)%name)
       sf%shp(ii)%lenn=len_trim(sf%shp(ii)%name)
       nameloop: do kk=1,ii
          if (sf%shp(ii)%name.eq.sf%shp(kk)%name) then
             sf%shp(ii)%index=kk
             exit nameloop
          end if
       end do nameloop
       !if (trim(sf%shp(ii)%name).eq."Norway")then
       !   do kk=1,shpobj%nvertices
       !      write(*,*) kk, shpobj%padfx(kk),shpobj%padfy(kk)
       !   end do
       !end if
       ! read the i-th shape from the shapefile object and obtain a shape object
       shpobj = shpreadobject(shphandle, jj)
       ! error check
       IF (shpisnull(shpobj)) THEN
          irc=348
          call parse_errorappend(crc250,myname//" Error in shpreadobject.")
          call parse_errorappendi(crc250,jj)
          call parse_errorappendi(crc250,irc)
          call parse_errorappend(crc250,"\n")
          return
       ENDIF
       ! rewind shape-rings..
       call shpretraceobject(shphandle,shpobj,leps,eps)
       !
       sf%shp(ii)%nll=shpobj%nseg
       do jj=1,shpobj%nvertices
          if (shpobj%valid(jj)) then
             sf%shp(ii)%nll=sf%shp(ii)%nll+1
          end if
       end do
       if(parse_bdeb)write(*,*)'Number of segments:',shpobj%nvertices,&
            & '+',shpobj%nseg,'->',sf%shp(ii)%nll
       if (sf%shp(ii)%nll.lt.3) then ! sanity check
          irc=945
          call parse_errorappend(crc250,myname//" Invalid shape-ll:")
          call parse_errorappendi(crc250,sf%shp(ii)%nll)
          call parse_errorappend(crc250,":")
          call parse_errorappendi(crc250,irc)
          call parse_errorappend(crc250,"\n")
          return
       end if
       sf%shp(ii)%npos=sf%shp(ii)%nll
       allocate(sf%shp(ii)%xx(sf%shp(ii)%nll),sf%shp(ii)%yy(sf%shp(ii)%nll),&
            & sf%shp(ii)%pos(3,sf%shp(ii)%npos),sf%shp(ii)%actual(sf%shp(ii)%npos),stat=irc)
       if (irc.ne.0) then
          call parse_errorappend(crc250,myname//" Unable to allocate shape-ll:")
          call parse_errorappendi(crc250,sf%shp(ii)%nll)
          call parse_errorappendi(crc250,irc)
          call parse_errorappend(crc250,"\n")
          return
       end if
       kk=0
       do jj=1,shpobj%nvertices
          if (shpobj%valid(jj)) then
             kk=kk+1
             call shape_lonlat2pos(shpobj%padfx(jj),shpobj%padfy(jj),&
                  & sf%shp(ii)%pos(1,kk))
             sf%shp(ii)%actual(kk)=shpobj%actual(jj)
          end if
       end do
       do while (shpLoopSegment(shpobj,spos,epos))
          kk=kk+1
          call shape_lonlat2pos(epos(1),epos(2),&
               & sf%shp(ii)%pos(1,kk))
          sf%shp(ii)%actual(kk)=.false.
       end do
       ! get map center
       sf%shp(ii)%map(1,3)=0.0D0
       sf%shp(ii)%map(2,3)=0.0D0
       sf%shp(ii)%map(3,3)=0.0D0
       do jj=1,sf%shp(ii)%npos
          sf%shp(ii)%map(1,3)=sf%shp(ii)%map(1,3)+sf%shp(ii)%pos(1,jj)
          sf%shp(ii)%map(2,3)=sf%shp(ii)%map(2,3)+sf%shp(ii)%pos(2,jj)
          sf%shp(ii)%map(3,3)=sf%shp(ii)%map(3,3)+sf%shp(ii)%pos(3,jj)
       end do
       rr=dsqrt(shape_dot(sf%shp(ii)%map(1,3),sf%shp(ii)%map(1,3)))
       if (rr.lt.1.0D-10) then ! shape covers half the world...
          irc=843
          call parse_errorappend(crc250,myname//" Great circle shape: "//trim(sf%shp(ii)%name))
          call parse_errorappendi(crc250,ii)
          call parse_errorappend(crc250,"\n")
          return
       end if
       sf%shp(ii)%map(1,3)=sf%shp(ii)%map(1,3)/rr
       sf%shp(ii)%map(2,3)=sf%shp(ii)%map(2,3)/rr
       sf%shp(ii)%map(3,3)=sf%shp(ii)%map(3,3)/rr
       call shape_cross(north,sf%shp(ii)%map(1,3),sf%shp(ii)%map(1,1))
       rr=dsqrt(shape_dot(sf%shp(ii)%map(1,1),sf%shp(ii)%map(1,1)))
       ! get vector along X-axis (west): map(:,1)
       if (rr.lt.1.0D-10) then ! shape center is towards north pole
          sf%shp(ii)%map(1,1)=1.0D0
          sf%shp(ii)%map(2,1)=0.0D0
          sf%shp(ii)%map(3,1)=0.0D0
       else
          sf%shp(ii)%map(1,1)=sf%shp(ii)%map(1,1)/rr
          sf%shp(ii)%map(2,1)=sf%shp(ii)%map(2,1)/rr
          sf%shp(ii)%map(3,1)=sf%shp(ii)%map(3,1)/rr
       end if
       ! get vector along Y-axis (north): map(:,2)
       call shape_cross(sf%shp(ii)%map(1,3),sf%shp(ii)%map(1,1),sf%shp(ii)%map(1,2))
       rr=dsqrt(shape_dot(sf%shp(ii)%map(1,2),sf%shp(ii)%map(1,2)))
       if (rr.lt.1.0D-10) then ! error
          irc=845
          call parse_errorappend(crc250,myname//" Failed sanity check: "//trim(sf%shp(ii)%name))
          call parse_errorappendi(crc250,ii)
          call parse_errorappend(crc250,"\n")
          return
       else ! not necessary... in theory
          sf%shp(ii)%map(1,2)=sf%shp(ii)%map(1,2)/rr
          sf%shp(ii)%map(2,2)=sf%shp(ii)%map(2,2)/rr
          sf%shp(ii)%map(3,2)=sf%shp(ii)%map(3,2)/rr
       end if
       first=.true.
       do jj=1,sf%shp(ii)%npos
          sf%shp(ii)%xx(jj)=shape_dot(sf%shp(ii)%map(1,1),sf%shp(ii)%pos(1,jj))
          sf%shp(ii)%yy(jj)=shape_dot(sf%shp(ii)%map(1,2),sf%shp(ii)%pos(1,jj))
          if (first) then
             first=.false.
             sf%shp(ii)%minzz=shape_dot(sf%shp(ii)%map(1,3),sf%shp(ii)%pos(1,jj))
             sf%shp(ii)%minxx=sf%shp(ii)%xx(jj)
             sf%shp(ii)%minyy=sf%shp(ii)%yy(jj)
             sf%shp(ii)%maxxx=sf%shp(ii)%xx(jj)
             sf%shp(ii)%maxyy=sf%shp(ii)%yy(jj)
          else
             sf%shp(ii)%minzz=min(sf%shp(ii)%minzz,&
                  & shape_dot(sf%shp(ii)%map(1,3),sf%shp(ii)%pos(1,jj)))
             sf%shp(ii)%minxx=min(sf%shp(ii)%minxx,sf%shp(ii)%xx(jj))
             sf%shp(ii)%minyy=min(sf%shp(ii)%minyy,sf%shp(ii)%yy(jj))
             sf%shp(ii)%maxxx=max(sf%shp(ii)%maxxx,sf%shp(ii)%xx(jj))
             sf%shp(ii)%maxyy=max(sf%shp(ii)%maxyy,sf%shp(ii)%yy(jj))
          end if
       end do
       sf%shp(ii)%maxrad=acos(sf%shp(ii)%minzz)
       if (parse_bdeb)write(*,'(4(X,F10.3),X,A)') &
            & shape_rtodeg(sf%shp(ii)%maxrad),(sf%shp(ii)%map(1,jj),jj=1,3), &
            & trim(sf%shp(ii)%name)
       if (sf%shp(ii)%minzz.lt.0.0D0) then ! shape covers more than half the world...
          if (parse_bdeb) then
             do jj=1,sf%shp(ii)%npos
                write(*,*)myname,'Pos:',jj,sf%shp(ii)%pos(1,jj),sf%shp(ii)%pos(2,jj),sf%shp(ii)%pos(3,jj)
             end do
             write(*,*)myname,'Center:',sf%shp(ii)%map(1,3),sf%shp(ii)%map(2,3),sf%shp(ii)%map(3,3)
             write(*,*)myname,'Minzz:',sf%shp(ii)%minzz,trim(sf%shp(ii)%name)
          end if
          irc=844
          call parse_errorappend(crc250,myname//" Too large shape: "//trim(sf%shp(ii)%name))
          call parse_errorappendi(crc250,ii)
          call parse_errorappend(crc250,"\n")
          return
       end if
       if (first) then ! shape has no nodes
          irc=899
          call parse_errorappend(crc250,myname//" Too small shape: "//trim(sf%shp(ii)%name))
          call parse_errorappendi(crc250,ii)
          call parse_errorappend(crc250,"\n")
          return
       end if
       !write(*,'(X,A,X,I0,6(X,F6.1),2X,I5,X,A,X,F6.1)') &
       !     & 'dbfreadattribute ', ii, &
       !     & shpobj%padfx(1),sf%shp(ii)%minxx,sf%shp(ii)%minxx, &
       !     & shpobj%padfy(1),sf%shp(ii)%minyy,sf%shp(ii)%maxyy, &
       !     & sf%shp(ii)%nll,trim(sf%shp(ii)%name)
       !
       ! now access all the components of the shape object
       ! number of vertices
       ! write(*,*)myname,'shpreadobject, number of vertices',ii,shpobj%nvertices
       ! write(*,*)myname,'shpreadobject, x:',ii
       ! write(*,*)myname,shpobj%padfx(:)
       ! write(*,*)myname,'shpreadobject, y:',ii
       ! write(*,*)myname,shpobj%padfy(:)
       ! write(*,*)myname,'shpreadobject, z:',ii
       ! write(*,*)myname,shpobj%padfz(:)
       !
       ! destroy the shape object to avoid memory leaks
       ! notice that for accessing dbf attributes the shape object is not required
       CALL shpdestroyobject(shpobj)
    ENDDO
    
    ! close the shapefile object
    CALL shpclose(shphandle)
    !
  end subroutine parse_setshapefile
  !
  subroutine parse_simplifyShapes(tol20,crc250,irc)
    use shape
    implicit none
    character*20 :: tol20
    character*250 :: crc250
    integer :: irc
    integer :: ii,lent
    integer, external :: length
    character*22 :: myname="parse_simplifyShapes"
    call chop0(tol20,20)
    lent=length(tol20,20,10)
    read (tol20(1:lent),*,iostat=irc) eps
    if (irc.ne.0) then
       call parse_errorappend(crc250,myname//" Invalid tolerance:")
       call parse_errorappendr(crc250,eps)
       call parse_errorappend(crc250,"\n")
       return
    end if
    leps=.true.
    if (parse_bdeb) write(*,*)myname,'Tolerance:',eps
    return
  end subroutine parse_simplifyShapes
  !
  subroutine parse_clearshapefile(crc250,irc)
    implicit none
    character*250 :: crc250
    integer :: irc
    integer :: ii
    character*22 :: myname="parse_clearshapefile"
    if (parse_bdeb)write(*,*)myname,'Entering.',sf%nshp
    if (sf%nshp.gt.0) then
       do ii=1,sf%nshp
          if (allocated(sf%shp(ii)%xx)) deallocate(sf%shp(ii)%xx)
          if (allocated(sf%shp(ii)%yy)) deallocate(sf%shp(ii)%yy)
          if (allocated(sf%shp(ii)%pos)) deallocate(sf%shp(ii)%pos)
          if (allocated(sf%shp(ii)%name)) deallocate(sf%shp(ii)%name)
       end do
       deallocate(sf%shp)
    end if
    sf%nshp=0
    return
  end subroutine parse_clearshapefile
  !
  integer function parse_type(funcstr,var,crc250,irc)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Identify type of function (empty, constant, variable or expression)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*),               INTENT(in) :: FuncStr   ! Function string
    CHARACTER (LEN=*), allocatable, INTENT(in) :: Var(:)     ! internal variables
    character*250 :: crc250
    integer :: irc
    CHARACTER (LEN=LEN(FuncStr))                :: Func      ! Function string, local use
    integer :: irc2
    integer :: ii,lfunc
    integer :: c
    integer :: ival
    real(rn) :: rval
    character*25 :: myname = "parse_type"
    Func = trim(FuncStr)                                           ! Local copy of function string
    lFunc = LEN_TRIM(Func)
    if (lfunc.eq.0) then
       parse_type=parse_empty
       return
    end if
    read (func(1:lfunc),*,iostat=irc2) ival
    if (irc2.ne.0) then
       read (func(1:lfunc),*,iostat=irc2) rval
    end if
    if (irc2.eq.0) then ! constant
       parse_type=parse_constant
       return
    end if
    DO ii=lbound(var,1),ubound(var,1)
       IF (trim(func) .eq. trim(Var(ii))) THEN                     
          parse_type=parse_internal
          return
       end if
    end Do
    DO ii=1,lFunc
       c=ichar(func(ii:ii))
       if (.not.((c.ge.parse_laa.and. c.le.parse_lzz).or.&
            & (c.ge.parse_uaa.and. c.le.parse_uzz).or.&
            & (c.eq.parse_und)))then
          parse_type=parse_expression
          return
       end if
    end do
    parse_type=parse_variable
    return
  end function parse_type
  !
  ! real(rn) function parse_val(FuncStr,crc250,irc)
  !   character (Len=*), INTENT(in)  :: FuncStr
  !   character*250 :: crc250
  !   integer :: irc
  !   CHARACTER (LEN=*), allocatable, INTENT(in) :: Var(:)       ! dummy
  !   REAL(rn), allocatable, INTENT(in)          :: Val(:)  ! dummy
  !   type(parse_session), pointer :: css => null()
  !   call parse_open(css,crc250,irc)
  !   if (irc.ne.0) return
  !   call parse_parsef (css, FuncStr, Var,crc250,irc)
  !   if (irc.ne.0) return
  !   parse_val=parse_evalf(css,val)
  !   call parse_close(css,crc250,irc)
  !   if (irc.ne.0) return
  !   return
  ! end function parse_val

  SUBROUTINE parse_parsef (css, FuncStr, Var,crc250,irc)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Parse function string FuncStr and compile it into bytecode
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    type(parse_session), pointer :: css
    CHARACTER (LEN=*),               INTENT(in) :: FuncStr   ! Function string
    CHARACTER (LEN=*), allocatable, INTENT(in) :: Var(:)       ! Array with variable names
    character*250 :: crc250
    integer :: irc
    CHARACTER (LEN=LEN(FuncStr))                :: Func      ! Function string, local use
    integer, external :: length
    character*25 :: myname = "parse_parsef"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    css%varEnd=varBegin+ubound(var,1)-lbound(var,1)+1
    Func = FuncStr                                           ! Local copy of function string
    CALL Replace ('**','^ ',Func)                            ! Exponent into 1-Char. format
    CALL RemoveSpaces (Func)                                 ! Condense function string
    if(parse_bdeb)write(*,*) myname,"Parsing '"//func(1:len_trim(func))//"'"
    CALL parse_CheckSyntax (Func,FuncStr,Var,crc250,irc)
    if (irc.ne.0) return
    if(parse_bdeb) write(*,*)myname,"Compiling '"//funcstr(1:LEN_TRIM(FuncStr))//"'"
    CALL Parse_compile (css,Func,Var,crc250,irc)                                ! Compile into bytecode
    css%funcStr100=FuncStr
    call chop0(css%funcStr100,100)
    css%lenf=length(css%funcStr100,100,10)
    if(parse_bdeb)write(*,'(X,A,X,A,1000(X,I0))') myname,"Done '"//&
         & funcstr(1:LEN_TRIM(FuncStr))//"'",css%bytecode
    return
  END SUBROUTINE parse_parsef
  !
  logical function parse_string(css, cbuff) result (ret)
    IMPLICIT NONE
    type(parse_session), pointer,INTENT(IN) :: css
    character(len=:), allocatable,INTENT(OUT):: cbuff   ! some functions write to the string buffer
    ret=(css%clen.ne.0)
    if (allocated(cbuff)) deallocate(cbuff)
    if (ret) then
       allocate(character(len=len_trim(css%cbuff)) :: cbuff)
       cbuff=trim(css%cbuff)
    end if
    if (parse_bdeb .and. ret) then
       write(*,*)'Parse_string Found: "'//cbuff//'"',css%clen
    end if
    return
  end function parse_string
  !
  FUNCTION parse_evalf (css, Val, crc250,irc) RESULT (res)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Evaluate bytecode of ith function for the values passed in array Val(:)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    type(parse_session), pointer,INTENT(IN) :: css
    REAL(rn), allocatable, INTENT(in)       :: Val(:)  ! Variable values
    character*250 :: crc250
    integer :: irc
    REAL(rn)                                :: res     ! Result
    !
    INTEGER                                 :: IP,   & ! Instruction pointer
         DP,   & ! Data pointer
         SP,   & ! Stack pointer
         AP,   & ! arguments pointer
         AI      ! arguments index
    REAL(rn),                PARAMETER :: zero = 0._rn
    integer :: ii, imax,nargs
    character*22 :: myname ="parse_evalf"
    character*250 :: str250
    real(rn)  :: eps
    integer :: lens
    integer, external :: length
    logical :: above,below,found
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    if (.not.associated(css)) then
       if(parse_bdeb)write(*,*)myname,"Input ",&
            & imax,allocated(val)
       irc=911
       call parse_errorappend(crc250,myname//" Invalid session.")
       return
    end if
    imax=size(val)
    css%clen=0
    if(parse_bdeb)write(*,*)myname,"Entering '"//css%funcStr100(1:css%lenf)//"'",imax,allocated(val)
    DP = 1
    SP = 0
    AP = 0 ! argument position
    AI = 0 ! argument function index
    DO IP=1,css%ByteCodeSize
       NARGS=css%ArgsByte(AI+1)
       if(parse_bdeb)then
          write(*,'(X,A,X,A,X,I3,X,I3,3X,A,3X,I0,X,I0)')myname,"Looping",&
               & IP,css%ByteCode(IP),parse_code20(css%bytecode(ip),nargs)
       end if
       SELECT CASE (css%ByteCode(IP))
       CASE (cImmed)
          SP=SP+1
          css%Stack(SP)=css%Immed(DP)
          DP=DP+1
       CASE   (cNeg)
          css%Stack(SP)=-css%Stack(SP)
       CASE   (cAdd)
          css%Stack(SP-1)=css%Stack(SP-1)+css%Stack(SP)
          SP=SP-1
       CASE   (cSub)
          css%Stack(SP-1)=css%Stack(SP-1)-css%Stack(SP)
          SP=SP-1
       CASE   (cMul)
          css%Stack(SP-1)=css%Stack(SP-1)*css%Stack(SP)
          SP=SP-1
       CASE   (cDiv)
          IF (css%Stack(SP)==0._rn) THEN
             if (parse_bdeb) write(*,*)"*** Division by zero."
             irc=313
             call parse_errorappend(crc250,myname//" Division by zero.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=1
             res=zero
             RETURN
          ENDIF
          css%Stack(SP-1)=css%Stack(SP-1)/css%Stack(SP)
          SP=SP-1
       CASE   (cPow)
          css%Stack(SP-1)=css%Stack(SP-1)**css%Stack(SP)
          SP=SP-1
       CASE   (cAbs)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=ABS(css%Stack(SP))
       CASE   (cExp)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=EXP(css%Stack(SP))
       CASE (cLog10)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (css%Stack(SP)<=0._rn) THEN
             if (parse_bdeb) write(*,*)"*** Negative argument to LOG10.",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Negative argument to LOG10.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=3
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=LOG10(css%Stack(SP))
       CASE   (cLog)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (css%Stack(SP)<=0._rn) THEN
             if (parse_bdeb) write(*,*)"*** Negative argument to LOG.",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Negative argument to LOG.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=3
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=LOG(css%Stack(SP))
       CASE  (cSqrt)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (css%Stack(SP)<0._rn) THEN
             if (parse_bdeb) write(*,*)"*** Negative argument to SQRT.",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Negative argument to SQRT.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=2
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=SQRT(css%Stack(SP))
       CASE  (cMsgMax)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=1.0D0
       CASE  (cMsgMin)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=1.0D0
       CASE  (cMsgClosest)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=1.0D0
       CASE  (cisMember)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=.false.
          ISMEMBER: DO II=1,NARGS-1
             if (css%stack(SP).eq.css%Stack(SP+II)) then
                found=.true.
                exit ISMEMBER
             end if
          end do ISMEMBER
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cisBelow)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=.true.
          ISBELOW: DO II=1,NARGS-1
             if (css%stack(SP).ge.css%Stack(SP+II)) then
                found=.false.
                exit ISBELOW
             end if
          end do ISBELOW
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cisAbove)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=.true.
          ISABOVE: DO II=1,NARGS-1
             if (css%stack(SP).le.css%Stack(SP+II)) then
                found=.false.
                exit ISABOVE
             end if
          end do ISABOVE
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cisBetween)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          above=.false.
          below=.false.
          ISBETWEEN: DO II=1,NARGS-1
             if (css%stack(SP).le.css%Stack(SP+II)) then
                BELOW=.TRUE.
             end if
             if (css%stack(SP).ge.css%Stack(SP+II)) then
                ABOVE=.TRUE.
             end if
             if (above.and.below) exit ISBETWEEN
          end do ISBETWEEN
          if (above.and.below) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cThinned)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.ge.1) THEN ! 
             if (rand()*100 .gt. css%Stack(SP)) then
                css%Stack(SP)=1.0D0
             else
                css%Stack(SP)=0.0D0
             end if
          end if
       CASE  (cand)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=(abs(css%stack(SP)).gt.0.5D0)
          if (found) then
             AND: DO II=1,NARGS-1
                if (abs(css%Stack(SP+II)).lt.0.5D0) then
                   found=.false.
                   exit AND
                end if
             end do AND
          end if
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cor)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=(abs(css%stack(SP)).gt.0.5D0)
          if (.not.found) then
             OR: DO II=1,NARGS-1
                if (abs(css%Stack(SP+II)).gt.0.5D0) then
                   found=.true.
                   exit OR
                end if
             end do OR
          end if
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cnot)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          ! .not.a .and. .not.b ....
          found=(abs(css%stack(SP)).lt.0.5D0)
          if (found) then
             NOT: DO II=1,NARGS-1
                if (abs(css%Stack(SP+II)).gt.0.5D0) then
                   found=.false.
                   exit NOT
                end if
             end do NOT
          end if
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (c1970yy)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_yy(css%Stack(SP))
       CASE  (c1970mm)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_mm(css%Stack(SP))
       CASE  (c1970dd)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_dd(css%Stack(SP))
       CASE  (c1970hh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_hh(css%Stack(SP))
       CASE  (c1970mi)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_mi(css%Stack(SP))
       CASE  (c1970)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.EQ.1) THEN ! dtg()
             css%Stack(SP)=css%Stack(SP)+parse_f1970(real(val8(1)),real(val8(2)),&
                  &real(val8(3)),real(val8(5)),real(val8(6)),real(val8(7)))
          ELSE IF (NARGS.EQ.6) THEN ! dtg(year,month,day,hour,min,sec)
             css%Stack(SP)=parse_f1970(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  css%Stack(SP+4), &
                  css%Stack(SP+5))
          ELSE IF (NARGS.EQ.5) THEN ! dtg(year,month,day,hour,min)
             css%Stack(SP)=parse_f1970(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  css%Stack(SP+4), &
                  0.0D0)
          ELSE IF (NARGS.EQ.4) THEN ! dtg(year,month,day,hour)
             css%Stack(SP)=parse_f1970(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  0.0D0, &
                  0.0D0)
          ELSE 
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to s1970:",nargs
             irc=308
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to s1970.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          END IF
       CASE  (cjulianyy)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_yy(css%Stack(SP))
       CASE  (cjulianmm)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_mm(css%Stack(SP))
       CASE  (cjuliandd)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_dd(css%Stack(SP))
       CASE  (cjulianhh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_hh(css%Stack(SP))
       CASE  (cjulianmi)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_mi(css%Stack(SP))
       CASE  (cjulian)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.EQ.1) THEN ! dtg()
             css%Stack(SP)=css%Stack(SP)+parse_fjulian(real(val8(1)),real(val8(2)),&
                  &real(val8(3)),real(val8(5)),real(val8(6)),real(val8(7)))
          ELSE IF (NARGS.EQ.6) THEN ! dtg(year,month,day,hour,min,sec)
             css%Stack(SP)=parse_fjulian(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  css%Stack(SP+4), &
                  css%Stack(SP+5))
          ELSE IF (NARGS.EQ.5) THEN ! dtg(year,month,day,hour,min)
             css%Stack(SP)=parse_fjulian(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  css%Stack(SP+4), &
                  0.0D0)
          ELSE IF (NARGS.EQ.4) THEN ! dtg(year,month,day,hour)
             css%Stack(SP)=parse_fjulian(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  0.0D0, &
                  0.0D0)
          ELSE 
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to d2000:",nargs
             irc=309
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to d2000.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          END IF
       CASE  (cmidnight)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=css%Stack(SP)*secperday+parse_f1970(real(val8(1)),real(val8(2)),&
               &real(val8(3)),0.0D0,0.0D0,0.0D0)
          do ii=1,nargs-1
             css%Stack(SP)=css%Stack(SP)+css%Stack(SP+ii)*secperday             
          end do
       CASE  (cnow)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=css%Stack(SP)*secperday+parse_f1970(real(val8(1)),real(val8(2)),&
               &real(val8(3)),real(val8(5)),real(val8(6)),real(val8(7)))
          do ii=1,nargs-1
             css%Stack(SP)=css%Stack(SP)+css%Stack(SP+ii)*secperday
          end do
       CASE  (cround)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.gt.1) then
             eps=max(1.0D-5,abs(css%Stack(SP+1)))
             css%Stack(SP)=dnint(css%Stack(SP)/eps)*eps
          else
             css%Stack(SP)=dnint(css%Stack(SP))
          end if
       CASE  (cVarName)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.1) then
             if (parse_bdeb) write(*,*)"*** Found shape:",nint(css%stack(sp))
             if (allocated(css%cbuff)) deallocate(css%cbuff)
             css%clen=25
             allocate(character(len=css%clen) :: css%cbuff)
             css%cbuff=trim(getname25(css%Stack(SP)))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to shapes:",nargs
             irc=312
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to shapes.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cValidRange)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.3) then
             if (parse_bdeb) write(*,*)"*** Found range-check"
             if (css%Stack(SP).lt.css%Stack(SP+1).or.&
                  & css%Stack(SP).gt.css%Stack(SP+2)) then
                if (allocated(css%cbuff)) deallocate(css%cbuff)
                css%clen=2
                allocate(character(len=css%clen) :: css%cbuff)
                css%cbuff="NA"
             end if
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to validRange:",nargs
             irc=312
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to validRange.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cShpPre)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=shapeid(css%Stack(SP),css%Stack(SP+1))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to shape:",nargs
             irc=310
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to shape.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cShpVic)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.3) then
             css%Stack(SP)=vicinity(css%Stack(SP),css%Stack(SP+1),css%Stack(SP+2))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to shape:",nargs
             irc=310
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to shape.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (ctd2q) ! td,p
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=td2q(css%Stack(SP),css%Stack(SP+1))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to td2q:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to td2q.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (crh2td) ! rh, t, [ice=1,0]
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=rh2td(css%Stack(SP),css%Stack(SP+1))
          else if (nargs.eq.3) then
             css%Stack(SP)=rh2td(css%Stack(SP),css%Stack(SP+1),css%Stack(SP+2))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to rh2td:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to rh2td.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (ctd2rh) ! td, t, [ice=1,0]
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=td2rh(css%Stack(SP),css%Stack(SP+1))
          else if (nargs.eq.3) then
             css%Stack(SP)=td2rh(css%Stack(SP),css%Stack(SP+1),css%Stack(SP+2))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to td2rh:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to td2rh.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cq2rh) ! q, t, [p|1013.25]
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=q2rh(css%Stack(SP),css%Stack(SP+1))
          else if (nargs.eq.3) then
             css%Stack(SP)=q2rh(css%Stack(SP),css%Stack(SP+1),css%Stack(SP+2))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to q2rh:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to q2rh.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (ck2c)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=css%Stack(SP)-t0
       CASE  (cc2k)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=css%Stack(SP)+t0
       CASE  (cSinh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=SINH(css%Stack(SP))
       CASE  (cCosh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=COSH(css%Stack(SP))
       CASE  (cTanh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=TANH(css%Stack(SP))
       CASE   (cSin)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=SIN(css%Stack(SP))
       CASE   (cCos)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=COS(css%Stack(SP))
       CASE   (cTan)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=TAN(css%Stack(SP))
       CASE  (cAsin)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF ((css%Stack(SP)<-1._rn).OR.(css%Stack(SP)>1._rn)) THEN
             if (parse_bdeb) write(*,*)"*** Invalid argument to ASIN:",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Invalid argument to ASIN.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=4
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=ASIN(css%Stack(SP))
       CASE  (cAcos)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF ((css%Stack(SP)<-1._rn).OR.(css%Stack(SP)>1._rn)) THEN
             if (parse_bdeb) write(*,*)"*** Invalid argument to ACOS:",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Invalid argument to ACOS.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=4
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=ACOS(css%Stack(SP))
       CASE  (cAtan2)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.EQ.2) THEN
             css%Stack(SP)=ATAN2(css%Stack(SP),css%Stack(SP+1))
          ELSE 
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to atan2:",nargs
             irc=310
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to atan2.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          END IF
       CASE  (cAtan)
          css%Stack(SP)=ATAN(css%Stack(SP))
       CASE  DEFAULT
          SP=SP+1
          if (css%ByteCode(IP) .le. css%VarEnd) then
             ii=css%ByteCode(IP)-VarBegin+1
             if (parse_bdeb.and.ii.gt.imax)write(*,*) myname,'Invalid VAL-index:',ii,"(max=",size(val),")"
             css%Stack(SP)=Val(ii)
          else
             css%Stack(SP)=ConstVal(css%ByteCode(IP)-css%VarEnd)
          end if
       END SELECT
       if(parse_bdeb)then
          if (sp.ne.0) then
             write(str250,'(100(X,F0.2))') &
                  & (css%Stack(II),II=1,min(SP,100))
          else
             STR250=""
          end if
          call chop0(str250,250)
          lens=length(str250,250,10)
          write(*,'(X,A,5X,A)') myname,&
               & "stack=["//str250(1:LENS)//"]"
       end if
    END DO
    EvalErrType = 0
    res = css%Stack(1)
    if(parse_bdeb)write(*,*) myname,"Result=",res
    !if(parse_bdeb)write(*,*)myname,"Done."
  END FUNCTION parse_evalf
  !
  subroutine parse_evals (css, Val, set, res, ret, crc250,irc) 
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Evaluate bytecode of ith function for the values passed in array Val(:)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    type(parse_session), pointer :: css
    REAL(rn), allocatable, INTENT(in)  :: Val(:)             ! Variable values
    logical, allocatable, INTENT(in)   :: set(:)            ! is variable set?
    REAL(rn)                           :: res                ! Result
    logical                            :: ret                ! is result set?
    character*250 :: crc250
    integer :: irc
    INTEGER                            :: IP,              & ! Instruction pointer
         DP,              & ! Data pointer
         SP,              & ! Stack pointer
         AP,              & ! arguments pointer
         AI                 ! arguments index
    REAL(rn),                PARAMETER :: zero = 0._rn
    integer :: ii, nargs
    character*22 :: myname ="parse_evals"
    character*250 :: str250
    real(rn) :: eps
    integer :: lens,imax
    integer, external :: length
    logical :: above,below,found
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    if (.not.associated(css)) then
       if(parse_bdeb)write(*,*)myname,"Input ",&
            & imax,size(set),&
            & allocated(val),allocated(set)
       irc=911
       call parse_errorappend(crc250,myname//" Invalid session.")
       return
    end if
    imax=size(val)
    css%clen=0
    if(parse_bdeb)write(*,*)myname,"Entering '"//css%funcStr100(1:css%lenf)//"'",&
         & imax,size(set),&
         & allocated(val),allocated(set)
    if(parse_bdeb)write(*,*)myname,"Entering"
    ret=.true.
    DP = 1
    SP = 0
    AP = 0 ! argument position
    AI = 0 ! argument function index
    DO IP=1,css%ByteCodeSize
       SELECT CASE (css%ByteCode(IP))
       CASE (cImmed)
          SP=SP+1
          css%Stack(SP)=css%Immed(DP)
          DP=DP+1
       CASE   (cNeg)
          css%Stack(SP)=-css%Stack(SP)
       CASE   (cAdd)
          css%Stack(SP-1)=css%Stack(SP-1)+css%Stack(SP)
          SP=SP-1
       CASE   (cSub)
          css%Stack(SP-1)=css%Stack(SP-1)-css%Stack(SP)
          SP=SP-1
       CASE   (cMul)
          css%Stack(SP-1)=css%Stack(SP-1)*css%Stack(SP)
          SP=SP-1
       CASE   (cDiv)
          IF (css%Stack(SP)==0._rn) THEN
             if (parse_bdeb) write(*,*)"*** Division by zero."
             irc=313
             call parse_errorappend(crc250,myname//" Division by zero.\n")
             EvalErrType=1
             res=zero
             RETURN
          ENDIF
          css%Stack(SP-1)=css%Stack(SP-1)/css%Stack(SP)
          SP=SP-1
       CASE   (cPow)
          css%Stack(SP-1)=css%Stack(SP-1)**css%Stack(SP)
          SP=SP-1
       CASE   (cAbs)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=ABS(css%Stack(SP))
       CASE   (cExp)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=EXP(css%Stack(SP))
       CASE (cLog10)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (css%Stack(SP)<=0._rn) THEN
             if (parse_bdeb) write(*,*)"*** Negative argument to LOG10:",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Negative argument to LOG10.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=3
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=LOG10(css%Stack(SP))
       CASE   (cLog)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (css%Stack(SP)<=0._rn) THEN
             if (parse_bdeb) write(*,*)"*** Negative argument to LOG:",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Negative argument to LOG.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=3
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=LOG(css%Stack(SP))
       CASE  (cSqrt)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (css%Stack(SP)<0._rn) THEN
             if (parse_bdeb) write(*,*)"*** Negative argument to SQRT:",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Negative argument to SQRT.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=3
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=SQRT(css%Stack(SP))
       CASE  (cMsgMax)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=1.0D0
       CASE  (cMsgMin)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=1.0D0
       CASE  (cMsgClosest)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=1.0D0
       CASE  (cisMember)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=.false.
          ISMEMBER: DO II=1,NARGS-1
             if (css%stack(SP).eq.css%Stack(SP+II)) then
                found=.true.
                exit ISMEMBER
             end if
          end do ISMEMBER
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cisBelow)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=.true.
          ISBELOW: DO II=1,NARGS-1
             if (css%stack(SP).ge.css%Stack(SP+II)) then
                found=.false.
                exit ISBELOW
             end if
          end do ISBELOW
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cisAbove)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=.true.
          ISABOVE: DO II=1,NARGS-1
             if (css%stack(SP).le.css%Stack(SP+II)) then
                found=.false.
                exit ISABOVE
             end if
          end do ISABOVE
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cisBetween)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          above=.false.
          below=.false.
          ISBETWEEN: DO II=1,NARGS-1
             if (css%stack(SP).le.css%Stack(SP+II)) then
                BELOW=.TRUE.
             end if
             if (css%stack(SP).ge.css%Stack(SP+II)) then
                ABOVE=.TRUE.
             end if
             if (above.and.below) exit ISBETWEEN
          end do ISBETWEEN
          if (above.and.below) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cThinned)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.ge.1) THEN ! 
             if (rand()*100 .gt. css%Stack(SP)) then
                css%Stack(SP)=1.0D0
             else
                css%Stack(SP)=0.0D0
             end if
          end if
       CASE  (cand)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=(abs(css%stack(SP)).gt.0.5D0)
          if (found) then
             AND: DO II=1,NARGS-1
                if (abs(css%Stack(SP+II)).lt.0.5D0) then
                   found=.false.
                   exit AND
                end if
             end do AND
          end if
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cor)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          found=(abs(css%stack(SP)).gt.0.5D0)
          if (.not.found) then
             OR: DO II=1,NARGS-1
                if (abs(css%Stack(SP+II)).gt.0.5D0) then
                   found=.true.
                   exit OR
                end if
             end do OR
          end if
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (cnot)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          ! .not.a .and. .not.b ....
          found=(abs(css%stack(SP)).lt.0.5D0)
          if (found) then
             NOT: DO II=1,NARGS-1
                if (abs(css%Stack(SP+II)).gt.0.5D0) then
                   found=.false.
                   exit NOT
                end if
             end do NOT
          end if
          if (found) then
             css%Stack(SP)=1.0D0
          else
             css%Stack(SP)=0.0D0
          end if
       CASE  (c1970yy)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_yy(css%Stack(SP))
       CASE  (c1970mm)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_mm(css%Stack(SP))
       CASE  (c1970dd)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_dd(css%Stack(SP))
       CASE  (c1970hh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_hh(css%Stack(SP))
       CASE  (c1970mi)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_f1970_mi(css%Stack(SP))
       CASE  (c1970)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.EQ.1) THEN ! dtg()
             css%Stack(SP)=css%Stack(SP)+parse_f1970(real(val8(1)),real(val8(2)),&
                  &real(val8(3)),real(val8(5)),real(val8(6)),real(val8(7)))
          ELSE IF (NARGS.EQ.6) THEN ! dtg(year,month,day,hour,min,sec)
             css%Stack(SP)=parse_f1970(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  css%Stack(SP+4), &
                  css%Stack(SP+5))
          ELSE IF (NARGS.EQ.5) THEN ! dtg(year,month,day,hour,min)
             css%Stack(SP)=parse_f1970(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  css%Stack(SP+4), &
                  0.0D0)
          ELSE IF (NARGS.EQ.4) THEN ! dtg(year,month,day,hour)
             css%Stack(SP)=parse_f1970(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  0.0D0, &
                  0.0D0)
          ELSE 
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to s1970:",nargs
             irc=311
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to s1970.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          END IF
       CASE  (cjulianyy)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_yy(css%Stack(SP))
       CASE  (cjulianmm)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_mm(css%Stack(SP))
       CASE  (cjuliandd)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_dd(css%Stack(SP))
       CASE  (cjulianhh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_hh(css%Stack(SP))
       CASE  (cjulianmi)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=parse_fjulian_mi(css%Stack(SP))
       CASE  (cjulian)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.EQ.1) THEN ! dtg()
             css%Stack(SP)=css%Stack(SP)+parse_fjulian(real(val8(1)),real(val8(2)),&
                  &real(val8(3)),real(val8(5)),real(val8(6)),real(val8(7)))
          ELSE IF (NARGS.EQ.6) THEN ! dtg(year,month,day,hour,min,sec)
             css%Stack(SP)=parse_fjulian(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  css%Stack(SP+4), &
                  css%Stack(SP+5))
          ELSE IF (NARGS.EQ.5) THEN ! dtg(year,month,day,hour,min)
             css%Stack(SP)=parse_fjulian(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  css%Stack(SP+4), &
                  0.0D0)
          ELSE IF (NARGS.EQ.4) THEN ! dtg(year,month,day,hour)
             css%Stack(SP)=parse_fjulian(css%Stack(SP), &
                  css%Stack(SP+1), &
                  css%Stack(SP+2), &
                  css%Stack(SP+3), &
                  0.0D0, &
                  0.0D0)
          ELSE 
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to d2000:",nargs
             irc=312
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to d2000.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          END IF
       CASE  (cmidnight)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=css%Stack(SP)*secperday+parse_f1970(real(val8(1)),real(val8(2)),&
               &real(val8(3)),0.0D0,0.0D0,0.0D0)
          do ii=1,nargs-1
             css%Stack(SP)=css%Stack(SP)+css%Stack(SP+ii)*secperday
          end do
       CASE  (cnow)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=css%Stack(SP)*secperday+parse_f1970(real(val8(1)),real(val8(2)),&
               &real(val8(3)),real(val8(5)),real(val8(6)),real(val8(7)))
          do ii=1,nargs-1
             css%Stack(SP)=css%Stack(SP)+css%Stack(SP+ii)*secperday
          end do
       CASE  (cround)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.gt.1) then
             eps=max(1.0D-5,abs(css%Stack(SP+1)))
             css%Stack(SP)=dnint(css%Stack(SP)/eps)*eps
          else
             css%Stack(SP)=dnint(css%Stack(SP))
          end if
       CASE  (cVarName)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.1) then
             if (parse_bdeb) write(*,*)"*** Found shape:",nint(css%stack(sp))
             if (allocated(css%cbuff)) deallocate(css%cbuff)
             css%clen=25
             allocate(character(len=css%clen) :: css%cbuff)
             css%cbuff=trim(getname25(css%Stack(SP)))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to shapes:",nargs
             irc=312
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to shapes.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cValidRange)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.3) then
             if (parse_bdeb) write(*,*)"*** Found range-check"
             if (css%Stack(SP).lt.css%Stack(SP+1).or.&
                  & css%Stack(SP).gt.css%Stack(SP+2)) then
                if (allocated(css%cbuff)) deallocate(css%cbuff)
                css%clen=2
                allocate(character(len=css%clen) :: css%cbuff)
                css%cbuff="NA"
             end if
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to rangeCheck:",nargs
             irc=312
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to rangeCheck.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cShpPre)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=shapeid(css%Stack(SP),css%Stack(SP+1))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to shape:",nargs
             irc=310
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to shape.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cShpVic)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.3) then
             css%Stack(SP)=vicinity(css%Stack(SP),css%Stack(SP+1),css%Stack(SP+2))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to shape:",nargs
             irc=310
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to shape.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (ctd2q) ! td,p
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=td2q(css%Stack(SP),css%Stack(SP+1))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to td2q:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to td2q.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (crh2td) ! rh, t, [ice=1,0]
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=rh2td(css%Stack(SP),css%Stack(SP+1))
          else if (nargs.eq.3) then
             css%Stack(SP)=rh2td(css%Stack(SP),css%Stack(SP+1),css%Stack(SP+2))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to rh2td:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to rh2td.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (ctd2rh) ! td, t, [ice=1,0]
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=td2rh(css%Stack(SP),css%Stack(SP+1))
          else if (nargs.eq.3) then
             css%Stack(SP)=td2rh(css%Stack(SP),css%Stack(SP+1),css%Stack(SP+2))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to td2rh:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to td2rh.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cq2rh) ! q, t, [p|1013.25]
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             css%Stack(SP)=q2rh(css%Stack(SP),css%Stack(SP+1))
          else if (nargs.eq.3) then
             css%Stack(SP)=q2rh(css%Stack(SP),css%Stack(SP+1),css%Stack(SP+2))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to q2rh:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to q2rh.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (ck2c)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=css%Stack(SP)-t0
       CASE  (cc2k)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=css%Stack(SP)+t0
       CASE  (cSinh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=SINH(css%Stack(SP))
       CASE  (cCosh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=COSH(css%Stack(SP))
       CASE  (cTanh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=TANH(css%Stack(SP))
       CASE   (cSin)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=SIN(css%Stack(SP))
       CASE   (cCos)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=COS(css%Stack(SP))
       CASE   (cTan)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          css%Stack(SP)=TAN(css%Stack(SP))
       CASE  (cAsin)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF ((css%Stack(SP)<-1._rn).OR.(css%Stack(SP)>1._rn)) THEN
             if (parse_bdeb) write(*,*)"*** Invalid argument to ASIN:",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Invalid argument to ASIN.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=4
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=ASIN(css%Stack(SP))
       CASE  (cAcos)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF ((css%Stack(SP)<-1._rn).OR.(css%Stack(SP)>1._rn)) THEN
             if (parse_bdeb) write(*,*)"*** Invalid argument to ACOS:",css%Stack(SP)
             irc=313
             call parse_errorappend(crc250,myname//" Invalid argument to ACOS.")
             call parse_errorappendr(crc250,css%Stack(SP))
             call parse_errorappend(crc250,"\n")
             EvalErrType=4
             res=zero
             RETURN
          ENDIF
          css%Stack(SP)=ACOS(css%Stack(SP))
       CASE  (cAtan2)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.EQ.2) THEN
             css%Stack(SP)=ATAN2(css%Stack(SP),css%Stack(SP+1))
          ELSE 
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to atan2:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to atan2.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          END IF
       CASE  (cAtan)
          css%Stack(SP)=ATAN(css%Stack(SP))
       CASE  DEFAULT
          SP=SP+1
          if (css%ByteCode(IP) .le. css%VarEnd) then
             css%Stack(SP)=Val(css%ByteCode(IP)-VarBegin+1)
             if (.not.set(css%ByteCode(IP)-VarBegin+1)) ret=.false.
          else
             css%Stack(SP)=ConstVal(css%ByteCode(IP)-css%VarEnd)
          end if
       END SELECT
       if(parse_bdeb)then
          if (sp.ne.0) then
             write(str250,'(100(X,F0.2))') &
                  & (css%Stack(II),II=1,min(SP,100))
          else
             STR250=""
          end if
          call chop0(str250,250)
          lens=length(str250,250,10)
          write(*,'(X,A,5X,A)') myname,&
               & "Stack=["//str250(1:LENS)//"]"
       end if
    END DO
    EvalErrType = 0
    res = css%Stack(1)
    if(parse_bdeb)write(*,'(X,A,X,A,X,F0.2,X,L1)') myname," result=",res,ret
    if(parse_bdeb)write(*,*)myname,"Done."
  END subroutine parse_evals
  !
  subroutine parse_evala (css, ctrg, cpos, npos, Val, Set, Res, crc250,irc)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Evaluate bytecode of ith function for the values passed in array Val(:)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    type(parse_session), pointer,INTENT(IN):: css
    integer(is),INTENT(in)                 :: ctrg,cpos  ! allocated targets, positions
    integer(is),INTENT(in)                 :: npos       ! number of positions
    REAL(rn), allocatable, INTENT(in)      :: Val(:,:)   ! Variable values
    logical, allocatable, INTENT(in)       :: Set(:)     ! is position defined?
    REAL(rn),allocatable,INTENT(INOUT)       :: res(:)     ! Result
    character*250 :: crc250
    integer :: irc
    INTEGER                            :: IP,              & ! Instruction pointer
         DP,              & ! Data pointer
         SP,              & ! Stack pointer
         AP,              & ! arguments pointer
         AI                 ! arguments index
    REAL(rn),                PARAMETER :: zero = 0._rn
    integer :: ii, jj, nargs, imax,imin,iclo
    real(rn) :: vmax,vmin,vclo,v,buff
    logical :: above, below, found
    character*250 :: str250
    real(rn) :: eps
    integer :: lens
    integer, external :: length
    character*12 :: myname ="parse_evala"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    if (.not.associated(css)) then
       if(parse_bdeb)write(*,*)myname,"Input ",&
            & ctrg, cpos, npos, size(val),size(set),size(res),&
            & allocated(val),allocated(set),allocated(res)
       irc=911
       call parse_errorappend(crc250,myname//" Invalid session.")
       return
    end if
    css%clen=0
    if(parse_bdeb)write(*,*)myname,"Entering '"//css%funcStr100(1:css%lenf)//"'",&
         & ctrg, cpos, npos, size(val),size(set),size(res),&
         & allocated(val),allocated(set),allocated(res)
    if (css%npos.lt.npos) then
       css%npos=npos
       IF (ASSOCIATED(css%Stacka)) DEALLOCATE ( css%Stacka, stat=irc)
       IF (ASSOCIATED(css%Wrka))   DEALLOCATE ( css%Wrka,   stat=irc)
       ALLOCATE (css%Stacka(css%StackSize,css%npos),css%Wrka(css%npos),STAT = irc)
       IF (irc.ne. 0) THEN
          call parse_errorappend(crc250,myname//" Unable to allocate stacka, stacka, wrka.\n")
          return
       end if
    end if
    !
    DP = 1
    SP = 0
    AP = 0
    AI = 0
    DO IP=1,css%ByteCodeSize
       if(parse_bdeb)then
          NARGS=css%ArgsByte(AI+1)
          write(*,*)myname,'Index:',ip,css%ByteCodeSize
          write(*,'(X,A,X,A,X,I3,X,I3,3X,A,3X,I0,X,I0)')myname,"Looping",&
               & IP,css%ByteCode(IP),parse_code20(css%bytecode(ip),nargs)
       end if
       SELECT CASE (css%ByteCode(IP))
       CASE (cImmed)
          if(parse_bdeb)write(*,*)myname,'Immed enter:',SP,DP,NPOS,size(set)
          SP=SP+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                if(parse_bdeb)write(*,*)myname,'Immed eval:',SP,jj,&
                     & associated(css%stacka),associated(css%immed)
                css%Stacka(SP,JJ)=css%Immed(DP)
             END IF
          END DO
          DP=DP+1
          if(parse_bdeb)write(*,*)myname,'Immed done:',SP,DP,NPOS,size(set)
       CASE   (cNeg)
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                if (parse_bdeb)write(*,*)myname,'Neg.'
                css%Stacka(SP,JJ)=-css%Stacka(SP,JJ)
             END IF
          END DO
       CASE   (cAdd)
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP-1,JJ)=css%Stacka(SP-1,JJ)+css%Stacka(SP,JJ)
             END IF
          END DO
          SP=SP-1
       CASE   (cSub)
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP-1,JJ)=css%Stacka(SP-1,JJ)-css%Stacka(SP,JJ)
             END IF
          END DO
          SP=SP-1
       CASE   (cMul)
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP-1,JJ)=css%Stacka(SP-1,JJ)*css%Stacka(SP,JJ)
             END IF
          END DO
          SP=SP-1
       CASE   (cDiv)
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                IF (css%Stacka(SP,JJ)==0._rn) THEN
                   if (parse_bdeb) write(*,*)"*** Division by zero."
                   irc=314
                   call parse_errorappend(crc250,myname//" Division by zero.\n")
                   EvalErrType=1
                   RETURN
                ENDIF
                css%Stacka(SP-1,JJ)=css%Stacka(SP-1,JJ)/css%Stacka(SP,JJ)
             END IF
          END DO
          SP=SP-1
       CASE   (cPow)
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP-1,JJ)=css%Stacka(SP-1,JJ)**css%Stacka(SP,JJ)
             END IF
          END DO
          SP=SP-1
       CASE   (cAbs)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=ABS(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE   (cExp)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=EXP(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE (cLog10)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                IF (css%Stacka(SP,JJ)<=0._rn) THEN
                   if (parse_bdeb) write(*,*)"*** Invalid argument to ACOS:",css%Stack(SP)
                   irc=315
                   call parse_errorappend(crc250,myname//" Negative argument to LOG10.")
                   call parse_errorappendr(crc250,css%Stack(SP))
                   call parse_errorappend(crc250,"\n")
                   EvalErrType=3
                   RETURN
                ELSE
                   css%Stacka(SP,JJ)=LOG10(css%Stacka(SP,JJ))
                ENDIF
             END IF
          END DO
       CASE   (cLog)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                IF (css%Stacka(SP,JJ)<=0._rn) THEN
                   if (parse_bdeb) write(*,*)"*** Invalid argument to ACOS:",css%Stack(SP)
                   irc=316
                   call parse_errorappend(crc250,myname//" Negative argument to LOG.")
                   call parse_errorappendr(crc250,css%Stack(SP))
                   call parse_errorappend(crc250,"\n")
                   EvalErrType=3
                   RETURN
                ELSE
                   css%Stacka(SP,JJ)=LOG(css%Stacka(SP,JJ))
                ENDIF
             END IF
          END DO
       CASE  (cSqrt)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                IF (css%Stacka(SP,JJ)<0._rn) THEN
                   if (parse_bdeb) write(*,*)"*** Invalid argument to ACOS:",css%Stack(SP)
                   irc=317
                   call parse_errorappend(crc250,myname//" Negative argument to SQRT.")
                   call parse_errorappendr(crc250,css%Stack(SP))
                   call parse_errorappend(crc250,"\n")
                   EvalErrType=3
                   RETURN
                ELSE
                   css%Stacka(SP,JJ)=SQRT(css%Stacka(SP,JJ))
                ENDIF
             END IF
          END DO
       CASE  (cMsgMax)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IMAX=0
          VMAX=0.0D0
          DO JJ=1,NPOS
             if(set(jj))then
                if (imax.eq.0) then
                   imax=jj
                   vmax=css%Stacka(SP,JJ)
                else if (css%Stacka(SP,JJ).gt.vmax) then
                   imax=jj
                   vmax=css%Stacka(SP,JJ)
                end if
             end if
          END DO
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=0.0D0
             END IF
          END DO
          IF (IMAX.NE.0) css%Stacka(SP,imax)=1.0D0
       CASE  (cMsgMin)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IMIN=0
          VMIN=0.0D0
          DO JJ=1,NPOS
             if(set(jj))then
                if (imin.eq.0) then
                   imin=jj
                   vmin=css%Stacka(SP,JJ)
                else if (css%Stacka(SP,JJ).lt.vmin) then
                   imin=jj
                   vmin=css%Stacka(SP,JJ)
                end if
             end if
          END DO
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=0.0D0
             END IF
          END DO
          IF (IMIN.NE.0) css%Stacka(SP,imin)=1.0D0
       CASE  (cMsgClosest)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             css%wrka(jj)=0.0D0
          END DO
          DO II=1,NARGS-1
             iclo=0
             vclo=0.0D0
             DO JJ=1,NPOS
                if(set(jj))then
                   v=abs(css%Stacka(SP,jj)-css%stacka(SP+II,JJ))
                   if (iclo.eq.0) then
                      iclo=jj
                      vclo=v
                   else if (v.lt.vclo) then
                      iclo=jj
                      vclo=v
                   end if
                end if
             END DO
             if (iclo.ne.0)css%wrka(iclo)=1.0D0
          end do
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=css%wrka(jj)
             END IF
          END DO
       CASE  (cisMember)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                found=.false.
                ISMEMBER: DO II=1,NARGS-1
                   if (css%stacka(SP,JJ).eq.css%stacka(SP+II,JJ)) then
                      found=.true.
                      exit ISMEMBER
                   end if
                end do ISMEMBER
                if (found) then
                   css%Stacka(SP,JJ)=1.0D0
                else
                   css%Stacka(SP,JJ)=0.0D0
                end if
             END IF
          END DO
       CASE  (cisBelow)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                found=.true.
                ISBELOW: DO II=1,NARGS-1
                   if (css%stacka(SP,JJ).ge.css%stacka(SP+II,JJ)) then
                      found=.false.
                      exit ISBELOW
                   end if
                end do ISBELOW
                if (found) then
                   css%Stacka(SP,JJ)=1.0D0
                else
                   css%Stacka(SP,JJ)=0.0D0
                end if
             END IF
          END DO
       CASE  (cisAbove)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                found=.true.
                ISABOVE: DO II=1,NARGS-1
                   if (parse_bdeb) write(*,*)myname,'Isabove:',jj,sp,css%stacka(SP,JJ),css%stacka(SP+II,JJ)
                   if (css%stacka(SP,JJ).le.css%stacka(SP+II,JJ)) then
                      found=.false.
                      exit ISABOVE
                   end if
                end do ISABOVE
                if (found) then
                   css%Stacka(SP,JJ)=1.0D0
                else
                   css%Stacka(SP,JJ)=0.0D0
                end if
                if (parse_bdeb) write(*,*)myname,'Isabove done:',jj,sp,found
             END IF
          END DO
       CASE  (cisBetween)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                above=.false.
                below=.false.
                ISBETWEEN: DO II=1,NARGS-1
                   if (css%stacka(SP,JJ).le.css%stacka(SP+II,JJ)) then
                      BELOW=.TRUE.
                   end if
                   if (css%stacka(SP,JJ).ge.css%stacka(SP+II,JJ)) then
                      ABOVE=.TRUE.
                   end if
                   if (above.and.below) exit ISBETWEEN
                end do ISBETWEEN
                if (above.and.below) then
                   css%Stacka(SP,JJ)=1.0D0
                else
                   css%Stacka(SP,JJ)=0.0D0
                end if
             END IF
          END DO
       CASE  (cThinned)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.ge.1) THEN ! 
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   if (rand()*100 .gt. css%Stacka(SP,JJ)) then
                      css%Stacka(SP,JJ)=1.0D0
                   else
                      css%Stacka(SP,JJ)=0.0D0
                   end if
                END IF
             END DO
          end if
       CASE  (cand)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                found=(abs(css%stacka(SP,JJ)).gt.0.5D0)
                if (found) then
                   AND: DO II=1,NARGS-1
                      if (abs(css%stacka(SP+II,JJ)).lt.0.5D0) then
                         found=.false.
                         exit AND
                      end if
                   end do AND
                end if
                if (found) then
                   css%Stacka(SP,JJ)=1.0D0
                else
                   css%Stacka(SP,JJ)=0.0D0
                end if
             END IF
          END DO
       CASE  (cor)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                found=(abs(css%stacka(SP,JJ)).gt.0.5D0)
                if (.not.found) then
                   OR: DO II=1,NARGS-1
                      if (abs(css%stacka(SP+II,JJ)).gt.0.5D0) then
                         found=.true.
                         exit OR
                      end if
                   end do OR
                end if
                if (found) then
                   css%Stacka(SP,JJ)=1.0D0
                else
                   css%Stacka(SP,JJ)=0.0D0
                end if
             END IF
          END DO
       CASE  (cnot)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                ! .not.a .and. .not.b ....
                found=(abs(css%stacka(SP,JJ)).lt.0.5D0)
                if (found) then
                   NOT: DO II=1,NARGS-1
                      if (abs(css%stacka(SP+II,JJ)).gt.0.5D0) then
                         found=.false.
                         exit NOT
                      end if
                   end do NOT
                end if
                if (found) then
                   css%Stacka(SP,JJ)=1.0D0
                else
                   css%Stacka(SP,JJ)=0.0D0
                end if
             END IF
          END DO
       CASE  (c1970yy)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_f1970_yy(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (c1970mm)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_f1970_mm(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (c1970dd)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_f1970_dd(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (c1970hh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_f1970_hh(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (c1970mi)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_f1970_mi(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (c1970)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.EQ.1) THEN ! dtg(days)
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=css%Stacka(SP,JJ)+parse_f1970(real(val8(1)),real(val8(2)),&
                        &real(val8(3)),real(val8(5)),real(val8(6)),real(val8(7)))
                END IF
             END DO
          ELSE IF (NARGS.EQ.6) THEN ! dtg(year,month,day,hour,min,sec)
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=parse_f1970(css%Stacka(SP,JJ), &
                        css%stacka(SP+1,JJ), &
                        css%stacka(SP+2,JJ), &
                        css%stacka(SP+3,JJ), &
                        css%stacka(SP+4,JJ), &
                        css%stacka(SP+5,JJ))
                END IF
             END DO
          ELSE IF (NARGS.EQ.5) THEN ! dtg(year,month,day,hour,min)
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=parse_f1970(css%Stacka(SP,JJ), &
                        css%stacka(SP+1,JJ), &
                        css%stacka(SP+2,JJ), &
                        css%stacka(SP+3,JJ), &
                        css%stacka(SP+4,JJ), &
                        0.0D0)
                END IF
             END DO
          ELSE IF (NARGS.EQ.4) THEN ! dtg(year,month,day,hour)
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=parse_f1970(css%Stacka(SP,JJ), &
                        css%stacka(SP+1,JJ), &
                        css%stacka(SP+2,JJ), &
                        css%stacka(SP+3,JJ), &
                        0.0D0, &
                        0.0D0)
                END IF
             END DO
          ELSE 
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to s1970:",nargs
             irc=318
             call parse_errorappend(crc250,myname//" Invalid number of arguments to s1970.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             RETURN
          END IF
       CASE  (cjulianyy)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_fjulian_yy(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (cjulianmm)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_fjulian_mm(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (cjuliandd)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_fjulian_dd(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (cjulianhh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_fjulian_hh(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (cjulianmi)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=parse_fjulian_mi(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (cjulian)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.EQ.1) THEN ! dtg()
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=css%Stacka(SP,JJ)+parse_fjulian(real(val8(1)),real(val8(2)),&
                        &real(val8(3)),real(val8(5)),real(val8(6)),real(val8(7)))
                END IF
             END DO
          ELSE IF (NARGS.EQ.6) THEN ! dtg(year,month,day,hour,min,sec)
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=parse_fjulian(css%Stacka(SP,JJ), &
                        css%stacka(SP+1,JJ), &
                        css%stacka(SP+2,JJ), &
                        css%stacka(SP+3,JJ), &
                        css%stacka(SP+4,JJ), &
                        css%stacka(SP+5,JJ))
                END IF
             END DO
          ELSE IF (NARGS.EQ.5) THEN ! dtg(year,month,day,hour,min)
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=parse_fjulian(css%Stacka(SP,JJ), &
                        css%stacka(SP+1,JJ), &
                        css%stacka(SP+2,JJ), &
                        css%stacka(SP+3,JJ), &
                        css%stacka(SP+4,JJ), &
                        0.0D0)
                END IF
             END DO
          ELSE IF (NARGS.EQ.4) THEN ! dtg(year,month,day,hour)
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=parse_fjulian(css%Stacka(SP,JJ), &
                        css%stacka(SP+1,JJ), &
                        css%stacka(SP+2,JJ), &
                        css%stacka(SP+3,JJ), &
                        0.0D0, &
                        0.0D0)
                END IF
             END DO
          ELSE 
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to d2000:",nargs
             irc=319
             call parse_errorappend(crc250,myname//" Invalid number of arguments to d2000.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             RETURN
          END IF
       CASE  (cmidnight)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          buff=parse_f1970(real(val8(1)),real(val8(2)),&
               &real(val8(3)),0.0D0,0.0D0,0.0D0)
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stack(SP)=css%Stack(SP)*secperday+buff
                do ii=1,nargs-1
                   css%Stack(SP)=css%Stack(SP)+css%Stack(SP+ii)*secperday
                end do
             end if
          end do
       CASE  (cnow)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          buff=parse_f1970(real(val8(1)),real(val8(2)),&
               &real(val8(3)),real(val8(5)),real(val8(6)),real(val8(7)))
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=css%Stacka(SP,JJ)*secperday+buff
                do ii=1,nargs-1
                   css%Stacka(SP,jj)=css%Stacka(SP,jj)+css%Stacka(SP+ii,jj)*secperday
                end do
             end if
          end do
       CASE  (cround)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.gt.1) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   eps=max(1.0D-5,abs(css%Stacka(SP+1,JJ)))
                   css%Stacka(SP,JJ)=dnint(css%Stacka(SP,JJ)/eps)*eps
                end if
             end do
          else
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=dnint(css%Stacka(SP,JJ))
                end if
             end do
          end if
       CASE  (cVarName)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.1) then
             if (parse_bdeb) write(*,*)"*** Found shape:",nint(css%stacka(sp,1))
             if (allocated(css%cbuff)) deallocate(css%cbuff)
             css%clen=25
             allocate(character(len=css%clen) :: css%cbuff)
             css%cbuff=trim(getname25(css%Stacka(SP,1)))
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to shapes:",nargs
             irc=312
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to shapes.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cValidRange)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.3) then
             if (parse_bdeb) write(*,*)"*** Found validRange"
             DO JJ=1,NPOS
                if (css%StackA(SP,JJ).lt.css%Stacka(SP+1,JJ).or.&
                  & css%Stacka(SP,JJ).gt.css%Stacka(SP+2,JJ)) then
                   if (allocated(css%cbuff)) deallocate(css%cbuff)
                   css%clen=25
                   allocate(character(len=css%clen) :: css%cbuff)
                   css%cbuff=trim(getname25(css%Stacka(SP,1)))
                end if
             end do
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to validRange:",nargs
             irc=312
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to validRange.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cShpPre)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=shapeid(css%Stacka(SP,JJ),css%Stacka(SP+1,JJ))
                end if
             end do
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to shape:",nargs
             irc=310
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to shape.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cShpVic)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.3) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=vicinity(css%Stacka(SP,JJ),css%Stacka(SP+1,JJ),css%Stacka(SP+2,JJ))
                end if
             end do
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to shape:",nargs
             irc=310
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to shape.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (ctd2q) ! td,p
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=td2q(css%Stacka(SP,JJ),css%Stacka(SP+1,JJ))
                END IF
             END DO
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to td2q:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to td2q.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (crh2td) ! rh, t, [ice=1,0]
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=rh2td(css%Stacka(SP,JJ),css%Stacka(SP+1,JJ))
                END IF
             END DO
          else if (nargs.eq.3) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=rh2td(css%Stacka(SP,JJ),css%Stacka(SP+1,JJ),css%Stacka(SP+2,JJ))
                END IF
             END DO
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to rh2td:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to rh2td.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (ctd2rh) ! td, t, [ice=1,0]
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=td2rh(css%Stacka(SP,JJ),css%Stacka(SP+1,JJ))
                END IF
             END DO
          else if (nargs.eq.3) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=td2rh(css%Stacka(SP,JJ),css%Stacka(SP+1,JJ),css%Stacka(SP+2,JJ))
                END IF
             END DO
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to td2rh:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to td2rh.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (cq2rh) ! q, t, [p|1013.25]
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          if (nargs.eq.2) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=q2rh(css%Stacka(SP,JJ),css%Stacka(SP+1,JJ))
                END IF
             END DO
          else if (nargs.eq.3) then
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=q2rh(css%Stacka(SP,JJ),css%Stacka(SP+1,JJ),css%Stacka(SP+2,JJ))
                END IF
             END DO
          else
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to q2rh:",nargs
             irc=313
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to q2rh.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             res=zero
             RETURN
          end if
       CASE  (ck2c)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=css%Stacka(SP,JJ)-t0
             END IF
          END DO
       CASE  (cc2k)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=css%Stacka(SP,JJ)+t0
             END IF
          END DO
       CASE  (cSinh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=SINH(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (cCosh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=COSH(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (cTanh)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=TANH(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE   (cSin)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=SIN(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE   (cCos)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=COS(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE   (cTan)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=TAN(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  (cAsin)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                IF ((css%Stacka(SP,JJ)<-1._rn).OR.(css%Stacka(SP,JJ)>1._rn)) THEN
                   if (parse_bdeb) write(*,*)"*** Invalid argument to ASIN:",css%Stacka(SP,JJ)
                   irc=320
                   call parse_errorappend(crc250,myname//" Invalid arguments to asin.")
                   call parse_errorappendr(crc250,css%Stacka(SP,JJ))
                   call parse_errorappend(crc250,"\n")
                   EvalErrType=4
                   RETURN
                ELSE
                   css%Stacka(SP,JJ)=ASIN(css%Stacka(SP,JJ))
                ENDIF
             END IF
          END DO
       CASE  (cAcos)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                IF ((css%Stacka(SP,JJ)<-1._rn).OR.(css%Stacka(SP,JJ)>1._rn)) THEN
                   if (parse_bdeb) write(*,*)"*** Invalid argument to ACOS:",css%Stacka(SP,JJ)
                   irc=321
                   call parse_errorappend(crc250,myname//" Invalid arguments to acos.")
                   call parse_errorappendr(crc250,css%Stacka(SP,JJ))
                   call parse_errorappend(crc250,"\n")
                   EvalErrType=4
                   RETURN
                ELSE
                   css%Stacka(SP,JJ)=ACOS(css%Stacka(SP,JJ))
                ENDIF
             END IF
          END DO
       CASE  (cAtan2)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          IF (NARGS.EQ.2) THEN
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=ATAN2(css%Stacka(SP,JJ),css%stacka(SP+1,JJ))
                END IF
             END DO
          ELSE 
             if (parse_bdeb) write(*,*)"*** Unexpected number of arguments to atan2:",nargs
             irc=322
             call parse_errorappend(crc250,myname//" Unexpected number of arguments to atan2.")
             call parse_errorappendi(crc250,nargs)
             call parse_errorappend(crc250,"\n")
             EvalErrType=5
             RETURN
          END IF
       CASE  (cAtan)
          AI=AI+1
          NARGS=css%ArgsByte(AI)
          SP=SP-NARGS+1
          DO JJ=1,NPOS
             IF(SET(JJ))THEN
                css%Stacka(SP,JJ)=ATAN(css%Stacka(SP,JJ))
             END IF
          END DO
       CASE  DEFAULT
          SP=SP+1
          if (css%ByteCode(IP) .le. css%VarEnd) then
             ii=css%ByteCode(IP)-VarBegin+1
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=Val(ii,JJ)
                END IF
             END DO
          else
             DO JJ=1,NPOS
                IF(SET(JJ))THEN
                   css%Stacka(SP,JJ)=ConstVal(css%ByteCode(IP)-css%VarEnd)
                END IF
             END DO
          end if
       END SELECT
       if(parse_bdeb)then
          if (sp.ne.0) then
             write(str250,'(100(X,F0.2))') &
                  & (css%Stacka(II,1),II=1,min(SP,10))
          else
             STR250=""
          end if
          call chop0(str250,250)
          lens=length(str250,250,10)
          write(*,'(X,A,5X,A,2(X,I0))') myname,&
               & "STACK=["//str250(1:LENS)//"]",AP,nargs
       end if
    END DO
    if(parse_bdeb)write(*,*)myname,'Loop done.',npos,allocated(set)
    EvalErrType = 0
    DO JJ=1,NPOS
       IF(SET(JJ))THEN
          if(parse_bdeb)write(*,'(X,A,X,A,I0,A,F0.10)') myname," result(",jj,")=",css%Stacka(1,JJ)
          res(JJ) = css%Stacka(1,JJ)
       END IF
    END DO
    if(parse_bdeb)write(*,*)myname,"Done."
    return
  END subroutine parse_evala
  !
  subroutine parse_used (css, set)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Evaluate bytecode of ith function for the values passed in array Val(:)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    type(parse_session), pointer :: css
    logical                      :: Set(:)  ! is variable used?
    INTEGER                      :: IP       ! Instruction pointer
    character*22 :: myname ="parse_used"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    if(parse_bdeb)write(*,*)myname,"Entering"
    DO IP=1,css%ByteCodeSize
       if (css%ByteCode(IP).ge.VarBegin.and.css%ByteCode(IP).le.css%VarEnd)then
          set(css%ByteCode(IP)-VarBegin+1)=.true.
       end if
    END DO
    if(parse_bdeb)write(*,*)myname,"Done."
  END subroutine parse_used
  !
  SUBROUTINE parse_CheckSyntax (Func,FuncStr,Var,crc250,irc)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Check syntax of function string,  returns 0 if syntax is ok
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*),               INTENT(in) :: Func      ! Function string without spaces
    CHARACTER (LEN=*),               INTENT(in) :: FuncStr   ! Original function string
    CHARACTER (LEN=*), allocatable, INTENT(in) :: Var(:)       ! Array with variable names
    character*250 :: crc250
    integer :: irc
    INTEGER(is)                                 :: n
    CHARACTER (LEN=1)                           :: c
    REAL(rn)                                    :: r
    LOGICAL                                     :: err
    INTEGER                                     :: ParCnt, & ! Parenthesis counter
         j,ib,in,lFunc
    character*22 :: myname ="parse_checkSyntax"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    if(parse_bdeb)write(*,*)myname,'Entering.',irc
    j = 1
    ParCnt = 0
    lFunc = LEN_TRIM(Func)
    step: DO
       IF (j > lFunc) then
          CALL parse_ParseErrMsg (j, FuncStr,"",crc250,irc)
          return
       end if
       c = Func(j:j)
       !-- -------- --------- --------- --------- --------- --------- --------- -------
       ! Check for valid operand (must appear)
       !-- -------- --------- --------- --------- --------- --------- --------- -------
       IF (c == '-' .OR. c == '+') THEN                      ! Check for leading - or +
          j = j+1
          IF (j > lFunc) then
             CALL parse_ParseErrMsg (j, FuncStr, 'Missing operand',crc250,irc)
             return
          end IF
          c = Func(j:j)
          IF (ANY(c == Ops)) then
             CALL parse_ParseErrMsg (j, FuncStr, 'Multiple operators',crc250,irc)
             return
          end IF
       END IF
       n = parse_MathFunctionIndex (Func(j:))
       IF (n > 0) THEN                                       ! Check for math function
          j = j+LEN_TRIM(Funcs(n))
          IF (j > lFunc) then
             CALL parse_ParseErrMsg (j, FuncStr, 'Missing function argument',crc250,irc)
             return
          end IF
          c = Func(j:j)
          IF (c /= '(') then
             CALL parse_ParseErrMsg (j, FuncStr, 'Missing opening parenthesis',crc250,irc)
             return
          end IF
       END IF
       IF (c == '(') THEN                                    ! Check for opening parenthesis
          ParCnt = ParCnt+1
          j = j+1
          CYCLE step
       END IF
       IF (SCAN(c,'0123456789.') > 0) THEN                   ! Check for number
          r = parse_RealNum (Func(j:),ib,in,err)
          IF (err) then
             CALL parse_ParseErrMsg (j, FuncStr, 'Invalid number format:  '//Func(j+ib-1:j+in-2),crc250,irc)
             return
          end IF
          j = j+in-1
          IF (j > lFunc) EXIT
          c = Func(j:j)
       ELSE                                                  ! Check for variable
          if(parse_bdeb)write(*,*)myname,'Checking variables.'
          if (allocated(var)) then
             n = parse_VariableIndex (Func(j:),Var,ib,in)
          else
             n=0
          end if
          IF (n == 0) then
             if(parse_bdeb)write(*,*)myname,'Checking constants.'
             n = parse_VariableIndex (Func(j:),const,ib,in)
             if (n==0) then
                CALL parse_ParseErrMsg (j, FuncStr, 'Invalid element: '//Func(j+ib-1:j+in-2),crc250,irc)
                return
             else 
                j = j+in-1
                IF (j > lFunc) EXIT
                c = Func(j:j)
             end if
          else
             j = j+in-1
             IF (j > lFunc) EXIT
             c = Func(j:j)
          end if
          if(parse_bdeb)write(*,*)myname,'Var/Const:',n
       END IF
       DO WHILE (c == ')')                                   ! Check for closing parenthesis
          ParCnt = ParCnt-1
          IF (ParCnt < 0) then
             CALL parse_ParseErrMsg (j, FuncStr, 'Mismatched parenthesis',crc250,irc)
             return
          end IF
          IF (Func(j-1:j-1) == '(') then
             CALL parse_ParseErrMsg (j-1, FuncStr, 'Empty parentheses',crc250,irc)
             return
          end if
          j = j+1
          IF (j > lFunc) EXIT
          c = Func(j:j)
       END DO
       !-- -------- --------- --------- --------- --------- --------- --------- -------
       ! Now, we have a legal operand: A legal operator or end of string must follow
       !-- -------- --------- --------- --------- --------- --------- --------- -------
       IF (j > lFunc) EXIT
       IF (ANY(c == Ops)) THEN                               ! Check for multiple operators
          IF (j+1 > lFunc) then
             CALL parse_ParseErrMsg (j, FuncStr,"",crc250,irc)
             return
          end if
          IF (ANY(Func(j+1:j+1) == Ops)) then
             CALL parse_ParseErrMsg (j+1, FuncStr, 'Multiple operators',crc250,irc)
             return
          end if
       ELSE IF (c == ",") THEN
       ELSE ! Check for next operand
          CALL parse_ParseErrMsg (j, FuncStr, 'Missing operator',crc250,irc)
          return
       END IF
       !-- -------- --------- --------- --------- --------- --------- --------- -------
       ! Now, we have an operand and an operator: the next loop will check for another 
       ! operand (must appear)
       !-- -------- --------- --------- --------- --------- --------- --------- -------
       j = j+1
    END DO step
    IF (ParCnt > 0) then
       CALL parse_ParseErrMsg (j, FuncStr, 'Missing )',crc250,irc)
       return
    end if
    if(parse_bdeb)write(*,*)myname,'Done checking.',irc
  END SUBROUTINE parse_CheckSyntax
  !
  FUNCTION parse_EvalErrMsg () RESULT (msg)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Return error message
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*), DIMENSION(5), PARAMETER :: m = (/ 'Division by zero                ', &
         'Argument of SQRT negative       ', &
         'Argument of LOG negative        ', &
         'Argument of ASIN or ACOS illegal', &
         'Unexpected number of arguments  ' /)
    CHARACTER (LEN=LEN(m))                     :: msg
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IF (EvalErrType < 1 .OR. EvalErrType > SIZE(m)) THEN
       msg = ''
    ELSE
       msg = m(EvalErrType)
    ENDIF
  END FUNCTION parse_EvalErrMsg
  !
  SUBROUTINE parse_ParseErrMsg (j, FuncStr, Msg, crc250,irc)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Print error message and terminate program
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    INTEGER,                     INTENT(in) :: j
    CHARACTER (LEN=*),           INTENT(in) :: FuncStr       ! Original function string
    CHARACTER (LEN=*),           INTENT(in) :: Msg
    character*250 :: crc250
    integer :: irc
    character*25 :: myname = "fparse"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    call parse_errorappend(crc250,myname//" "//Msg//" in string '"//&
         & FuncStr//"' [pos=")
    call parse_errorappendi(crc250,j)
    call parse_errorappend(crc250,"]\n")
    irc=323
    return
  END SUBROUTINE parse_ParseErrMsg
  !
  FUNCTION parse_OperatorIndex (c) RESULT (n)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Return operator index
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=1), INTENT(in) :: c
    INTEGER(is)                   :: n,j
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    n = 0
    DO j=cAdd,cPow
       IF (c == Ops(j)) THEN
          n = j
          EXIT
       END IF
    END DO
  END FUNCTION parse_OperatorIndex
  !
  FUNCTION parse_MathFunctionIndex (str) RESULT (n)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Return index of math function beginnig at 1st position of string str
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*), INTENT(in) :: str
    INTEGER(is)                   :: n,j
    INTEGER                       :: k
    CHARACTER (LEN=LEN(Funcs))    :: fun
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    n = 0
    DO j=cAbs,cAtan                                          ! Check all math functions
       k = MIN(LEN_TRIM(Funcs(j)), LEN(str))   
       CALL parse_LowCase (str(1:k), fun)
       IF (fun == Funcs(j)) THEN                             ! Compare lower case letters
          n = j                                              ! Found a matching function
          EXIT
       END IF
    END DO
  END FUNCTION parse_MathFunctionIndex
  !
  FUNCTION parse_VariableIndex (str, Var, ibegin, inext) RESULT (n)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Return index of variable at begin of string str (returns 0 if no variable found)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*),               INTENT(in) :: str       ! String
    CHARACTER (LEN=*), allocatable, INTENT(in) :: Var(:)       ! Array with variable names
    INTEGER(is)                                 :: n         ! Index of variable
    INTEGER, OPTIONAL,              INTENT(out) :: ibegin, & ! Start position of variable name
         inext     ! Position of character after name
    INTEGER                                     :: j,ib,in,lstr
    character*25 :: myname = "parse_VariableIndex"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    n = 0
    if(parse_bdeb)write(*,*)myname,"Entering: '"//trim(str)//"'",ibegin,lbound(var,1),ubound(var,1)
    lstr = LEN_TRIM(str)
    IF (lstr > 0) THEN
       DO ib=1,lstr                                          ! Search for first character in str
          IF (str(ib:ib) /= ' ') EXIT                        ! When lstr>0 at least 1 char in str
       END DO
       DO in=ib,lstr                                         ! Search for name terminators
          IF (SCAN(str(in:in),'+-*/^) ,') > 0) EXIT
       END DO
       if (allocated(var)) then
          DO j=lbound(var,1),ubound(Var,1)
             IF (str(ib:in-1) .eq. trim(Var(j))) THEN                     
                n = j                                           ! Variable name found
                IF (PARSE_BDEB) THEN
                   write(*,*) myname,"** MATCH: '"//str(ib:in-1)//"' == '"//trim(Var(j))//"'"
                end if
                EXIT
                !          ELSE IF (PARSE_BDEB) THEN
                !             write(*,*) myname,"no match: '"//str(ib:in-1)//"' != '"//trim(Var(j))//"'",&
                !                  & in-ib,len_trim(var(j))
             END IF
          END DO
       end if
    END IF
    IF (PRESENT(ibegin)) ibegin = ib
    IF (PRESENT(inext))  inext  = in
    if (n.eq.0.and.parse_bdeb)write(*,*) myname,"No match for '"//str(ib:in-1)//"'"
    if(parse_bdeb)write(*,*)myname,"Done.",ib,in
  END FUNCTION parse_VariableIndex
  !
  SUBROUTINE RemoveSpaces (str)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Remove Spaces from string, remember positions of characters in old string
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*), INTENT(inout) :: str
    INTEGER                          :: lstr,ii,jj
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    lstr = LEN(str)
    ii=0
    do jj=1,lstr
       if (str(jj:jj).ne." ".and.ichar(str(jj:jj)).ge.32) then ! ascii characters >= 32
          ii=ii+1
          str(ii:ii)=str(jj:jj)
       end if
    end do
    do jj=ii+1,lstr
       str(jj:jj)=' '
    end do
    !do jj=1,lstr
    !   write(*,*)'parse_removespaces ',jj,"'"//str(jj:jj)//"'",ichar(str(jj:jj))
    !end do
  END SUBROUTINE RemoveSpaces
  !
  SUBROUTINE Replace (ca,cb,str)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Replace ALL appearances of character set ca in string str by character set cb
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*),       INTENT(in) :: ca
    CHARACTER (LEN=LEN(ca)), INTENT(in) :: cb                ! LEN(ca) must be LEN(cb)
    CHARACTER (LEN=*),    INTENT(inout) :: str
    INTEGER                             :: j,lca
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    lca = LEN(ca)
    DO j=1,LEN_TRIM(str)-lca+1
       IF (str(j:j+lca-1) == ca) str(j:j+lca-1) = cb
    END DO
  END SUBROUTINE Replace
  !
  SUBROUTINE Parse_compile (css, F, Var, crc250,irc)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Compile i-th function string F into bytecode
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    type(parse_session), pointer :: css
    CHARACTER (LEN=*),               INTENT(in) :: F         ! Function string
    CHARACTER (LEN=*), allocatable, INTENT(in) :: Var(:)       ! Array with variable names
    character*250 :: crc250
    integer :: irc
    INTEGER                                     :: istat
    character*25 :: myname = "parse_compile"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IF (ASSOCIATED(css%ByteCode)) DEALLOCATE ( css%ByteCode, &
         css%Immed,    &
         css%Stack,    &
         css%ArgsByte     )
    css%ByteCodeSize = 0
    css%ImmedSize    = 0
    css%StackSize    = 0
    css%StackPtr     = 0
    css%ArgsSize     = 0
    css%ArgsPtr     = 0
    if (parse_bdeb) write(*,*)myname,"Compiling '"//F(1:LEN_TRIM(F))//"'"
    CALL parse_CompileSubstr (css,F,1,LEN_TRIM(F),Var,.false.)               ! Compile string to determine size
    if(parse_bdeb) write(*,*)myname,'>>>>> Arg size:',css%ArgsSize,css%ArgsPtr
    ALLOCATE ( css%ByteCode(css%ByteCodeSize), & 
         css%Immed(css%ImmedSize),       &
         css%Stack(css%StackSize),       &
         css%ArgsByte(css%ArgsSize+1),    &
         STAT = istat                            )
    IF (istat /= 0) THEN
       call parse_errorappend(crc250,myname//" Memmory allocation for byte code failed.\n")
       irc=324
       return
    ELSE
       css%ByteCodeSize = 0
       css%ImmedSize    = 0
       css%StackSize    = 0
       css%StackPtr     = 0
       css%ArgsSize     = 0
       css%ArgsPtr     = 0
       css%argsByte(css%ArgsSize+1)=0 ! dummy value...
       CALL parse_CompileSubstr (css,F,1,LEN_TRIM(F),Var,.false.)            ! Compile string into bytecode
    END IF
    !
  END SUBROUTINE Parse_compile
  !
  SUBROUTINE parse_AddCompiledByte (css, b)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Add compiled byte to bytecode
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    type(parse_session), pointer :: css
    INTEGER(is), INTENT(in) :: b                             ! Value of byte to be added
    character*22 :: myname ="parse_AddCompiledByte"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    css%ByteCodeSize = css%ByteCodeSize + 1
    IF (ASSOCIATED(css%ByteCode)) css%ByteCode(css%ByteCodeSize) = b
    if (parse_bdeb)write(*,'(X,A,"Cmd(",I0,") -> ",A)')myname,css%ByteCodeSize,parse_code20(b,0)
  END SUBROUTINE parse_AddCompiledByte
  !
  FUNCTION parse_MathItemIndex (css, F, Var) RESULT (n)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Return math item index, if item is real number, enter it into Comp-structure
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    type(parse_session), pointer :: css
    CHARACTER (LEN=*),               INTENT(in) :: F         ! Function substring
    CHARACTER (LEN=*), allocatable, INTENT(in) :: Var(:)       ! Array with variable names
    INTEGER(is)                                 :: n         ! Byte value of math item
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    n = 0
    if (len_trim(f).eq.0)return
    IF (SCAN(F(1:1),'0123456789.') > 0) THEN                 ! Check for begin of a number
       css%ImmedSize = css%ImmedSize + 1
       IF (ASSOCIATED(css%Immed)) css%Immed(css%ImmedSize) = parse_RealNum (F)
       n = cImmed
    ELSE                                                     ! Check for a variable
       n = parse_VariableIndex (F, Var)
       IF (n > 0) then
          n = VarBegin+n-1
       else
          n = parse_VariableIndex (F, Const)
          IF (n > 0) then
             n = css%VarEnd+n
          end if
       end if
    END IF
  END FUNCTION parse_MathItemIndex
  !
  FUNCTION parse_CompletelyEnclosed (F, b, e) RESULT (res)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Check if function substring F(b:e) is completely enclosed by a pair of parenthesis
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*), INTENT(in) :: F                       ! Function substring
    INTEGER,           INTENT(in) :: b,e                     ! First and last pos. of substring
    LOGICAL                       :: res
    INTEGER                       :: j,k
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    res=.false.
    IF (F(b:b) == '(' .AND. F(e:e) == ')') THEN
       k = 0
       DO j=b+1,e-1
          IF     (F(j:j) == '(') THEN
             k = k+1
          ELSEIF (F(j:j) == ')') THEN
             k = k-1
          END IF
          IF (k < 0) EXIT
       END DO
       IF (k == 0) res=.true.                                ! All opened parenthesis closed
    END IF
  END FUNCTION parse_CompletelyEnclosed
  !
  RECURSIVE SUBROUTINE parse_CompileSubstr (css, F, b, e, Var, comma)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Compile css function string F into bytecode
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    type(parse_session), pointer :: css
    CHARACTER (LEN=*),               INTENT(in) :: F         ! Function substring
    INTEGER,                         INTENT(in) :: b,e       ! Begin and end position substring
    CHARACTER (LEN=*), allocatable, INTENT(in)  :: Var(:)       ! Array with variable names
    logical, INTENT(in)                         :: comma
    INTEGER(is)                                 :: n
    INTEGER                                     :: b2,j,k,io
    CHARACTER (LEN=*),                PARAMETER :: calpha = 'abcdefghijklmnopqrstuvwxyz'// &
         'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    integer :: iArgsPtr
    integer :: nargs
    character*22 :: myname ="parse_compileSustr"
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Check for special cases of substring
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    nargs=0
    if (parse_bdeb) write(*,*) myname,'** Processing:',F(b:e)
    if (b.gt.e) return ! nothing to do
    IF (parse_CompletelyEnclosed (F, b, e)) THEN               ! Case 2: F(b:e) = '(...)'
       if (parse_bdeb) WRITE(*,*)myname,'2. F(b:e) = "(...)"',F(b:e)
       CALL parse_CompileSubstr (css, F, b+1, e-1, Var,.true.)
       RETURN
    ELSEIF (SCAN(F(b:b),calpha) > 0) THEN        
       if (parse_bdeb) WRITE(*,*)myname,'3. Found Alphanumeric: ',F(b:e),allocated(var)
       n = parse_MathFunctionIndex (F(b:e))
       IF (n > 0) THEN
          b2 = b+INDEX(F(b:e),'(')-1
          IF (parse_CompletelyEnclosed(F, b2, e)) THEN             ! Case 3: F(b:e) = 'fcn(...)'
             if (parse_bdeb) WRITE(*,*)myname,'3. F(b:e) = "fcn(...)" ',F(b2+1:e-1)
             iArgsPtr=css%ArgsPtr ! current argument pointer
             CALL parse_CompileSubstr(css, F, b2+1, e-1, Var,.true.)
             css%ArgsSize=css%ArgsSize+1 ! increase function counter
             nargs=css%ArgsPtr-iArgsPtr+1 ! (number of commas) + 1
             css%ArgsPtr=iArgsPtr
             if (parse_bdeb) WRITE(*,'(X,A,X,A,I0,A,A)')myname,&
                  & '3. Number of arguments= ',nargs," '"//F(b2+1:e-1)//"'"
             IF (ASSOCIATED(css%ArgsByte))then
                css%ArgsByte(css%ArgsSize)=nargs ! number of arguments
                if (parse_bdeb)write(*,'(X,A,X,A,I0,A,I0)')myname,&
                     & 'Argsbyte(',css%ArgsSize,')=',css%ArgsByte(css%ArgsSize)
             end if
             CALL parse_AddCompiledByte (css, n)
             RETURN
          END IF
       END IF
    END IF
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Check for commas in argument lists
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    if (comma) then
       k = 0
       DO j=e,b,-1
          IF     (F(j:j) == ')') THEN
             k = k+1
          ELSEIF (F(j:j) == '(') THEN
             k = k-1
          END IF
          IF (k == 0 .AND. F(j:j) == ",") THEN
             if (parse_bdeb) WRITE(*,*)myname,'3. Found comma: ', F(j:j)
             CALL parse_CompileSubstr (css, F, b, j-1, Var,comma)
             CALL parse_CompileSubstr (css, F, j+1, e, Var,comma)
             css%ArgsPtr=css%ArgsPtr+1 ! increase function counter
             RETURN
          END IF
       END DO
    end if
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Check for signs
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IF (F(b:b) == '+') THEN                              ! Case 1: F(b:e) = '+...'
       if (parse_bdeb) WRITE(*,*)myname,'1. F(b:e) = "+..."'
       CALL parse_CompileSubstr (css, F, b+1, e, Var,comma)
       RETURN
    ELSEIF (F(b:b) == '-') THEN
       if (parse_bdeb) WRITE(*,*)myname,'3. Found Minus'
       CALL parse_CompileSubstr (css, F, b+1, e, Var,comma)
       CALL parse_AddCompiledByte (css, cNeg)
       RETURN
    END IF
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Check for operator in substring: check only base level (k=0), exclude expr. in ()
    !----- -------- --------- --------- --------- --------- --------- --------- -------    
    DO io=cAdd,cPow                                          ! Increasing priority +-*/^
       k = 0
       DO j=e,b,-1
          IF     (F(j:j) == ')') THEN
             k = k+1
          ELSEIF (F(j:j) == '(') THEN
             k = k-1
          END IF
          IF (k == 0 .AND. F(j:j) == Ops(io) .AND. parse_IsBinaryOp (j, F)) THEN
             if (parse_bdeb) WRITE(*,*)myname,'3. Found Binary op at: ',j,'('//F(j:j)//')'
             IF (ANY(F(j:j) == Ops(cMul:cPow)) .AND. F(b:b) == '-') THEN ! Case 6: F(b:e) = '-...Op...' with Op > -
                if (parse_bdeb) WRITE(*,*)myname,'6. F(b:e) = "-...Op..." with Op > -'
                CALL parse_CompileSubstr (css, F, b+1, e, Var,comma)
                CALL parse_AddCompiledByte (css, cNeg)
                RETURN                 
             ELSE                                                        ! Case 7: F(b:e) = '...BinOp...'
                if (parse_bdeb) WRITE(*,*)myname,'7. Binary operator ',F(j:j),b,j,e
                CALL parse_CompileSubstr (css, F, b, j-1, Var,comma)
                CALL parse_CompileSubstr (css, F, j+1, e, Var,comma)
                CALL parse_AddCompiledByte (css, parse_OperatorIndex(Ops(io)))
                css%StackPtr = css%StackPtr - 1
                RETURN
             END IF
          END IF
       END DO
    END DO
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Check for remaining items, i.e. variables or explicit numbers
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    b2 = b
    IF (F(b:b) == '-') b2 = b2+1
    n = parse_MathItemIndex(css, F(b2:e), Var)
    if (parse_bdeb) WRITE(*,*)myname,'8. parse_AddCompiledByte ',parse_code20(n,0)," = '"//F(b2:e)//"'",&
         & css%StackPtr
    CALL parse_AddCompiledByte (css, n)
    css%StackPtr = css%StackPtr + 1
    IF (css%StackPtr > css%StackSize) css%StackSize = css%StackSize + 1
    IF (b2 > b) CALL parse_AddCompiledByte (css, cNeg)
  END SUBROUTINE parse_CompileSubstr
  !
  FUNCTION parse_IsBinaryOp (j, F) RESULT (res)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Check if operator F(j:j) in string F is binary operator
    ! Special cases already covered elsewhere:              (that is corrected in v1.1)
    ! - operator character F(j:j) is first character of string (j=1)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    INTEGER,           INTENT(in) :: j                       ! Position of Operator
    CHARACTER (LEN=*), INTENT(in) :: F                       ! String
    LOGICAL                       :: res                     ! Result
    INTEGER                       :: k
    LOGICAL                       :: Dflag,Pflag
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    res=.true.
    IF (F(j:j) == '+' .OR. F(j:j) == '-') THEN               ! Plus or minus sign:
       IF (j == 1) THEN                                      ! - leading unary operator ?
          res = .false.
       ELSEIF (SCAN(F(j-1:j-1),'+-*/^(') > 0) THEN           ! - other unary operator ?
          res = .false.
       ELSEIF (SCAN(F(j+1:j+1),'0123456789') > 0 .AND. &     ! - in exponent of real number ?
            SCAN(F(j-1:j-1),'eEdD')       > 0) THEN
          Dflag=.false.
          Pflag=.false.
          k = j-1
          DO WHILE (k > 1)                                   !   step to the left in mantissa 
             k = k-1
             IF     (SCAN(F(k:k),'0123456789') > 0) THEN
                Dflag=.true.
             ELSEIF (F(k:k) == '.') THEN
                IF (Pflag) THEN
                   EXIT                                      !   * EXIT: 2nd appearance of '.'
                ELSE
                   Pflag=.true.                              !   * mark 1st appearance of '.'
                ENDIF
             ELSE
                EXIT                                         !   * all other characters
             END IF
          END DO
          IF (Dflag .AND. (k == 1 .OR. SCAN(F(k:k),'+-*/^(') > 0)) res = .false.
       END IF
    END IF
  END FUNCTION parse_IsBinaryOp
  !
  FUNCTION parse_RealNum (str, ibegin, inext, error) RESULT (res)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Get real number from string - Format: [blanks][+|-][nnn][.nnn][e|E|d|D[+|-]nnn]
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*),  INTENT(in) :: str                    ! String
    REAL(rn)                       :: res                    ! Real number
    INTEGER, OPTIONAL, INTENT(out) :: ibegin,              & ! Start position of real number
         inext                  ! 1st character after real number
    LOGICAL, OPTIONAL, INTENT(out) :: error                  ! Error flag
    INTEGER                        :: ib,in,istat
    LOGICAL                        :: Bflag,               & ! .T. at begin of number in str
         InMan,               & ! .T. in mantissa of number
         Pflag,               & ! .T. after 1st '.' encountered
         Eflag,               & ! .T. at exponent identifier 'eEdD'
         InExp,               & ! .T. in exponent of number
         DInMan,              & ! .T. if at least 1 digit in mant.
         DInExp,              & ! .T. if at least 1 digit in exp.
         err                    ! Local error flag
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    Bflag=.true.
    InMan=.false.
    Pflag=.false.
    Eflag=.false.
    InExp=.false.
    DInMan=.false.
    DInExp=.false.
    ib   = 1
    in   = 1
    DO WHILE (in <= LEN_TRIM(str))
       SELECT CASE (str(in:in))
       CASE (' ')                                            ! Only leading blanks permitted
          ib = ib+1
          IF (InMan .OR. Eflag .OR. InExp) EXIT
       CASE ('+','-')                                        ! Permitted only
          IF     (Bflag) THEN           
             InMan=.true.
             Bflag=.false.                     ! - at beginning of mantissa
          ELSEIF (Eflag) THEN               
             InExp=.true.
             Eflag=.false.                     ! - at beginning of exponent
          ELSE
             EXIT                                            ! - otherwise STOP
          ENDIF
       CASE ('0':'9')                                        ! Mark
          IF     (Bflag) THEN           
             InMan=.true.
             Bflag=.false.                     ! - beginning of mantissa
          ELSEIF (Eflag) THEN               
             InExp=.true.
             Eflag=.false.                     ! - beginning of exponent
          ENDIF
          IF (InMan) DInMan=.true.                           ! Mantissa contains digit
          IF (InExp) DInExp=.true.                           ! Exponent contains digit
       CASE ('.')
          IF     (Bflag) THEN
             Pflag=.true.                                    ! - mark 1st appearance of '.'
             InMan=.true.
             Bflag=.false.                     !   mark beginning of mantissa
          ELSEIF (InMan .AND..NOT.Pflag) THEN
             Pflag=.true.                                    ! - mark 1st appearance of '.'
          ELSE
             EXIT                                            ! - otherwise STOP
          END IF
       CASE ('e','E','d','D')                                ! Permitted only
          IF (InMan) THEN
             Eflag=.true.
             InMan=.false.                     ! - following mantissa
          ELSE
             EXIT                                            ! - otherwise STOP
          ENDIF
       CASE DEFAULT
          EXIT                                               ! STOP at all other characters
       END SELECT
       in = in+1
    END DO
    err = (ib > in-1) .OR. (.NOT.DInMan) .OR. ((Eflag.OR.InExp).AND..NOT.DInExp)
    IF (err) THEN
       res = 0.0_rn
    ELSE
       READ(str(ib:in-1),*,IOSTAT=istat) res
       err = istat /= 0
    END IF
    IF (PRESENT(ibegin)) ibegin = ib
    IF (PRESENT(inext))  inext  = in
    IF (PRESENT(error))  error  = err
  END FUNCTION parse_RealNum
  !  
  SUBROUTINE parse_LowCase (str1, str2)
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    ! Transform upper case letters in str1 into lower case letters, result is str2
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    IMPLICIT NONE
    CHARACTER (LEN=*),  INTENT(in) :: str1
    CHARACTER (LEN=*), INTENT(out) :: str2
    INTEGER                        :: j,k
    CHARACTER (LEN=*),   PARAMETER :: lc = 'abcdefghijklmnopqrstuvwxyz'
    CHARACTER (LEN=*),   PARAMETER :: uc = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    !----- -------- --------- --------- --------- --------- --------- --------- -------
    str2 = str1
    DO j=1,LEN_TRIM(str1)
       k = INDEX(uc,str1(j:j))
       IF (k > 0) str2(j:j) = lc(k:k)
    END DO
  END SUBROUTINE parse_LowCase
  !
  real(rn) function parse_f1970(yy,mm,dd,hh,mi,sec)
    implicit none
    real(rn)  :: yy,mm,dd,hh,mi,sec
    !     returns "seconds since 1970-01-01 00:00:00 +00:00"
    real(rn) days
    !     yy=1970
    !     mm=01
    !     dd=01
    !     mi=00
    !     sec=0.0D0
    !     call date2jd2000(days,yy,mm,dd,hh,mi,sec)
    !     write(*,*) 'S1970 1970-reference in J2000:',days!  2440587.5
    call date2jd(days,nint(yy),nint(mm),nint(dd),nint(hh),nint(mi),sec) ! get days since 2000/1/1 0:0
    days = days - 2440587.5  ! convert to days since reference
    parse_f1970=days*86400.0D0      ! convert to seconds
    return
  end function parse_f1970
  !
  real(rn) function parse_f1970_yy(secs)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "seconds since 1970-01-01 00:00:00 +00:00"
    real(rn) days,sec,secs
    !     yy=1970
    !     mm=01
    !     dd=01
    !     mi=00
    !     sec=0.0D0
    !     call date2jd2000(days,yy,mm,dd,hh,mi,sec)
    !     write(*,*) 'S1970 1970-reference in J2000:',days!  2440587.5
    days=secs/86400.0D0+2440587.5
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_f1970_yy=yy      ! convert to seconds
    return
  end function parse_f1970_yy
  !
  real(rn) function parse_f1970_mm(secs)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "seconds since 1970-01-01 00:00:00 +00:00"
    real(rn) days,sec,secs
    !     yy=1970
    !     mm=01
    !     dd=01
    !     mi=00
    !     sec=0.0D0
    !     call date2jd2000(days,yy,mm,dd,hh,mi,sec)
    !     write(*,*) 'S1970 1970-reference in J2000:',days!  2440587.5
    days=secs/86400.0D0+2440587.5
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_f1970_mm=mm      ! convert to seconds
    return
  end function parse_f1970_mm
  !
  real(rn) function parse_f1970_dd(secs)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "seconds since 1970-01-01 00:00:00 +00:00"
    real(rn) days,sec,secs
    !     yy=1970
    !     mm=01
    !     dd=01
    !     mi=00
    !     sec=0.0D0
    !     call date2jd2000(days,yy,mm,dd,hh,mi,sec)
    !     write(*,*) 'S1970 1970-reference in J2000:',days!  2440587.5
    days=secs/86400.0D0+2440587.5
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_f1970_dd=dd      ! convert to seconds
    return
  end function parse_f1970_dd
  !
  real(rn) function parse_f1970_hh(secs)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "seconds since 1970-01-01 00:00:00 +00:00"
    real(rn) days,sec,secs
    !     yy=1970
    !     mm=01
    !     dd=01
    !     mi=00
    !     sec=0.0D0
    !     call date2jd2000(days,yy,mm,dd,hh,mi,sec)
    !     write(*,*) 'S1970 1970-reference in J2000:',days!  2440587.5
    days=secs/86400.0D0+2440587.5
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_f1970_hh=hh      ! convert to seconds
    return
  end function parse_f1970_hh
  !
  real(rn) function parse_f1970_mi(secs)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "seconds since 1970-01-01 00:00:00 +00:00"
    real(rn) days,sec,secs
    !     yy=1970
    !     mm=01
    !     dd=01
    !     mi=00
    !     sec=0.0D0
    !     call date2jd2000(days,yy,mm,dd,hh,mi,sec)
    !     write(*,*) 'S1970 1970-reference in J2000:',days!  2440587.5
    days=secs/86400.0D0+2440587.5
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_f1970_mi=mi      ! convert to seconds
    return
  end function parse_f1970_mi
  !
  real(rn) function parse_fjulian(yy,mm,dd,hh,mi,sec)
    implicit none
    real(rn)  :: yy,mm,dd,hh,mi
    !     returns "julian days since 2000
    real(rn) days,sec
    call date2jd(days,nint(yy),nint(mm),nint(dd),nint(hh),nint(mi),sec) ! get days since 2000/1/1 0:0
    parse_fjulian=days
    return
  end function parse_fjulian
  !
  real(rn) function parse_fjulian_yy(days)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "julian days since 2000
    real(rn) days,sec
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_fjulian_yy=yy
    return
  end function parse_fjulian_yy
  !
  real(rn) function parse_fjulian_mm(days)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "julian days since 2000
    real(rn) days,sec
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_fjulian_mm=real(mm)
    return
  end function parse_fjulian_mm
  !
  real(rn) function parse_fjulian_dd(days)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "julian days since 2000
    real(rn) days,sec
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_fjulian_dd=real(dd)
    return
  end function parse_fjulian_dd
  !
  real(rn) function parse_fjulian_hh(days)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "julian days since 2000
    real(rn) days,sec
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_fjulian_hh=real(hh)
    return
  end function parse_fjulian_hh
  !
  real(rn) function parse_fjulian_mi(days)
    implicit none
    integer  :: yy,mm,dd,hh,mi
    !     returns "julian days since 2000
    real(rn) days,sec
    call jd2date(days,yy,mm,dd,hh,mi,sec) ! get days since 2000/1/1 0:0
    parse_fjulian_mi=real(mi)
    return
  end function parse_fjulian_mi
  !
  subroutine DATE2JD (JD, YEAR,MONTH,DAY,HOUR,MINUTES,SECONDS)
    !     (corresponds to JD2000)
    !     Computes julian day from gregorian (civil) calendar
    !     O  (REAL*8) JD = JULIAN. DAY
    !     I  (INT*4) YY = YEAR
    !     I  (INT*4) MM = MONTH
    !     I  (INT*4) DD = DAY
    !     I  (INT*4) HH = HOUR
    !     I  (INT*4) MI = MINUTE
    !     I  (REAL*8) SEC = SECOND.
    implicit none
    REAL(rn) JD
    INTEGER(is) YEAR,MONTH,DAY,HOUR,MINUTES,I,J,K
    REAL(rn) SECONDS
    I= YEAR
    J= MONTH
    K= DAY
    JD= K-32075+1461*(I+4800+(J-14)/12)/4+367*(J-2-(J-14)/12*12) &
         /12-3*((I+4900+(J-14)/12)/100)/4
    JD=JD+((HOUR-12.0D0)/24.0D0)+(MINUTES/1440.0D0)+(SECONDS/86400.0D0)
    RETURN
  END subroutine DATE2JD
  SUBROUTINE JD2DATE (JD, YEAR,MONTH,DAY,HOUR,MINUTES,SECONDS)
    !     (corresponds to DJ2000)
    !     Computes gregorian (civil) calendar from julian day
    !     I  (REAL*8) JD = JULIAN. DAY
    !     O  (INT*4) YY = YEAR
    !     O  (INT*4) MM = MONTH
    !     O  (INT*4) DD = DAY
    !     O  (INT*4) HH = HOUR
    !     O  (INT*4) MI = MINUTE
    !     O  (REAL*8) SEC = SECOND.
    !
    implicit none
    REAL*8 JD
    INTEGER YEAR,MONTH,DAY,HOUR,MINUTES
    REAL*8 SECONDS
    REAL*8 DJ
    INTEGER*8 I,J,K,L,N,IJ
    IJ= INT(JD+0.5D0)
    DJ=(JD+0.5D0)-real(ij)
    L= IJ+68569
    N= 4*L/146097
    L= L-(146097*N+3)/4
    I= 4000*(L+1)/1461001
    L= L-1461*I/4+31
    J= 80*L/2447
    K= L-2447*J/80
    L= J/11
    J= J+2-12*L
    I= 100*(N-49)+I+L
    YEAR= INT(I)
    MONTH= INT(J)
    DAY= INT(K)
    DJ=DJ*86400.0D0 ! seconds
    HOUR=int(DJ/3600.0D0)
    Dj=DJ-HOUR*3600.0D0
    MINUTES=INT(DJ/60.0D0)
    Dj=DJ-MINUTES*60.0D0
    SECONDS=DJ
    RETURN
  END SUBROUTINE JD2DATE
  !
  ! E R R O R    R O U T I N E S
  !
  subroutine parse_errorappend(crc250,string)
    implicit none
    character*250 :: crc250
    character*(*) :: string
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    character*22 :: myname ="parse_errorappend"
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    lenb=len(trim(string))
    buff250=string(1:lenb)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//""//buff250(1:min(250-lenc-1,lenb))
    end if
    if (parse_bdeb)write(*,*)myname,buff250(1:lenb)
    call chop0(crc250,250)
    return
  end subroutine parse_errorappend
  subroutine parse_errorappendi(crc250,inum)
    implicit none
    character*250 :: crc250
    integer :: inum
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    character*22 :: myname ="parse_errorappendi"
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    write(buff250,'(I12)')inum
    call chop0(buff250,250)
    lenb=length(buff250,250,1)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//""//buff250(1:min(250-lenc-1,lenb))
    end if
    if (parse_bdeb)write(*,*)myname,buff250(1:lenb)
    call chop0(crc250,250)
    return
  end subroutine parse_errorappendi
  subroutine parse_errorappendr(crc250,rnum)
    implicit none
    character*250 :: crc250
    real(rn) :: rnum
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    character*22 :: myname ="parse_errorappendi"
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    write(buff250,'(F0.2)')rnum
    call chop0(buff250,250)
    lenb=length(buff250,250,1)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//""//buff250(1:min(250-lenc-1,lenb))
    end if
    if (parse_bdeb)write(*,*)myname,buff250(1:lenb)
    call chop0(crc250,250)
    return
  end subroutine parse_errorappendr
  !
  character*20 function parse_code20(code,nargs)
    integer code,nargs,ii
    if (code.ge.cabs.and.code.le.catan) then
       if (nargs.eq.0) then
          parse_code20=funcs(code)
       else
          write(parse_code20,'(A,"(",I0,")")')trim(funcs(code)),nargs
       end if
    ELSE IF (code.eq.cImmed) THEN
       parse_code20="+stack=fix"
    ELSE IF (code.eq.cNeg) THEN
       parse_code20="neg"
    ELSE IF (code.eq.cAdd) THEN
       parse_code20="add"
    ELSE IF (code.eq.cSub) THEN
       parse_code20="sub"
    ELSE IF (code.eq.cMul) THEN
       parse_code20="mul"
    ELSE IF (code.eq.cDiv) THEN
       parse_code20="div"
    ELSE IF (code.eq.cPow) THEN
       parse_code20="pow"
    else
       ii=code-VarBegin+1
       write(parse_code20,'("+stack=",I0)')ii
    end if
    return
  end function parse_code20
  !
  ! CEOP Derived Parameter Equations
  ! http://www.eol.ucar.edu/projects/ceop/dm/documents/refdata_report/eqns.html
  
  ! Compute the Specific Humidity  from dew point temperature (Bolton 1980):

  real function td2q(td,p) ! td,p
    real :: td,p
    real :: e,q
    ! Vapour pressure in mb
    !    where:
    !       e = vapor pressure in mb;
    !       Td = dew point in deg C;
    !       p = surface pressure in mb;
    !       q = specific humidity in g/kg.
    e= 6.112*exp((17.67*td)/(td + 243.5))
    q= 1000*(0.622 * e)/(p - (0.378 * e))
    td2q=q
    return ! q
  end function td2q
  
  ! Compute Dew Point Temperature (Bolton 1980):
  
  real function rh2td(rh,t,rice) ! rh, t, ice=NULL
    real :: rh,t
    real, OPTIONAL :: rice
    logical :: ice
    real :: es,e,td
    !     where:
    !      rh - relative Humidity in percent;
    !       t - temperature in deg C
    ! Saturation vapor pressure in mb:
    if (present(rice)) then
       ice=rice.ge.0.5D0
    else
       ice=(t.le.0.0D0)
    end if
    es=satVapPres(t+273.15,ice)
    ! Vapor pressure in mb:
    e =es * rh/100.0
    ! Dew point in deg C
    td=log(e/6.112)*243.5/(17.67-log(e/6.112))
    rh2td=td
    return ! td
  end function rh2td
    
  ! Compute Relative Humidity (Bolton 1980):

  real function td2rh(td,t,rice) ! td, t, ice=NULL
    real :: td,t
    real, optional :: rice
    !     where:
    !       td - dew point in deg C
    !       t - temperature in deg C
    logical :: ice
    real :: es,e,rh
    if (present(rice)) then
       ice=rice.ge.0.5D0
    else
       ice=(t.le.0.0D0)
    end if
    es=satVapPres(t+273.15, ice)
    ! Vapor pressure in mb;
    e=6.112*exp((17.67*td)/(td + 243.5))
    ! Relative Humidity in percent 
    rh=100.0 * (e/es)
    if (rh>100) rh=100.0D0
    td2rh=rh
    return ! rh
  end function td2rh
  
  !  From somewhere else
  !  GANSKE nyaktig...
  
  real function q2rh(q,t,rp) ! q, t, p = 1013.25
    real :: q, t
    real, optional :: rp
    real :: es,e,rh,p
    !   Q --> RH
    !   q - specific humidity
    !   t - temperature in Kelvin
    !   p - pressure
    if (present(rp)) then
       p=rp
    else
       p=1013.25
    end if
    es        = 6.112 * exp((17.67 * (t-273.15))/(t - 29.65))
    e         =q * p / (0.378 * q + 0.622)
    rh        =e / es
    if (rh > 1) rh=1.0D0
    if (rh < 0) rh=0.0D0
    q2rh=rh*100.0D0
    return ! rh*100
  end function q2rh
  
  real function satVapPres(t,ice) ! t, ice
    real :: t
    logical :: ice
    real :: tc,ew,log10ei,ei,e
    !  Saturation vapour pressure above water
    !
    !    Guide to Meteorological Instruments and Methods of Observation (CIMO Guide)
    !    (WMO, 2008) with t in [C] and ew in [hPa]
    tc =t - 273.15
    ew =6.112*exp(17.62*(tc/(243.12 + tc)))
    !  Saturation vapour pressure above ice
    ! Vapor pressure over ice
    !    Goff Gratch equation (Smithsonian Tables, 1984):
    !
    !    Log10 ei =  -9.09718 (273.16/T - 1)                                                             [12]
    !                       - 3.56654 Log10(273.16/ T)
    !                       + 0.876793 (1 - T/ 273.16)
    !                       + Log10(6.1071)
    !    with T in [K] and ei in [hPa]
    tc =t - 273.15
    ew =6.112*exp(17.62*(tc/(243.12 + tc)))
    !  Saturation vapour pressure above ice
    ! Vapor pressure over ice
    !    Goff Gratch equation (Smithsonian Tables, 1984):
    !
    !    Log10 ei =  -9.09718 (273.16/T - 1)                                                             [12]
    !                       - 3.56654 Log10(273.16/ T)
    !                       + 0.876793 (1 - T/ 273.16)
    !                       + Log10(6.1071)
    !    with T in [K] and ei in [hPa]
    log10ei =  -9.09718*(273.16/t - 1)&
         & - 3.56654*log10(273.16/t) &
         & + 0.876793*(1 - t/273.16) &
         & + log10(6.1071)
    ei      =   10**log10ei
    log10ei =  -9.09718*(273.16/t - 1) &
         & - 3.56654*log10(273.16/t) &
         & + 0.876793*(1 - t/273.16) &
         & + log10(6.1071)
    ei      =   10**log10ei
    if(ice) then
       e=ei
    else
       e=ew
    end if
    satVapPres=e
    return ! e
  end function satVapPres
  function camelCase(strIn,lens) result(strOut)
    implicit none
    integer :: lens
    character(len=*), intent(in) :: strIn
    character(len=len(strIn))    :: strBuff
    character(len=lens)          :: strOut
    integer :: i,j,k
    logical :: lup
    strBuff="";
    k=0
    lup=.true. ! start with uppercase
    do i = 1, len(strIn)
       j = iachar(strIn(i:i))
       if (j>= iachar("a") .and. j<=iachar("z") ) then ! lower case
          k=k+1
          if (lup) then ! make upper case
             strBuff(k:k) = achar(iachar(strIn(i:i))-32)
             lup=.false.
          else
             strBuff(k:k) = strIn(i:i)
          end if
       else if (j>= iachar("A") .and. j<=iachar("Z") ) then
          k=k+1
          if (lup) then
             strBuff(k:k) = strIn(i:i)
             lup=.false.
          else ! make lower case
             strBuff(k:k) = achar(iachar(strIn(i:i))+32)
          end if
       else if (j.eq.iachar(" ")) then
          lup=.true.
       else
          k=k+1
          strBuff(k:k) = strIn(i:i)
       end if
    end do
    strOut=strBuff
  end function camelCase
  function to_upper(strIn) result(strOut)
    ! Adapted from http://www.star.le.ac.uk/~cgp/fortran.html (25 May 2012)
    ! Original author: Clive Page
    
    implicit none
    
    character(len=*), intent(in) :: strIn
    character(len=len(strIn)) :: strOut
    integer :: i,j

    do i = 1, len(strIn)
       j = iachar(strIn(i:i))
       if (j>= iachar("a") .and. j<=iachar("z") ) then
          strOut(i:i) = achar(iachar(strIn(i:i))-32)
       else
          strOut(i:i) = strIn(i:i)
       end if
    end do
    
  end function to_upper
  function to_lower(strIn) result(strOut)
    ! Adapted from http://www.star.le.ac.uk/~cgp/fortran.html (25 May 2012)
    ! Original author: Clive Page
    
    implicit none
    
    character(len=*), intent(in) :: strIn
    character(len=len(strIn)) :: strOut
    integer :: i,j
    
    do i = 1, len(strIn)
       j = iachar(strIn(i:i))
       if (j>= iachar("A") .and. j<=iachar("Z") ) then
          strOut(i:i) = achar(iachar(strIn(i:i))+32)
       else
          strOut(i:i) = strIn(i:i)
       end if
    end do
    
  end function to_lower
  ! returns the shape identification
  integer function shapeid (lon,lat)
    USE shape
    implicit none
    real :: lon
    real :: lat
    integer :: ii,inout
    real :: pos(3),xx,yy,zz
    if (abs(sf%shapeidlat-lat).lt.1.0D-6.and. &
         & abs(sf%shapeidlon-lon).lt.1.0D-6) then
       shapeid=sf%shapeid
       if (parse_bdeb) write(*,*)"Shapeid Using cache:",lat,lon,shapeid
       return
    end if
    do ii=1,sf%nshp
       inout=0
       call shape_lonlat2pos(lon,lat,pos)
       zz=shape_dot(sf%shp(ii)%map(1,3),pos)
       if (zz.ge.sf%shp(ii)%minzz) then
          xx=shape_dot(sf%shp(ii)%map(1,1),pos)
          yy=shape_dot(sf%shp(ii)%map(1,2),pos)
          if (xx.ge.sf%shp(ii)%minxx.and. &
               & xx.le.sf%shp(ii)%maxxx.and. &
               & yy.ge.sf%shp(ii)%minyy.and. &
               & yy.le.sf%shp(ii)%maxyy) then
             if (parse_bdeb) write(*,*)"shapeid Checking shape:",ii,&
                  & sf%shp(ii)%index,sf%shp(ii)%npos, &
                  & trim(sf%shp(ii)%name)
             call shape_pnpoly(xx,yy,sf%shp(ii)%npos,&
                  & sf%shp(ii)%xx,sf%shp(ii)%yy,inout)
             if (parse_bdeb) write(*,*)"Shapeid checked shape:",ii,inout,&
                  & sf%shp(ii)%minxx,sf%shp(ii)%maxxx,&
                  & sf%shp(ii)%minyy,sf%shp(ii)%maxyy,&
                  & trim(sf%shp(ii)%name)
             if (inout.ge.0) then
                shapeid=sf%shp(ii)%index
                sf%shapeid=shapeid
                sf%shapeidlat=lat
                sf%shapeidlon=lon
                return
             end if
          end if
       end if
    end do
    shapeid=0 ! no matching shapes
    sf%shapeid=shapeid
    sf%shapeidlat=lat
    sf%shapeidlon=lon
    return
  end function shapeid
  ! returns the closest shape identification
  integer function vicinity (lon,lat,eps)
    USE shape
    implicit none
    real :: lon ! longitude in degrees
    real :: lat ! latitude in degrees
    real :: eps ! tolerance in km
    integer :: ii,inout
    real :: dd, dbbox, epr
    logical lbbox
    integer ibbox
    real :: pos(3),rr,xx,yy,zz
    ! first check if position is inside a polygon...
    if (abs(sf%vicinitylat-lat).lt.1.0D-6.and. &
         & abs(sf%vicinitylon-lon).lt.1.0D-6) then
       vicinity=sf%vicinity
       if (parse_bdeb) write(*,*)"Vicinity Using cache:",lat,lon,vicinity
       return
    end if
    do ii=1,sf%nshp
       inout=0
       call shape_lonlat2pos(lon,lat,pos)
       zz=shape_dot(sf%shp(ii)%map(1,3),pos)
       if (zz.ge.sf%shp(ii)%minzz) then
          xx=shape_dot(sf%shp(ii)%map(1,1),pos)
          yy=shape_dot(sf%shp(ii)%map(1,2),pos)
          if (xx.ge.sf%shp(ii)%minxx.and. &
               & xx.le.sf%shp(ii)%maxxx.and. &
               & yy.ge.sf%shp(ii)%minyy.and. &
               & yy.le.sf%shp(ii)%maxyy) then
             if (parse_bdeb) write(*,*)"vicinity Checking shape:",ii,&
                  & sf%shp(ii)%index,sf%shp(ii)%npos, &
                  & trim(sf%shp(ii)%name)
             call shape_pnpoly(xx,yy,sf%shp(ii)%npos,&
                  & sf%shp(ii)%xx,sf%shp(ii)%yy,inout)
             if (parse_bdeb) write(*,*)"vicinity Checking shape:",ii,inout,&
                  & sf%shp(ii)%minxx,sf%shp(ii)%maxxx,&
                  & sf%shp(ii)%minyy,sf%shp(ii)%maxyy,&
                  & trim(sf%shp(ii)%name)
             if (inout.ge.0) then ! position inside shape, we are done...
                vicinity=sf%shp(ii)%index
                sf%vicinity=vicinity
                sf%vicinitylat=lat
                sf%vicinitylon=lon
                return
             end if
          end if
       end if
    end do
    ! find closest polygon (in cartesian coordinates)
    ! We mix distance on cirle with distance through circle..
    call shape_lonlat2pos(lon,lat,pos) ! radius==1
    dbbox=abs(eps/6371.0D0) ! km -> rad
    if(parse_bdeb)write(*,*)'VICINITY limit:',dbbox
    lbbox=.false.
    ibbox=0
    do ii=1,sf%nshp ! loop over shapes
       ! get distance to bounding box
       dd=acos(shape_dot(pos,sf%shp(ii)%map(1,3)))
       if (dd.lt.1.57D0.and.dd-sf%shp(ii)%maxrad.lt.dbbox) then ! check bounding-box
          if(parse_bdeb)write(*,'(X,A,I3,X,A,4(X,F5.2))')'Vicinity close: ',&
               & ii,trim(sf%shp(ii)%name),dbbox,dd,shape_rtodeg(dd),shape_rtodeg(sf%shp(ii)%maxrad)
          dd = shape_ddpoly(pos,sf%shp(ii)%npos,sf%shp(ii)%pos,sf%shp(ii)%actual)
          if(parse_bdeb)write(*,'(X,A,I3,X,A,3(X,F5.2))')'                ',&
               & ii,trim(sf%shp(ii)%name),dbbox,dd,shape_rtodeg(dd)
          if (dd.ge.0.0D0.and.dd.lt.dbbox) then
             dbbox=dd
             ibbox=sf%shp(ii)%index
          end if
       end if
    end do
    if(parse_bdeb) then
       if (ibbox.ne.0) write(*,*)'VICINITY finally:',ibbox,trim(sf%shp(ibbox)%name)
    end if
    vicinity=ibbox
    sf%vicinity=vicinity
    sf%vicinitylat=lat
    sf%vicinitylon=lon
    return
  end function vicinity
  !
  character*25 function getname25(val)
    implicit none
    real :: val
    integer :: jj
    do jj=lbound(constval,1),ubound(constval,1)
       if (abs(constval(jj)-val).lt.1.0D-5) then
          getname25=const(jj)
          return
       end if
    end do
    getname25="undefined"
    return
  end function getname25
  !
  !
  !###############################################################################
  ! RERUN ROUTINES
  !###############################################################################
  !
  !
  subroutine parse_setvariable(var,crc250,irc)
    implicit none
    character*(*) :: var
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    integer :: lenv
    character*22 :: myname="parse_setvariable"
    !if(parse_bdeb)write(*,*)myname,' Entering.',irc
    if (allocated(rerun_var80)) deallocate (rerun_var80)
    if (allocated(rerun_lenv)) deallocate (rerun_lenv)
    if (allocated(rerun_value)) deallocate (rerun_value)
    lenv=len_trim(var)
    if (lenv.eq.0) then
       rerun_nvar=0
    else
       rerun_nvar=1
       allocate(rerun_var80(rerun_nvar),&
            & rerun_lenv(rerun_nvar),&
            & rerun_value(rerun_nvar),&
            & stat=irc)
       if (irc.ne.0) then
          call parse_errorappend(crc250,myname)
          call parse_errorappend(crc250,"Unable to allocate &
               & 'rerun_var80'.")
          call parse_errorappend(crc250,"\n")
          return
       end if
       rerun_var80(1)=trim(var)
       call chop0(rerun_var80(1),80)
       rerun_lenv(1)=length(rerun_var80(1),80,10)
       if(parse_bdeb)write(*,*)myname,"Variable:'"//&
            & rerun_var80(1)(1:rerun_lenv(1))//"'",irc
    end if
    return
  end subroutine parse_setvariable
  !
  subroutine parse_setvalue(val,crc250,irc)
    implicit none
    integer :: val
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    character*22 :: myname="parse_setvariable"
    !if(parse_bdeb)write(*,*)myname,' Entering.',irc
    if (rerun_nvar.eq.1) then
       rerun_value(1)=real(val)
       if(parse_bdeb)write(*,*)myname,"Value:'",rerun_value(1),"'",irc
    end if
  end subroutine parse_setvalue
  !
  subroutine parse_setoffset(off,crc250,irc)
    implicit none
    character*(*) :: off
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    integer :: jj
    character*22 :: myname="parse_setvariable"
    !if(parse_bdeb)write(*,*)myname,' Entering.',irc
    rerun_off250=trim(off)
    call chop0(rerun_off250,250)
    rerun_leno=length(rerun_off250,250,10)
    if(parse_bdeb)write(*,*)myname,"Offset:'"//rerun_off250(1:rerun_leno)//"'",irc
    if (associated(rerun_offset)) then
       call parse_close (rerun_offset,crc250,irc)
       if (irc.ne.0) then
          call parse_errorappend(crc250,"parse_close")
          return
       end if
    end if
    if (rerun_leno.gt.0) then
       call parse_open(rerun_offset,crc250,irc)
       if (irc.ne.0) then
          call parse_errorappend(crc250,myname)
          call parse_errorappend(crc250," Error return from parse_open.")
          call parse_errorappend(crc250,"\n")
          return
       end if
       call parse_parsef(rerun_offset,&
            & rerun_off250(1:rerun_leno),rerun_var80,crc250,irc)
       if (irc.ne.0) then
          if(parse_bdeb)then
             do jj=1,size(rerun_var80)
                write(*,'(A,A,I0,A)')myname,"     var(",jj,") = '"//&
                     & trim(rerun_var80(jj))//"'"
             end do
          end if
          call parse_errorappend(crc250,myname)
          call parse_errorappend(crc250," Error return from parsef.")
          call parse_errorappendi(crc250,irc)
          call parse_errorappend(crc250,"\n")
          return
       end if
    end if
    return
  end subroutine parse_setoffset
  !
  real function parse_gettimeoffset(crc250,irc)
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="parse_gettimeoffset"
    if (associated(rerun_offset)) then
       parse_gettimeoffset=parse_evalf(rerun_offset,rerun_value,crc250,irc)
       if (irc.ne.0) then
          call parse_errorappend(crc250,myname)
          call parse_errorappend(crc250," Error return from evalf.")
          call parse_errorappendi(crc250,irc)
          call parse_errorappend(crc250,"\n")
          return
       end if
    else
       parse_gettimeoffset=0.0D0
    end if
    return
  end function parse_gettimeoffset
  !
end module parse
#__file: 'libparse/par_setOffset.F90' 0100644    **DO NOT DELETE**
subroutine par_setoffset(off,crc250, irc)
  use parse
  implicit none
  character*(*) :: off
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setoffset"
  !write(*,*) myname, 'Entering.',irc,filter250,
  call parse_setoffset(off,crc250,irc)
  if (irc.ne.0) then
     call parse_errorappend(crc250,myname)
     call parse_errorappend(crc250," Error return from col_setobscache.")
     call parse_errorappendi(crc250,irc)
     call parse_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine par_setoffset
#__file: 'libparse/par_setShapeFile.F90' 0100644    **DO NOT DELETE**
subroutine par_setshapefile(fn250, cn11, crc250, irc)
  use parse
  implicit none
  character*250 :: fn250
  character*11 :: cn11
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setshapefile"
  !write(*,*) myname, 'Entering.',irc
  call parse_setshapefile(fn250, cn11, crc250,irc)
  if (irc.ne.0) then
     call parse_errorappend(crc250,myname)
     call parse_errorappend(crc250," Error return from parse_setshapefile.")
     call parse_errorappendi(crc250,irc)
     call parse_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine par_setshapefile
#__file: 'libparse/par_setValue.F90' 0100644    **DO NOT DELETE**
subroutine par_setvalue(val,crc250, irc)
  use parse
  implicit none
  integer :: val
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setvalue"
  !write(*,*) myname, 'Entering.',irc,filter250,
  call parse_setvalue(val,crc250,irc)
  if (irc.ne.0) then
     call parse_errorappend(crc250,myname)
     call parse_errorappend(crc250," Error return from col_setobscache.")
     call parse_errorappendi(crc250,irc)
     call parse_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine par_setvalue
#__file: 'libparse/par_setVariable.F90' 0100644    **DO NOT DELETE**
subroutine par_setvariable(var,crc250, irc)
  use parse
  implicit none
  character*(*) :: var
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setvariable"
  !write(*,*) myname, 'Entering.',irc,filter250,
  call parse_setvariable(var,crc250,irc)
  if (irc.ne.0) then
     call parse_errorappend(crc250,myname)
     call parse_errorappend(crc250," Error return from col_setobscache.")
     call parse_errorappendi(crc250,irc)
     call parse_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine par_setvariable
#__file: 'libparse/par_simplifyShapes.F90' 0100644    **DO NOT DELETE**
subroutine par_simplifyShapes(tol20, crc250, irc)
  use parse
  implicit none
  character*20 :: tol20
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "simplifyShapes"
  !write(*,*) myname, 'Entering.',irc
  call parse_simplifyShapes(tol20, crc250,irc)
  if (irc.ne.0) then
     call parse_errorappend(crc250,myname)
     call parse_errorappend(crc250," Error return from parse_simplifyShapes.")
     call parse_errorappendi(crc250,irc)
     call parse_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine par_simplifyShapes
#__file: 'libplot/plo_clearAttrStack.F90' 0100644    **DO NOT DELETE**
subroutine plo_clearattrstack(sid,crc250, irc)
  use plot
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearattrstack"
  type(plot_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc
  call plot_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_clearattrstack(css,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_clearattrstack.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine plo_clearattrstack
#__file: 'libplot/plo_clearColumn.F90' 0100644    **DO NOT DELETE**
subroutine plo_clearcolumn(sid, crc250, irc)
  use plot
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "plo_clearcolumn"
  type(plot_session), pointer :: css !  current session
  !if(plot_bdeb)write(*,*) myname, 'Entering.',irc
  call plot_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_clearcolumn(css,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_clearcolumn.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !if(plot_bdeb)write(*,*) myname,' Done.'
  return
end subroutine plo_clearcolumn
#__file: 'libplot/plo_clearSetStack.F90' 0100644    **DO NOT DELETE**
subroutine plo_clearsetstack(sid, crc250, irc)
  use plot
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "clearsetstack"
  type(plot_session), pointer :: css !  current session
  !write(*,*) myname, 'Entering.',irc
  call plot_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_clearsetstack(css,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_clearsetstack.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine plo_clearsetstack
#__file: 'libplot/plo_closeSession.F90' 0100644    **DO NOT DELETE**
subroutine plo_closesession(sid, crc250, irc)
  use plot
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "plo_closesession"
  type(plot_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call plot_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_closesession(css,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_closeSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.'
  return
end subroutine plo_closeSession
#__file: 'libplot/plo_getGraphicsfile.F90' 0100644    **DO NOT DELETE**
subroutine plo_getgraphicsfile(pid, gra250, crc250, irc)
  use plot
  implicit none
  integer :: pid             ! session id
  character*250 :: gra250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "getgraphicsfile"
  type(plot_session), pointer :: pss !  current session
  !write(*,*) myname, 'Entering.',irc,gra250
  !
  call plot_getSession(pss,pid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_getgraphicsfile(pss,gra250,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_getgraphicsfile.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine plo_getgraphicsfile
#__file: 'libplot/plo_getTablefile.F90' 0100644    **DO NOT DELETE**
subroutine plo_gettablefile(pid, tab250, crc250, irc)
  use plot
  implicit none
  integer :: pid             ! session id
  character*250 :: tab250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "getTablefile"
  type(plot_session), pointer :: pss !  current session
  !write(*,*) myname, 'Entering.',irc,tab250
  !
  call plot_getSession(pss,pid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_gettablefile(pss,tab250,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_gettablefile.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine plo_gettablefile
#__file: 'libplot/plo_makeTable.F90' 0100644    **DO NOT DELETE**
subroutine plo_maketable(sid,cid,mid,oid,tab250,gra250,cat250,test,fill250,crc250, irc)
  use plot
  use model
  use observations
  use colocation
  implicit none
  integer :: sid ! plot session id
  integer :: cid ! coloc session id
  integer :: mid ! model session id
  integer :: oid ! observation session id
  character*250 :: tab250
  character*250 :: gra250
  character*250 :: cat250
  integer :: test
  character*250 :: fill250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "plo_maketable"
  type(plot_session), pointer :: pss !  current session
  type(col_session), pointer ::  css !  current session
  type(mod_session), pointer ::  mss !  current session
  type(obs_session), pointer ::  oss !  current session
  !if (plot_bdeb)write(*,*)myname,'Entering.',irc,test
  ! get session objects
  call model_getSession(mss,mid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from mod_getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call observation_getSession(oss,oid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from obs_getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call colocation_getSession(css,cid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plot_getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_getSession(pss,sid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plot_getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !
  call  plot_maketable(pss,css,mss,oss,tab250,gra250,cat250,test,fill250,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plot_maketable.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  return
end subroutine plo_maketable
#__file: 'libplot/plo_openSession.F90' 0100644    **DO NOT DELETE**
subroutine plo_opensession(sid, crc250, irc)
  use plot
  implicit none
  integer :: sid             ! session id
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "plo_opensession"
  type(plot_session), pointer :: css !  current session
  !write(*,*) myname,'Entering.',irc
  call plot_opensession(sid,css,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_openSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,'Done.',sid
  return
end subroutine plo_opensession
#__file: 'libplot/plo_pushAttr.F90' 0100644    **DO NOT DELETE**
subroutine plo_pushattr(sid,name80,val250,crc250, irc)
  use plot
  implicit none
  integer :: sid ! plot session id
  character*80 :: name80
  character*250 :: val250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "plo_pushattr"
  type(plot_session), pointer :: css !  current session
  !
  call plot_getSession(css,sid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !
  call  plot_pushattr(css,name80,val250,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plot_pushattr.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  return
end subroutine plo_pushattr
#__file: 'libplot/plo_pushColumn.F90' 0100644    **DO NOT DELETE**
subroutine plo_pushcolumn(sid,nam80,exp250,crc250, irc)
  use plot
  implicit none
  integer :: sid ! plot session id
  character*80 :: nam80
  character*250 :: exp250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "plo_pushcolumn"
  type(plot_session), pointer :: pss !  current session
  !write(*,*)myname,'Entering:',irc,sid,cid,mid,oid,nam250
  ! get session objects
  call plot_getSession(pss,sid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !
  call  plot_pushcolumn(pss,nam80,exp250,crc250, irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plot_pushcolumn.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*)myname,'Exiting:',irc,sid,nam80
  return
end subroutine plo_pushcolumn
#__file: 'libplot/plo_pushSet.F90' 0100644    **DO NOT DELETE**
subroutine plo_pushset(sid,cid,mid,oid,nam80,leg250,crc250, irc)
  use plot
  use model
  use observations
  use colocation
  implicit none
  integer :: sid ! plot session id
  integer :: cid ! coloc session id
  integer :: mid ! model session id
  integer :: oid ! observation session id
  character*80 :: nam80
  character*250 :: leg250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "plo_pushset"
  type(plot_session), pointer :: pss !  current session
  type(col_session), pointer ::  css !  current session
  type(mod_session), pointer ::  mss !  current session
  type(obs_session), pointer ::  oss !  current session
  !write(*,*)myname,'Entering:',irc,sid,cid,mid,oid,nam80
  ! get session objects
  call model_getSession(mss,mid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from mod_getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call observation_getSession(oss,oid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from obs_getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call colocation_getSession(css,cid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plot_getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !
  call plot_getSession(pss,sid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !
  call  plot_pushset(pss,css,mss,oss,nam80,leg250,crc250, irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plot_pushset.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*)myname,'Exiting:',irc,sid,cid,mid,oid,nam80
  return
end subroutine plo_pushset
#__file: 'libplot/plo_setDebug.F90' 0100644    **DO NOT DELETE**
subroutine plo_setdebug(ideb)
  use observations
  use model
  use colocation
  use plot
  use parse
  use shape
  implicit none
  integer :: ideb
  logical :: bdeb
  if (ideb.eq.0) then
     obs_bdeb=.false.   ! observations
     mod_bdeb=.false. ! model
     col_bdeb=.false.   ! colocation
     plot_bdeb=.false.  ! plot
     parse_bdeb=.false. ! parse
  else if (abs(ideb).eq.1) then ! obs
     if (ideb.gt.0) then
        obs_bdeb=.true.
     else
        obs_bdeb=.false.
     end if
  else if (abs(ideb).eq.2) then ! model
     if (ideb.gt.0) then
        mod_bdeb=.true.
     else
        mod_bdeb=.false.
     end if
  else if (abs(ideb).eq.3) then ! col
     if (ideb.gt.0) then
        col_bdeb=.true.
     else
        col_bdeb=.false.
     end if
  else if (abs(ideb).eq.4) then ! plot
     if (ideb.gt.0) then
        plot_bdeb=.true.
     else
        plot_bdeb=.false.
     end if
  else if (abs(ideb).eq.5) then ! parse
     if (ideb.gt.0) then
        parse_bdeb=.true.
     else
        parse_bdeb=.false.
     end if
  else if (abs(ideb).eq.6) then ! shape
     if (ideb.gt.0) then
        shape_bdeb=.true.
     else
        shape_bdeb=.false.
     end if
  end if
  return
end subroutine plo_setdebug
#__file: 'libplot/plo_setGraphicsfile.F90' 0100644    **DO NOT DELETE**
subroutine plo_setgraphicsfile(pid, gra250, crc250, irc)
  use plot
  implicit none
  integer :: pid             ! session id
  character*250 :: gra250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "setgraphicsfile"
  type(plot_session), pointer :: pss !  current session
  !write(*,*) myname, 'Entering.',irc,gra250
  !
  call plot_getSession(pss,pid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_setgraphicsfile(pss,gra250,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_setgraphicsfile.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine plo_setgraphicsfile
#__file: 'libplot/plo_setTablefile.F90' 0100644    **DO NOT DELETE**
subroutine plo_settablefile(pid, tab250, crc250, irc)
  use plot
  implicit none
  integer :: pid             ! session id
  character*250 :: tab250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "settablefile"
  type(plot_session), pointer :: pss !  current session
  !write(*,*) myname, 'Entering.',irc,tab250
  !
  call plot_getSession(pss,pid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_settablefile(pss,tab250,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_settablefile.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine plo_settablefile
#__file: 'libplot/plo_setType.F90' 0100644    **DO NOT DELETE**
subroutine plo_settype(pid, type250, crc250, irc)
  use plot
  implicit none
  integer :: pid             ! session id
  character*250 :: type250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "settype"
  type(plot_session), pointer :: pss !  current session
  !write(*,*) myname, 'Entering.',irc,type250
  !
  call plot_getSession(pss,pid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_settype(pss,type250,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_settype.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine plo_settype
#__file: 'libplot/plo_strepFiles.F90' 0100644    **DO NOT DELETE**
subroutine plo_strepfiles(pid, crc250, irc)
  use plot
  implicit none
  integer :: pid             ! session id
  character*250 :: gra250
  character*250 :: crc250
  integer :: irc
  character*25 :: myname = "strepfiles"
  type(plot_session), pointer :: pss !  current session
  !write(*,*) myname, 'Entering.',irc,gra250
  !
  call plot_getSession(pss,pid,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from getSession.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  call plot_strepfiles(pss,crc250,irc)
  if (irc.ne.0) then
     call plot_errorappend(crc250,myname)
     call plot_errorappend(crc250," Error return from plo_strepfiles.")
     call plot_errorappendi(crc250,irc)
     call plot_errorappend(crc250,"\n")
     return
  end if
  !write(*,*) myname,' Done.'
  return
end subroutine plo_strepfiles
#__file: 'libplot/plot.F90' 0100644    **DO NOT DELETE**
module plot
  IMPLICIT NONE
  !
  ! Global constants
  !
  logical     :: plot_bdeb=.false.
  !
  ! SESSION VARIABLES
  !
  type :: plot_attribute
     character*80 :: name80=""
     integer :: lenn=0
     character*250 :: value250=""
     integer :: lenv=0
     type(plot_attribute), pointer :: prev => null()         ! linked list
     type(plot_attribute), pointer :: next => null()         ! linked list
  end type plot_attribute
  !
  ! Target item
  !   
  type :: plot_obstrg
     character*80 :: trg80      ! target name
     character*250 :: pos250    ! position/sequence number
     character*80 :: descr80    ! descriptor
     character*250 :: info250   ! information
     character*80 :: min80      ! min value
     character*80 :: max80      ! max value
     type(plot_obstrg), pointer :: prev => null()   ! linked list
     type(plot_obstrg), pointer :: next => null()   ! linked list
  end type plot_obstrg
  !
  type :: plot_modtrg
     character*80 :: trg80      ! target name
     character*80 :: var80      ! variable name
     character*80 :: min80      ! min value
     character*80 :: max80      ! max value
     type(plot_modtrg), pointer :: prev => null()   ! linked list
     type(plot_modtrg), pointer :: next => null()   ! linked list
  end type plot_modtrg
  !
  ! default values for the model targets
  !
  type :: plot_default
     character*80 :: n80   ! name
     integer :: lenn       ! name length
     character*80 :: v80   ! value
     integer :: lenv       ! value length
     real :: val           ! value
     type(plot_default), pointer :: prev => null()   ! linked list
     type(plot_default), pointer :: next => null()   ! linked list
  end type plot_default
  !
  type :: plot_location
     type(plot_default), pointer  :: cDef => null()
     type(plot_default), pointer  :: firstDef => null()! linked list start
     type(plot_default), pointer  :: lastDef => null() ! linked list end
     type(plot_location), pointer :: prev => null()    ! linked list
     type(plot_location), pointer :: next => null()    ! linked list
  end type plot_location
  !
  type :: plot_match
     character*80 :: n80 ! name
     character*250 :: e250 ! obs expression
     character*80 :: l80 ! lower limit
     character*80 :: u80 ! upper limit
     type(plot_match), pointer :: prev => null()   ! linked list
     type(plot_match), pointer :: next => null()   ! linked list
  end type plot_match
  !
  type plot_column
     character*80  :: name80
     integer :: lenn=0
     character*250  :: exp250
     integer :: lene=0
     type(plot_column), pointer  :: prev => null() ! linked list start
     type(plot_column), pointer  :: next => null()  ! linked list end
  end type plot_column
  !
  type :: plot_set
     character*80 :: name80=""
     integer :: id=0
     character*250, allocatable :: colv(:)
     character*250 :: leg250=""
     ! model data
     ! obs data
     CHARACTER(LEN=250)              :: tablepath=""
     integer :: category                   ! filter category/bufrType
     integer :: subCategory                ! filter subcategory/subType
     character*80                    :: ind_obs80=""          ! obs index target name
     character*250                   :: ind_exp250=""         ! index target expression
     logical                         :: ind(3)   ! true if both ind_start and ind_stop are valid
     real                            :: ind_start=0.0D0         ! lowest index
     real                            :: ind_stop=0.0D0          ! highest index
     character*250 :: obs250="" ! observation cache file
     character*250 :: mod250="" ! model cache file
     character*80                    :: ind_trg80=""            ! model index target name
     character*80                    :: ind_mod80=""            ! model index variable
     ! obs data
     type(plot_obstrg), pointer :: firstObstrg => null()        ! linked list
     type(plot_obstrg), pointer :: lastObstrg => null()         ! linked list
     integer :: nObsTrg = 0
     ! mod data
     type(plot_modtrg), pointer :: firstModtrg => null()        ! linked list
     type(plot_modtrg), pointer :: lastModtrg => null()         ! linked list
     integer :: nModTrg = 0
     type(plot_obstrg), pointer :: cObstrg => null()            ! linked list
     type(plot_modtrg), pointer :: cModtrg => null()            ! linked list
     ! colocation data
     type(plot_location), pointer :: firstLoc => null()         ! linked list start
     type(plot_location), pointer :: lastLoc => null()          ! linked list end
     type(plot_location), pointer :: currentLoc => null()       ! current location
     type(plot_location), pointer :: cLoc => null()             ! current location
     integer :: ndef = 0                                        ! number of defaults
     type(plot_match), pointer :: firstMatch => null()          ! linked list
     type(plot_match), pointer :: lastMatch => null()           ! linked list
     type(plot_match), pointer :: cMatch => null()              ! linked list
     integer :: nmatch = 0
     character*250 :: fltmod250=""
     character*250 :: fltobs250=""
     !
     ! output columns 
     integer :: ccol=0    ! number of allocated columns
     character*80,allocatable    :: col80(:)
     integer, allocatable        :: col_lenn(:)
     character*250,allocatable   :: col_exp250(:)
     integer, allocatable        :: col_lene(:)
     !
     ! target lists
     integer :: nTrgMod=0
     character*80, pointer :: trgMod80(:) => null()       ! list of target names
     integer, pointer :: trgModLent(:) => null()         ! list of target name length
     logical :: trgModSet=.false. ! is target list set?
     ! linked list
     type(plot_set), pointer :: prev => null()         ! linked list
     type(plot_set), pointer :: next => null()         ! linked list
  end type plot_set
  !
  type :: plot_session
     integer :: sid=0            ! session id
     character*250 :: type250="" ! type
     integer :: lenp =0
     !
     ! output
     character*250 :: tab250=""  ! table file name
     integer :: lent             ! length of tab250
     character*250 :: gra250=""  ! graphics file name
     integer :: leng             ! length of gra250
     !
     ! time information
     !  VALUES(1):	The year
     !  VALUES(2):	The month
     !	VALUES(3):	The day of the month
     !	VALUES(4):	Time difference with UTC in minutes
     !	VALUES(5):	The hour of the day
     !	VALUES(6):	The minutes of the hour
     !	VALUES(7):	The seconds of the minute
     !	VALUES(8):	The milliseconds of the second
     integer :: values(8)
     !
     integer :: ncol=0    ! number of columns in linked list
     type(plot_column), pointer :: firstColumn => null()   ! linked list start
     type(plot_column), pointer :: lastColumn => null()    ! linked list end
     !
     integer :: natt =0
     type(plot_attribute), pointer :: firstAttribute => null()         ! linked list
     type(plot_attribute), pointer :: lastAttribute => null()         ! linked list
     integer :: nset =0
     type(plot_set), pointer :: firstSet => null()         ! linked list
     type(plot_set), pointer :: lastSet => null()          ! linked list
     type(plot_set), pointer :: currentSet => null()       ! linked list
     type(plot_session), pointer :: prev => null()         ! linked list
     type(plot_session), pointer :: next => null()         ! linked list
  end type plot_session
  !
  integer :: maxid=0 ! session counter
  type(plot_session), pointer :: firstSession => null()   ! linked list start
  type(plot_session), pointer :: lastSession => null()    ! linked list end
  !
CONTAINS
  !
  !###############################################################################
  ! SESSION ROUTINES
  !###############################################################################
  !
  subroutine plot_opensession(sid,pss,crc250,irc)
    integer :: sid
    character*250 :: crc250
    integer :: irc
    type(plot_session),pointer :: pss  !  new session
    character*25 :: myname="plot_openSession"
    if (.not.associated(firstSession)) then
       allocate(firstSession, lastSession,stat=irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250,"Unable to allocate 'firstSession/lastSession'.")
          call plot_errorappend(crc250,"\n")
          return
       end if
       firstSession%next => lastSession
       lastSession%prev => firstSession
    end if
    nullify(pss)
    allocate(pss,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'new session'.")
       call plot_errorappend(crc250,"\n")
       return
    end if
    maxid=maxid+1
    pss%sid=maxid
    pss%prev => lastSession%prev
    pss%next => lastSession
    pss%prev%next => pss
    pss%next%prev => pss
    allocate(pss%firstAttribute,pss%lastAttribute,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'attribute chain'.")
       call plot_errorappend(crc250,"\n")
       return
    end if
    pss%firstAttribute%next => pss%lastAttribute
    pss%lastAttribute%prev => pss%firstAttribute
    pss%natt=0
    allocate(pss%firstSet,pss%lastSet,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'attribute chain'.")
       call plot_errorappend(crc250,"\n")
       return
    end if
    pss%firstSet%next => pss%lastSet
    pss%lastSet%prev => pss%firstSet
    pss%nset=0
    !
    allocate(pss%firstColumn,pss%lastColumn, stat=irc) ! 
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate &
            & 'pss%firstColumn/pss%lastColumn'.")
       call plot_errorappend(crc250,"\n")
       return
    end if
    pss%firstColumn%next => pss%lastColumn
    pss%lastColumn%prev => pss%firstColumn
    !
    sid = pss%sid
    return
  end subroutine plot_opensession

  subroutine plot_getSession(pss,sid,crc250,irc)
    type(plot_session), pointer :: pss !  current session
    integer :: sid
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="plot_getSession"
    if (.not.associated(firstSession)) then
       irc=911
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"No session is opened!")
       call plot_errorappendi(crc250,irc)
       call plot_errorappend(crc250,"\n")
       return
    end if
    pss => firstSession%next
    do while ( .not.associated(pss,target=lastSession))
       if (pss%sid .eq. sid) then
          !if (plot_bdeb) write(*,*)myname,'Exiting with sid:',sid,irc
          return
       end if
       pss=>pss%next
    end do
    nullify(pss)
    irc=342
    call plot_errorappend(crc250,myname)
    call plot_errorappend(crc250,"Invalid session id:")
    call plot_errorappendi(crc250,sid)
    call plot_errorappend(crc250,"\n")
    return
  end subroutine plot_getSession

  subroutine plot_closeSession(pss,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="plot_closeSession"
    if(plot_bdeb)write(*,*)myname,'Entering.',irc
    if (associated(pss)  .and. .not.associated(pss,target=lastSession)) then
       call plot_removeSession(pss,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from removeSession.")
          call plot_errorappendi(crc250,irc)
          call plot_errorappend(crc250,"\n")
          return
       end if
    else
       irc=599
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Attempt to close none-existent session.")
       call plot_errorappend(crc250,"\n")
       return
    end if
    if(plot_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine plot_closeSession

  subroutine plot_removeSession(pss,crc250,irc)
    type(plot_session), pointer :: pss !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="plot_removeSession"
    pss%prev%next => pss%next
    pss%next%prev => pss%prev
    call plot_clearAttrStack(pss,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearAttrStack.")
       call plot_errorappendi(crc250,irc)
       call plot_errorappend(crc250,"\n")
       return
    end if
    !call plot_clearSetStack(pss)
    deallocate(pss%firstAttribute,pss%lastAttribute,pss%firstSet,pss%lastSet)
    deallocate(pss)
  end subroutine plot_removeSession
  !
  !###############################################################################
  ! TYPE + ATTRIBUTE ROUTINES
  !###############################################################################
  !
  ! set the observation graphivcs type ("rms+stdv", "scatter" etc).
  subroutine plot_settype(pss,type250,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: type250
    character*250 :: crc250
    integer :: irc
    integer,external :: length
    character*22 :: myname="plot_settype"
    pss%type250=type250
    pss%lenp=length(type250,250,10)
    return
  end subroutine plot_settype
  !
  subroutine plot_clearattrstack(pss,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: crc250
    integer :: irc
    integer :: irc2
    character*22 :: myname="plot_clearattrstack"
    type(plot_attribute), pointer :: cat,nat !  current attribute
    cat => pss%firstAttribute%next
    do while (.not.associated(cat,target=pss%lastAttribute))
       nat => cat%next
       call plot_unlinkAttribute(cat)
       call plot_deallocateAttribute(cat)
       pss%natt=pss%natt-1
       cat  => nat
    end do
    return
  end subroutine plot_clearattrstack
  !
  subroutine plot_unlinkAttribute(cat)
    implicit none
    type(plot_attribute), pointer :: cat !  current attribute
    cat%prev%next => cat%next
    cat%next%prev => cat%prev
    return
  end subroutine plot_unlinkAttribute
  !
  subroutine plot_deallocateAttribute(cat)
    implicit none
    type(plot_attribute), pointer :: cat !  current attribute
    integer :: irc2
    deallocate(cat,stat=irc2) ! ignore any errors
    return
  end subroutine plot_deallocateAttribute
  !
  subroutine plot_pushattr(pss,name80,val250,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*80 :: name80
    character*250 :: val250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_pushattr"
    integer :: lenn,lenv
    integer, external :: length
    type(plot_attribute), pointer :: cat !  current attribute
    lenn=length(name80,80,10)
    lenv=length(val250,250,10)
    if (lenn.ne.0) then
       allocate(cat,stat=irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250,"Unable to allocate 'attribute'.")
       end if
       cat%name80=name80
       cat%lenn=lenn
       cat%value250=val250
       cat%lenv=lenv
       cat%next => pss%lastAttribute
       cat%prev => pss%lastAttribute%prev
       cat%prev%next => cat
       cat%next%prev => cat
       pss%natt=pss%natt+1
       nullify(cat)
    else
       irc=344
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Attempt to push empty attribute/value.")
       return
    end if
    return
  end subroutine plot_pushattr
  !
  !###############################################################################
  ! OUTPUT FILE ROUTINE
  !###############################################################################
  !
  subroutine plot_setTablefile(pss,tab250,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: tab250 ! name of table file
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    pss%tab250=tab250
    CALL CHOP0(pss%tab250,250)
    PSS%LENT=LENGTH(pss%tab250,250,10)
    return
  end subroutine plot_setTablefile
  !
  subroutine plot_getTablefile(pss,tab250,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: tab250 ! name of table file
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    tab250=pss%tab250
    return
  end subroutine plot_getTablefile
  !
  subroutine plot_openfile(pss,ounit,tab250,lent,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    integer :: ounit
    character*250 :: tab250
    integer :: lent
    character*250 :: crc250
    integer :: irc
    integer, external :: ftunit,length
    character*22 :: myname="plot_openFile"
    call chop0(tab250,250)
    lent=length(tab250,250,10)
    ounit=ftunit(irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from FTUNIT.")
       call plot_errorappendi(crc250,irc)
       return
    end if
    write(*,'(X,A,X,A)')myname,"Table file: "//tab250(1:lent)
    open(unit=ounit,file=tab250(1:lent), &
         & access="sequential",form="formatted",status="unknown",iostat=irc)
    if(plot_bdeb)write(*,*)myname,'Opened:',tab250(1:lent),ounit,irc
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to open table file '"//tab250(1:lent)//"'")
       call plot_errorappendi(crc250,irc)
       return
    end if
    return
  end subroutine plot_openfile
  !
  subroutine plot_openfileapp(pss,ounit,tab250,lent,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    integer :: ounit
    character*250 :: tab250
    integer :: lent
    character*250 :: crc250
    integer :: irc
    integer, external :: ftunit,length
    character*22 :: myname="plot_openFileApp"
    call chop0(tab250,250)
    lent=length(tab250,250,10)
    ounit=ftunit(irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from FTUNIT.")
       call plot_errorappendi(crc250,irc)
       return
    end if
    open(unit=ounit,file=tab250(1:lent), &
         & access="append",form="formatted",status="old",iostat=irc)
    if(plot_bdeb)write(*,*)myname,'Appending:',tab250(1:lent),ounit,irc
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to open table file '"//tab250(1:lent)//"'")
       call plot_errorappendi(crc250,irc)
       return
    end if
    return
  end subroutine plot_openfileapp
  !
  subroutine plot_closeFile(pss,ounit,tab250,lent,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    integer :: ounit
    character*250 :: tab250
    integer :: lent
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_closeFile"
    close(unit=ounit,iostat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to close table file '"//tab250(1:lent)//"'")
       call plot_errorappendi(crc250,irc)
       return
    end if
    return
  end subroutine plot_closeFile
  !
  subroutine plot_addComments(pss,css,mss,oss,ounit,tab250,lent,gra250,cat250,crc250,irc)
    use model
    use observations
    use colocation
    use parse
    implicit none
    type(plot_session), pointer :: pss !  current session
    type(col_session), pointer ::  css !  current session
    type(mod_session), pointer ::  mss !  current session
    type(obs_session), pointer ::  oss !  current session
    integer :: cid,mid,oid
    integer :: ounit
    character*250 :: tab250,gra250,cat250
    integer :: lent
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_makecomments"
    integer, external :: length
    integer :: lenc,lene,lenn,lenl,leng
    type(plot_attribute), pointer :: attr => null()
    character*250 :: leg250
    character*80 :: name80
    character*80, allocatable :: var80(:)
    integer :: ii,jj
    integer :: ncol
    character*80, allocatable :: col80(:)
    character*250, allocatable :: exp250(:)
    call chop0(cat250,250)
    lenc=length(cat250,250,10)
    call chop0(gra250,250)
    leng=length(gra250,250,10)
    write(ounit,'("# COMMAND: Rscript --vanilla ",A,X,A,X,A)',iostat=irc) &
         & cat250(1:lenc),tab250(1:lent),gra250(1:leng)
    !
    ! loop over set and write attributes and legend as comments
    !
    if(plot_bdeb)write(*,*)myname,'Writing attributes and legends.',ounit
    write(ounit,'("#")',iostat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Error writing to table file'.")
       call plot_errorappend(crc250,pss%tab250(1:pss%lent))
       return
    end if
    write(ounit,'("# TYPE:",A)',iostat=irc)pss%type250(1:pss%lenp)
    write(ounit,'("#")',iostat=irc)
    ! print attributes
    write(ounit,'("# ATTRIBUTES:",I0)',iostat=irc)pss%natt
    attr => pss%firstAttribute%next
    do while (.not.associated(attr,target=pss%lastAttribute))
       write(ounit,'("# ",A,":",A)',iostat=irc)&
            & attr%name80(1:attr%lenn),attr%value250(1:attr%lenv)
       attr => attr%next
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Error writing to Table file'.")
       call plot_errorappend(crc250,pss%tab250(1:pss%lent))
       return
    end if
    ! print legend table
    write(ounit,'("#")',iostat=irc)
    write(ounit,'("# LEGENDS:",I0)',iostat=irc) pss%nset
    do while (plot_loopset(pss,css,mss,oss,name80,ncol,col80,exp250,leg250,0,crc250,irc))
       call chop0(name80,80)
       lenn=length(name80,80,1)
       call chop0(leg250,250)
       lenl=length(leg250,250,1)
       if (plot_bdeb) write(*,*)myname,"Inside loopSet '"//name80(1:lenn)//"'"
       write(ounit,'("#",X,A,":",A)',iostat=irc)name80(1:lenn),leg250(1:lenl)
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopset'.")
       return
    end if
    ! print legend table
    write(ounit,'("#")',iostat=irc)
    write(ounit,'("# COLUMNS:",I0)',iostat=irc) ncol+1
    write(ounit,'("#",X,A,":",A)',iostat=irc) "set","id"
    do ii=1,ncol
       call chop0(col80(ii),80)
       lenc=length(col80(ii),80,1)
       call chop0(exp250(ii),80)
       lene=length(exp250(ii),80,1)
       write(ounit,'("#",X,A,":",A)',iostat=irc)col80(ii)(1:lenc),exp250(ii)(1:lene)
    end do
    if(plot_bdeb)write(*,*)myname,'Writing data.',ounit,ncol,size(col80),size(exp250)
    write(ounit,'("#")',iostat=irc)
    write(ounit,'("# Data table")',iostat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Error writing to Table file'.")
       call plot_errorappend(crc250,pss%tab250(1:pss%lent))
       return
    end if
    if (ncol.eq.0) then
       write(ounit,'(X,A)',iostat=irc)"set"
    else
       write(ounit,'(X,A)',iostat=irc,advance="no")"set"
    end if
    do ii=1,ncol
       lenc=length(col80(ii),80,1)
       if (ii.eq.ncol) then
          write(ounit,'(X,A)',iostat=irc)col80(ii)(1:lenc)
       else
          write(ounit,'(X,A)',iostat=irc,advance="no")col80(ii)(1:lenc)
       end if
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Error writing to Table file'.")
       call plot_errorappend(crc250,pss%tab250(1:pss%lent))
       return
    end if
    !
    if (allocated(var80)) deallocate(var80)
    if (allocated(col80)) deallocate(col80)
    if (allocated(exp250)) deallocate(exp250)
    !
  end subroutine plot_addComments
  !
  subroutine plot_setTime(pss,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_clearsetstack"
    !call date_and_time(VALUES=pss%values)
    call parse_date_and_time(pss%values)
    return
  end subroutine plot_setTime
  !
  subroutine plot_strepfiles(pss,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_strepfiles"
    integer,parameter  :: nn = 6
    character*100 :: src100(nn) = (/'YY','MM','DD','HH','MI','SS'/)
    character*100 :: rep100(nn)
    logical :: lrep(nn)
    call plot_settime(pss,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from settime.")
       call plot_errorappendi(crc250,irc)
       return
    end if
    !  values(1):	the year
    !  values(2):	the month
    !	values(3):	the day of the month
    !	values(4):	time difference with utc in minutes
    !	values(5):	the hour of the day
    !	values(6):	the minutes of the hour
    !	values(7):	the seconds of the minute
    !	values(8):	the milliseconds of the second
    write(rep100(1),'(i4.4)')pss%values(1)
    write(rep100(2),'(i2.2)')pss%values(2)
    write(rep100(3),'(i2.2)')pss%values(3)
    write(rep100(4),'(i2.2)')pss%values(5)
    write(rep100(5),'(i2.2)')pss%values(6)
    write(rep100(6),'(i2.2)')pss%values(7)
    if (pss%lent.ne.0)call plot_strep(pss%tab250,nn,src100,rep100,lrep,irc)
    if (pss%leng.ne.0)call plot_strep(pss%gra250,nn,src100,rep100,lrep,irc)
    return
  end subroutine plot_strepfiles
  !
  subroutine plot_setFiles(pss,tab250,gra250,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: tab250
    character*250 :: gra250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_strepfiles"
    integer,parameter  :: nn = 6
    call plot_setTablefile(pss,tab250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setTableFile.")
       return
    end if
    call plot_setGraphicsfile(pss,gra250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setGraphicsFile.")
       return
    end if
    call plot_strepfiles(pss,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from strepFiles.")
       return
    end if
    call plot_getTablefile(pss,tab250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setTableFile.")
       return
    end if
    call plot_getGraphicsfile(pss,gra250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setGraphicsFile.")
       return
    end if
    return
  end subroutine plot_setFiles
  !
  subroutine plot_setGraphicsfile(pss,gra250,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: gra250 ! name of graphics file
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    pss%gra250=gra250
    CALL CHOP0(pss%gra250,250)
    PSS%LENG=LENGTH(pss%gra250,250,10)
    return
  end subroutine plot_setGraphicsfile
  !
  subroutine plot_getGraphicsfile(pss,gra250,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: gra250 ! name of graphics file
    character*250 :: crc250
    integer :: irc
    integer, external :: length
    gra250=pss%gra250
    return
  end subroutine plot_getGraphicsfile
  !
  !###############################################################################
  ! SET ROUTINES
  !###############################################################################
  !
  subroutine plot_clearsetstack(pss,crc250,irc)
    implicit none
    type(plot_session), pointer :: pss !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_clearsetstack"
    type(plot_set), pointer :: cset,nset !  current set
    cset => pss%firstSet%next
    do while (.not.associated(cset,target=pss%lastSet))
       nset => cset%next
       call plot_unlinkSet(cset)
       call plot_deallocateSet(cset)
       pss%nset=pss%nset-1
       cset  => nset
    end do
    return
  end subroutine plot_clearsetstack
  !
  subroutine plot_unlinkSet(set)
    implicit none
    type(plot_set), pointer :: set !  current set
    set%prev%next => set%next
    set%next%prev => set%prev
    return
  end subroutine plot_unlinkSet
  !
  subroutine plot_allocateSet(set,crc250,irc)
    implicit none
    type(plot_set), pointer ::  set !  current set
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_allocateset"
    allocate(set,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'set'.")
       return
    end if
    allocate(set%firstObstrg,set%lastObstrg,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'set-obstrg'.")
       return
    end if
    set%firstObstrg%next => set%lastObstrg
    set%lastObstrg%prev => set%firstObstrg
    allocate(set%firstModtrg,set%lastModtrg,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'set-modtrg'.")
    end if
    set%firstModtrg%next => set%lastModtrg
    set%lastModtrg%prev => set%firstModtrg
    allocate(set%firstLoc,set%lastLoc,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'set-def'.")
    end if
    set%firstLoc%next => set%lastLoc
    set%lastLoc%prev => set%firstLoc
    allocate(set%firstMatch,set%lastMatch,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'set-match'.")
    end if
    set%firstMatch%next => set%lastMatch
    set%lastMatch%prev => set%firstMatch
    return
  end subroutine plot_allocateSet
  !
  subroutine plot_deallocateSet(set)
    implicit none
    type(plot_set), pointer :: set !  current set
    integer :: irc2
    character*250 :: crc250
    integer :: irc
    call plot_clearObstrgStack(set,crc250,irc)
    call plot_clearModtrgStack(set,crc250,irc)
    call plot_clearMatchStack(set,crc250,irc)
    deallocate(set,stat=irc2) ! ignore any errors
    return
  end subroutine plot_deallocateSet
  !
  subroutine plot_clearcolumn(pss,crc250,irc)
    type(plot_session), pointer :: pss !  current session
    character*250 :: crc250
    integer :: irc
    type(plot_column), pointer :: col, ncol
    character*22 :: myname="plot_clearcolumn"
    if(plot_bdeb)write(*,*)myname, 'Entering.',irc,&
         & associated(pss%firstColumn),associated(pss%lastColumn)
    col=>pss%firstColumn%next
    do while (.not.associated(col,target=pss%lastColumn))
       ncol=>col%next
       col%prev%next => col%next
       col%next%prev => col%prev
       deallocate(col)
       nullify(col)
       col=>ncol
    end do
    pss%ncol=0
    !pss%firstColumn%next=>pss%lastColumn
    !pss%lastColumn%prev=>pss%firstColumn
    !if(plot_bdeb)write(*,*)myname, 'Done.',irc
    return
  end subroutine plot_clearcolumn
  !
  subroutine plot_pushcolumn(pss,name80,exp250,crc250,irc)
    type(plot_session), pointer :: pss !  current session
    character*80 :: name80
    character*250 :: exp250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_pushcolumn"
    type(plot_column), pointer :: col
    integer, external :: length
    allocate(col,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'col'.")
       return
    end if
    col%name80=name80
    call chop0(col%name80,80)
    col%lenn=length(col%name80,80,10)
    col%exp250=exp250
    call chop0(col%exp250,250)
    col%lene=length(col%exp250,250,10)
    col%prev => pss%lastColumn%prev
    col%next => pss%lastColumn
    col%prev%next => col
    col%next%prev => col
    pss%ncol=pss%ncol+1
    return
  end subroutine plot_pushcolumn
  !
  subroutine plot_makeColumn(pss,set,crc250,irc) ! make set-column arrays
    type(plot_session), pointer :: pss !  current session
    type(plot_set), pointer     :: set !  current set
    character*250 :: crc250
    integer :: irc
    type(plot_column), pointer :: col
    integer :: ii
    character*22 :: myname="plot_makeColumn"
    if (allocated(set%col80)) deallocate(set%col80)
    if (allocated(set%col_lenn)) deallocate(set%col_lenn)
    if (allocated(set%col_exp250)) deallocate(set%col_exp250)
    if (allocated(set%col_lene)) deallocate(set%col_lene)
    if (pss%ncol > 0) then
       set%ccol=pss%ncol
       allocate(set%col80(set%ccol), &
            & set%col_lenn(set%ccol), &
            & set%col_exp250(set%ccol), &
            & set%col_lene(set%ccol), &
            & stat=irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250,"Unable to allocate 'set%col'.")
          return
       end if
       ii=0
       col=>pss%firstColumn%next
       do while (.not.associated(col,target=pss%lastColumn))
          ii=ii+1
          set%col80(ii)=col%name80
          set%col_lenn(ii)=col%lenn
          set%col_exp250(ii)=col%exp250
          set%col_lene(ii)=col%lene
          col=>col%next
       end do
    end if
    return
  end subroutine plot_makeColumn
  !
  subroutine plot_pushset(pss,css,mss,oss,name80,leg250,crc250,irc)
    use model
    use observations
    use colocation
    implicit none
    type(plot_session), pointer :: pss !  current session
    type(col_session), pointer ::  css !  current session
    type(mod_session), pointer ::  mss !  current session
    type(obs_session), pointer ::  oss !  current session
    character*80 :: name80
    character*250 leg250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_pushset"
    type(plot_set), pointer :: set !  current set
    if(plot_bdeb)write(*,*)myname,'Entering.',irc
    call plot_allocateSet(set,crc250,irc)
    set%name80=name80
    set%leg250=leg250
    if(plot_bdeb)write(*,*)myname,'Importing obs.',irc
    call plot_obsImport(set,oss,crc250,irc) ! get obs data 
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from obsImport.")
       return
    end if
    if(plot_bdeb)write(*,*)myname,'Importing model.',irc
    call plot_modImport(set,mss,crc250,irc) ! get model data
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from modImport.")
       return
    end if
    if(plot_bdeb)write(*,*)myname,'Importing colocation.',irc
    call plot_colImport(set,css,crc250,irc) ! get colocation data
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from colImport.")
       return
    end if
    call plot_makeColumn(pss,set,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from makeColumn.")
       return
    end if
    set%next => pss%lastSet
    set%prev => pss%lastSet%prev
    set%prev%next => set
    set%next%prev => set
    pss%nset=pss%nset+1
    nullify(set)
    !if(plot_bdeb)write(*,*)myname,'Exiting.',irc
    return
  end subroutine plot_pushset
  !
  ! loop over sets from top and delete them
  logical function plot_pullset(pss,css,mss,oss,name80,leg250,level,crc250,irc)
    use model
    use observations
    use colocation
    implicit none
    type(plot_session), pointer :: pss !  current session
    type(col_session), pointer ::  css !  current session
    type(mod_session), pointer ::  mss !  current session
    type(obs_session), pointer ::  oss !  current session
    character*80 :: name80
    character*250 :: leg250
    integer :: level
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_pullset"
    type(plot_set), pointer :: set !  current set
    plot_pullset=.false. ! only true if all is ok
    set => pss%firstSet%next
    if (.not.associated(set,target=pss%lastSet)) then
       name80=set%name80
       leg250=set%leg250
       call plot_obsExport(set,oss,crc250,irc) ! set obs data
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from obsExport.")
          return
       end if
       call plot_modExport(set,mss,crc250,irc) ! set model data
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from modExport.")
          return
       end if
       call plot_colExport(set,css,crc250,irc) ! set colocation data
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from colExport.")
          return
       end if
       if(plot_bdeb)write(*,*)myname,"Cleaning.",irc
       call plot_unlinkSet(set)       
       call plot_deallocateSet(set)
       plot_pullset=.true.
    end if
    if(plot_bdeb)write(*,*)myname,"Done.",irc
    return
  end function plot_pullset
  !
  ! loop over sets from bottom and delete them
  logical function plot_popset(pss,css,mss,oss,name80,leg250,crc250,irc)
    use model
    use observations
    use colocation
    implicit none
    type(plot_session), pointer :: pss !  current session
    type(col_session), pointer ::  css !  current session
    type(mod_session), pointer ::  mss !  current session
    type(obs_session), pointer ::  oss !  current session
    character*80 :: name80
    character*250 :: leg250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_popset"
    type(plot_set), pointer :: set !  current set
    plot_popset=.false. ! only true if all is ok and irc==0
    set => pss%lastSet%prev
    if (.not.associated(set,target=pss%firstSet)) then
       name80=set%name80
       leg250=set%leg250
       call plot_obsExport(set,oss,crc250,irc) ! set obs data
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from obsExport.")
          return
       end if
       call plot_modExport(set,mss,crc250,irc) ! set model data
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from modExport.")
          return
       end if
       call plot_colExport(set,css,crc250,irc) ! set colocation data
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from colExport.")
          return
       end if
       if(plot_bdeb)write(*,*)myname,"Cleaning.",irc
       call plot_unlinkSet(set)       
       call plot_deallocateSet(set)
       plot_popset=.true.
    end if
    if(plot_bdeb)write(*,*)myname,"Done.",irc
    return
  end function plot_popset
  !
  ! check that sets are comparable (TRUE=ok)
  logical function plot_checkSets(pss)
    implicit none
    type(plot_session), pointer :: pss !  current session
    type(plot_set),pointer :: cSet
    logical ::first
    first = .true.
    plot_checkSets=.false.
    if (.not.associated(pss)) return
    cSet => pss%firstSet%next
    do while (.not.associated(cSet,target=pss%lastSet))
       if (first) then
          first=.false.
       else if (.not.plot_checkObsTrg(pss%firstSet%next,cSet)) then
          if(plot_bdeb)write(*,*)'Obs targets differ.'
          return
       else if (pss%firstSet%next%category.ne.cSet%category) then
          if(plot_bdeb)write(*,*)'BUFR categories differ:',&
               & pss%firstSet%next%category,cSet%category
          return
       else if (pss%firstSet%next%subcategory.ne.cSet%subcategory) then
          if(plot_bdeb)write(*,*)'BUFR sub-categories differ:',&
               & pss%firstSet%next%subcategory,cSet%subcategory
          return
       end if
       cSet => cSet%next
    end do
    plot_checkSets=.true.
    return
  end function plot_checkSets
  !
  ! compare observation targets of the two sets (TRUE=ok)
  logical function plot_checkObsTrg(set1,set2)
    implicit none
    type(plot_set),pointer :: set1,set2
    type(plot_obstrg),pointer :: t1,t2
    integer :: ii
    plot_checkObsTrg=.false.
    t1 => set1%firstObsTrg%next
    t2 => set1%firstObsTrg%next
    ii=0
    do while (.not.associated(t1,set1%lastObsTrg))
       ii=ii+1
       if (t1%pos250.ne.t2%pos250) then
          if(plot_bdeb)write(*,*)'Positions differ.',ii
          return
       else if (t1%descr80.ne.t2%descr80) then
          if(plot_bdeb)write(*,*)'Descriptors differ.',ii
          return
       end if
       t1=>t1%next
       t2=>t2%next
    end do
    plot_checkObsTrg=.true.
    return
  end function plot_checkObsTrg
  !
  ! loop over sets from the top without deleting them...
  logical function plot_loopSet(pss,css,mss,oss,name80,ncol,col80,exp250,leg250,level,crc250,irc)
    use model
    use observations
    use colocation
    implicit none
    type(plot_session), pointer :: pss !  current session
    type(col_session), pointer ::  css !  current session
    type(mod_session), pointer ::  mss !  current session
    type(obs_session), pointer ::  oss !  current session
    character*80 :: name80
    integer :: ncol
    character*80, allocatable :: col80(:)
    character*250, allocatable :: exp250(:)
    character*250 :: leg250
    integer :: level
    character*250 :: crc250
    integer :: irc,ii
    integer :: lenn
    integer, external :: length
    character*22 :: myname="plot_loopSet"
    plot_loopset=.false. ! only true if all is ok
    if (.not.associated(pss%currentSet)) then
       pss%currentSet =>  pss%firstSet%next 
    else
       pss%currentSet =>  pss%currentSet%next
    end if
    if (associated(pss%currentSet,target=pss%lastSet)) then
       nullify(pss%currentSet)
       plot_loopset=.false.
    else
       name80=pss%currentSet%name80
       leg250=pss%currentSet%leg250
       if (level.ne.0) then
          if(plot_bdeb)then
             lenn=length(pss%currentSet%name80,80,10)
             write(*,*)myname,"Set '"//pss%currentSet%name80(1:lenn)//"'"
          end if
          call plot_obsExport(pss%currentSet,oss,crc250,irc) ! set obs data
          if (irc.ne.0) then
             call plot_errorappend(crc250,myname)
             call plot_errorappend(crc250," Error return from obsExport.")
             return
          end if
          call plot_modExport(pss%currentSet,mss,crc250,irc) ! set model data
          if (irc.ne.0) then
             call plot_errorappend(crc250,myname)
             call plot_errorappend(crc250," Error return from modExport.")
             return
          end if
          call plot_colExport(pss%currentSet,css,crc250,irc) ! set colocation data
          if (irc.ne.0) then
             call plot_errorappend(crc250,myname)
             call plot_errorappend(crc250," Error return from colExport.")
             return
          end if
          !
       end if
       if(plot_bdeb)write(*,*)myname,"Make columns.",pss%currentSet%ccol,allocated(col80)
       ncol=pss%currentSet%ccol
       if (.not.allocated(col80).or..not.allocated(exp250).or.&
            & pss%currentSet%ccol > size(col80).or.pss%currentSet%ccol > size(exp250)) then
          if (allocated(col80)) deallocate(col80)
          if (allocated(exp250)) deallocate(exp250)
          if(plot_bdeb)write(*,*)myname,"Allocating columns.",ncol
          allocate(col80(ncol),exp250(ncol),stat=irc)
          if (irc.ne.0) then
             call plot_errorappend(crc250,myname)
             call plot_errorappend(crc250," Unable to allocate columns.")
             return
          end if
       end if
       if(plot_bdeb)write(*,*)myname,"Assigning columns.",ncol,&
            & allocated(col80),allocated(exp250),size(col80),size(exp250)
       do ii=1,ncol
          col80(ii)=pss%currentSet%col80(ii)
          exp250(ii)=pss%currentSet%col_exp250(ii)
       end do
       if (plot_bdeb)write(*,*)myname,'Columns:',ncol,size(col80),size(exp250)
       !
       plot_loopset=.true.
    end if
    if(plot_bdeb)write(*,*)myname,"Done.",plot_loopset
    return
  end function plot_loopSet
  !
  !###############################################################################
  ! SUB DATA ROUTINES (OBS-, MODEL-, MATCH-TARGET)
  !###############################################################################
  !
  !
  subroutine plot_clearobstrgstack(set,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_clearobstrgstack"
    type(plot_obstrg), pointer :: ctrg,ntrg !  current target
    ctrg => set%firstObstrg%next
    do while (.not.associated(ctrg,target=set%lastObstrg))
       ntrg => ctrg%next
       call plot_unlinkObstrg(ctrg)
       set%nObsTrg=set%nObsTrg-1
       call plot_deallocateObstrg(ctrg)
       ctrg  => ntrg
    end do
    nullify(set%cobstrg)
    return
  end subroutine plot_clearobstrgstack
  !
  subroutine plot_clearmodtrgstack(set,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_clearmodtrgstack"
    type(plot_modtrg), pointer :: ctrg,ntrg !  current target
    ctrg => set%firstModtrg%next
    do while (.not.associated(ctrg,target=set%lastModtrg))
       ntrg => ctrg%next
       call plot_unlinkModtrg(ctrg)
       set%nModTrg=set%nModTrg-1
       call plot_deallocateModtrg(ctrg)
       ctrg  => ntrg
    end do
    nullify(set%cmodtrg)
    return
  end subroutine plot_clearmodtrgstack
  !
  subroutine plot_clearmatchstack(set,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_clearmatchstack"
    type(plot_match), pointer :: cmatch,nmatch !  current target
    cmatch => set%firstMatch%next
    do while (.not.associated(cmatch,target=set%lastMatch))
       nmatch => cmatch%next
       call plot_unlinkMatch(cmatch)
       call plot_deallocateMatch(cmatch)
       set%nmatch=set%nmatch-1
       cmatch  => nmatch
    end do
    nullify(set%cmatch)
    return
  end subroutine plot_clearmatchstack
  !
  ! clear the default stack
  !
  subroutine plot_cleardefaultStack(set,crc250,irc) 
    type(plot_set), pointer :: set !  current session
    character*250 :: crc250
    integer :: irc
    type(plot_location), pointer :: cLoc !  the current default target
    type(plot_location), pointer :: nLoc !  the next default target
    character*25 :: myname="plot_cleardefaultStack"
    if (plot_bdeb) write(*,*)myname,'Entering.',associated(set), associated(set%firstLoc)
    cLoc => set%firstLoc%next
    do while (.not.associated(cLoc,target=set%lastLoc))
       nLoc => cLoc%next
       cLoc%prev%next =>  cLoc%next
       cLoc%next%prev =>  cLoc%prev
       deallocate(cLoc,stat=irc)
       cLoc => nLoc
    end do
    set%ndef=0
    if (plot_bdeb) write(*,*)myname,'Exiting.',irc
    return
  end subroutine plot_cleardefaultStack
  !
  subroutine plot_unlinkObstrg(trg)
    implicit none
    type(plot_obstrg), pointer :: trg !  current target
    trg%prev%next => trg%next
    trg%next%prev => trg%prev
    return
  end subroutine plot_unlinkObstrg
  !
  subroutine plot_unlinkModtrg(trg)
    implicit none
    type(plot_modtrg), pointer :: trg !  current target
    trg%prev%next => trg%next
    trg%next%prev => trg%prev
    return
  end subroutine plot_unlinkModtrg
  !
  subroutine plot_unlinkMatch(match)
    implicit none
    type(plot_match), pointer :: match !  current target
    match%prev%next => match%next
    match%next%prev => match%prev
    return
  end subroutine plot_unlinkMatch
  !
  subroutine plot_unlinkDefault(def)
    implicit none
    type(plot_default), pointer :: def !  current target
    def%prev%next => def%next
    def%next%prev => def%prev
    return
  end subroutine plot_unlinkDefault
  !
  subroutine plot_pushobstrg(set,trg80,pos250,descr80,info250,min80,max80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80 :: trg80      ! target name
    character*250 :: pos250    ! position/sequence number
    character*80 :: descr80    ! descriptor
    character*250 :: info250   ! information
    character*80 :: min80      ! min value
    character*80 :: max80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_pushobstrg"
    type(plot_obstrg), pointer :: trg !  current target
    allocate(trg,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'obstrg'.")
    end if
    trg%trg80=trg80
    trg%pos250=pos250
    trg%descr80=descr80
    trg%info250=info250
    trg%min80=min80
    trg%max80=max80
    trg%next => set%lastObstrg
    trg%prev => set%lastObstrg%prev
    set%nObsTrg=set%nObsTrg+1
    trg%prev%next => trg
    trg%next%prev => trg
    nullify(trg)
    return
  end subroutine plot_pushobstrg
  !
  subroutine plot_pushmodtrg(set,trg80,var80,min80,max80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80 :: trg80      ! target name
    character*80 :: var80    ! descriptor
    character*80 :: min80      ! min value
    character*80 :: max80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_pushmodtrg"
    type(plot_modtrg), pointer :: trg !  current target
    allocate(trg,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'modtrg'.")
    end if
    trg%trg80=trg80
    trg%var80=var80
    trg%min80=min80
    trg%max80=max80
    trg%next => set%lastModtrg
    trg%prev => set%lastModtrg%prev
    set%nModTrg=set%nModTrg+1
    trg%prev%next => trg
    trg%next%prev => trg
    nullify(trg)
    return
  end subroutine plot_pushmodtrg
  !
  integer function plot_countModTrg(set)
    type(plot_set),pointer :: set
    plot_countModTrg=set%nModTrg
    return
  end function plot_countModTrg
  !
  integer function plot_countObsTrg(set)
    type(plot_set),pointer :: set
    plot_countObsTrg=set%nObsTrg
    return
  end function plot_countObsTrg
  !
  subroutine plot_pushmatch(set,n80,e250,l80,u80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80 :: n80      ! target name
    character*250 :: e250    ! position/sequence number
    character*80 :: l80      ! lower
    character*80 :: u80      ! upper
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_pushmatch"
    integer :: lenn
    integer, external :: length
    type(plot_match), pointer :: trg !  current target
    allocate(trg,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'match'.")
    end if
    trg%n80=n80
    trg%e250=e250
    trg%l80=l80
    trg%u80=u80
    trg%next => set%lastMatch
    trg%prev => set%lastMatch%prev
    trg%prev%next => trg
    trg%next%prev => trg
    set%nmatch=set%nmatch+1
    if (plot_bdeb)then
       lenn=length(n80,80,10)
       write(*,*)myname,' Adding:',n80(1:lenn)
    end if
    nullify(trg)
    return
  end subroutine plot_pushmatch
  !
  ! add default element
  !
  subroutine plot_addDefault(set,n80,v80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80 :: n80 ! target name
    character*80 :: v80 ! target value
    character*250 :: crc250
    integer :: irc
    integer :: ii, irc2, lenv, lenn
    type(plot_default),pointer :: newdef
    integer, external :: length
    character*25 :: myname="colocation_addDefault"
    if(plot_bdeb)write(*,*)myname,'Entering.',associated(set%currentLoc),irc
    allocate(newdef,stat=irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250,"Unable to allocate 'newdef'.")
       call plot_errorappend(crc250,"\n")
       return
    end if
    newdef%n80=n80
    call chop0(newdef%n80,80)
    newdef%lenn=length(newdef%n80,80,10)
    newdef%v80=v80
    call chop0(newdef%v80,80)
    newdef%lenv=length(newdef%v80,80,10)
    if(plot_bdeb)write(*,*)myname," Assigning: '"//newdef%n80(1:newdef%lenn)//&
         & "' -> '"//newdef%v80(1:newdef%lenv)//"'"
    if (.not.associated(set%currentLoc)) then
       if(plot_bdeb)write(*,*)myname,'New Default.'
       allocate(set%currentLoc, stat=irc)
       set%currentLoc%next => set%lastLoc
       set%currentLoc%prev => set%lastLoc%prev
       set%lastLoc%prev%next => set%currentLoc
       set%lastLoc%prev => set%currentLoc
       allocate(set%currentLoc%firstDef,set%currentLoc%lastDef, stat=irc) ! 
       set%currentLoc%firstDef%next => set%currentLoc%lastDef
       set%currentLoc%lastDef%prev => set%currentLoc%firstDef
       set%ndef=set%ndef+1
    end if
    if(plot_bdeb)write(*,*)myname,'Adding default.'
    newdef%next => set%currentLoc%lastDef
    newdef%prev => set%currentLoc%lastDef%prev
    set%currentLoc%lastDef%prev%next => newdef
    set%currentLoc%lastDef%prev => newdef
    if(plot_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine plot_addDefault
  !
  subroutine plot_maketargetlist(set,crc250,irc)
    type(plot_set), pointer :: set !  current session
    character*250 :: crc250
    integer :: irc
    character*25 :: myname="plot_maketargetlist"
    type(plot_modtrg), pointer :: cTrg
    integer ii,lens,irc2
    integer, external :: length
    if(plot_bdeb)write(*,*)myname,'Entering.',irc
    set%nTrgMod=0
    cTrg => set%firstModTrg%next
    do while (.not.associated(cTrg,target=set%lastModTrg))
       set%nTrgMod=set%nTrgMod+1
       cTrg => cTrg%next
    end do
    if(associated(set%trgMod80)) deallocate(set%trgMod80)
    if(associated(set%trgModLent)) deallocate(set%trgModLent)
    if (set%nTrgMod.ne.0) then
       allocate(set%trgMod80(set%nTrgMod), set%trgModLent(set%nTrgMod), stat=irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250,"Unable to allocate 'session:trg...'.")
          call plot_errorappend(crc250,"\n")
          return
       end if
       ii=0
       cTrg => set%firstModTrg%next
       do while (.not.associated(cTrg,target=set%lastModTrg))
          ii=min(set%nTrgMod,ii+1)
          set%trgMod80(ii)=cTrg%trg80
          call chop0(set%trgMod80(ii),80)
          set%trgmodlent(ii)=length(set%trgMod80(ii),80,10)
          cTrg => cTrg%next
       end do
    end if
    set%trgModSet=.true.
    if(plot_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine plot_maketargetlist
  !
  ! push default values to the stack
  !
  subroutine plot_pushDefault(set,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*250 :: crc250
    integer :: irc
    type(plot_location), pointer :: newLoc
    character*25 :: myname="plot_pushDefault"
    if(plot_bdeb)write(*,*)myname,'Entering.',irc
    if (.not.associated(set %firstLoc)) then
       allocate(set%firstLoc,set%lastLoc, stat=irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250,"Unable to allocate 'firstDef/lastDef'.")
          call plot_errorappend(crc250,"\n")
          return
       end if
       set%firstLoc%next => set%lastLoc
       set%lastLoc%prev => set%firstLoc
       set%ndef=0
    end if
    if (associated(set%currentLoc)) then
       nullify(set%currentLoc)
    end if
    if(plot_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine plot_pushDefault
  !
  logical function plot_popobstrg(set,trg80,pos250,descr80,info250,min80,max80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80  :: trg80      ! target name
    character*250 :: pos250    ! position/sequence number
    character*80  :: descr80    ! descriptor
    character*250 :: info250   ! information
    character*80  :: min80      ! min value
    character*80  :: max80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_popobstrg"
    type(plot_obstrg), pointer :: trg,ntrg !  current trg
    plot_popobstrg=.false. ! only true if all is ok
    trg => set%lastObstrg%prev
    if (.not.associated(trg,set%firstObstrg)) then
       ntrg=>trg%next
       trg80=trg%trg80
       pos250=trg%pos250
       descr80=trg%descr80
       info250=trg%info250
       min80=trg%min80
       max80=trg%max80
       call plot_unlinkObstrg(trg)
       set%nObsTrg=set%nObsTrg-1
       trg=>ntrg
       plot_popobstrg=.true.
    end if
    return
  end function plot_popobstrg
  !
  logical function plot_popmodtrg(set,trg80,var80,min80,max80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80  :: trg80      ! target name
    character*80  :: var80    ! descriptor
    character*80  :: min80      ! min value
    character*80  :: max80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_popmodtrg"
    type(plot_modtrg), pointer :: trg,ntrg !  current trg
    plot_popmodtrg=.false. ! only true if all is ok
    trg => set%lastModtrg%prev
    if (.not.associated(trg,set%firstModtrg)) then
       ntrg=>trg%next
       trg80=trg%trg80
       var80=trg%var80
       min80=trg%min80
       max80=trg%max80
       call plot_unlinkModtrg(trg)
       set%nModTrg=set%nModTrg-1
       trg=>ntrg
       plot_popmodtrg=.true.
    end if
    return
  end function plot_popmodtrg
  !
  logical function plot_popmatch(set,n80,e250,l80,u80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80  :: n80      ! target name
    character*250 :: e250    ! observation expression
    character*80  :: l80      ! lower
    character*80  :: u80      ! upper
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_popmatch"
    type(plot_match), pointer :: trg,ntrg !  current trg
    plot_popmatch=.false. ! only true if all is ok
    trg => set%lastMatch%prev
    if (.not.associated(trg,set%firstMatch)) then
       ntrg=>trg%next
       n80=trg%n80
       e250=trg%e250
       l80=trg%l80
       u80=trg%u80
      call plot_unlinkMatch(trg)
       trg=>ntrg
       plot_popmatch=.true.
       set%nmatch=set%nmatch-1
    end if
    return
  end function plot_popmatch
  !
  logical function plot_loopobstrg(set,trg80,pos250,descr80,info250,min80,max80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80  :: trg80      ! target name
    character*250 :: pos250    ! position/sequence number
    character*80  :: descr80    ! descriptor
    character*250 :: info250   ! information
    character*80  :: min80      ! min value
    character*80  :: max80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_loopobstrg"
    plot_loopobstrg=.false. ! only true if all is ok
    if (.not.associated(set%cobstrg)) then
       set%cobstrg =>  set%firstObstrg%next 
    else
       set%cobstrg =>  set%cobstrg%next
    end if
    if (associated(set%cobstrg,target=set%lastObstrg)) then
       nullify(set%cobstrg)
       plot_loopobstrg=.false.
    else
       trg80=set%cobstrg%trg80
       pos250=set%cobstrg%pos250
       descr80=set%cobstrg%descr80
       info250=set%cobstrg%info250
       min80=set%cobstrg%min80
       max80=set%cobstrg%max80
       plot_loopobstrg=.true.
    end if
    return
  end function plot_loopobstrg
  !
  logical function plot_loopmodtrg(set,trg80,var80,min80,max80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80  :: trg80      ! target name
    character*80  :: var80    ! descriptor
    character*80  :: min80      ! min value
    character*80  :: max80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_loopmodtrg"
    !if (plot_bdeb) write(*,*)myname,' Entering.',irc
    plot_loopmodtrg=.false. ! only true if all is ok
    if (.not.associated(set%cmodtrg)) then
       set%cmodtrg =>  set%firstModtrg%next 
    else
       set%cmodtrg =>  set%cmodtrg%next
    end if
    if (associated(set%cmodtrg,target=set%lastModtrg)) then
       nullify(set%cmodtrg)
       plot_loopmodtrg=.false.
    else
       trg80=set%cmodtrg%trg80
       var80=set%cmodtrg%var80
       min80=set%cmodtrg%min80
       max80=set%cmodtrg%max80
       plot_loopmodtrg=.true.
    end if
    !if (plot_bdeb) write(*,*)myname,' Done.',plot_loopmodtrg
    return
  end function plot_loopmodtrg
  !
  logical function plot_loopLocation(set,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_loopLocation"
    if (plot_bdeb) write(*,*)myname,'Entering.',irc
    plot_loopLocation=.false. ! only true if all is ok
    if (.not.associated(set%cLoc)) then
       set%cLoc =>  set%firstLoc%next 
    else
       set%cLoc =>  set%cLoc%next
    end if
    if (associated(set%cLoc,target=set%lastLoc)) then
       nullify(set%cLoc)
       plot_loopLocation=.false.
    else
       plot_loopLocation=.true.
    end if
    return
  end function plot_loopLocation
  !
  logical function plot_loopDefault(set,n80,v80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80  :: n80      ! target name
    character*80  :: v80      ! variable
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_loopdefitem"
    if (plot_bdeb) write(*,*)myname,'Entering.',irc
    plot_loopDefault=.false. ! only true if all is ok
    if (.not.associated(set%cLoc%cDef)) then
       set%cLoc%cDef =>  set%cLoc%firstDef%next 
    else
       set%cLoc%cDef =>  set%cLoc%cDef%next
    end if
    if (associated(set%cLoc%cDef,target=set%cLoc%lastDef)) then
       nullify(set%cLoc%cDef)
       plot_loopDefault=.false.
    else
       plot_loopDefault=.true.
       n80=set%cLoc%cDef%n80
       v80=set%cLoc%cDef%v80
    end if
    return
  end function plot_loopDefault
  !
  logical function plot_loopmatch(set,n80,e250,l80,u80,crc250,irc)
    implicit none
    type(plot_set), pointer :: set !  current session
    character*80  :: n80      ! target name
    character*250 :: e250   ! information
    character*80  :: l80      ! min value
    character*80  :: u80      ! max value
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_loopmatch"
    plot_loopmatch=.false. ! only true if all is ok
    if (.not.associated(set%cmatch)) then
       set%cmatch =>  set%firstMatch%next 
    else
       set%cmatch =>  set%cmatch%next
    end if
    if (associated(set%cmatch,target=set%lastMatch)) then
       nullify(set%cmatch)
       plot_loopmatch=.false.
    else
       n80=set%cmatch%n80
       e250=set%cmatch%e250
       l80=set%cmatch%l80
       u80=set%cmatch%u80
       plot_loopmatch=.true.
    end if
    return
  end function plot_loopmatch
  !
  subroutine plot_deallocateObstrg(trg)
    implicit none
    type(plot_obstrg), pointer :: trg !  current target
    integer :: irc2
    deallocate(trg,stat=irc2) ! ignore any errors
    return
  end subroutine plot_deallocateObstrg
  !
  subroutine plot_deallocateModtrg(trg)
    implicit none
    type(plot_modtrg), pointer :: trg !  current target
    integer :: irc2
    deallocate(trg,stat=irc2) ! ignore any errors
    return
  end subroutine plot_deallocateModtrg
  !
  subroutine plot_deallocateMatch(match)
    implicit none
    type(plot_match), pointer :: match !  current target
    integer :: irc2
    deallocate(match,stat=irc2) ! ignore any errors
    return
  end subroutine plot_deallocateMatch
  !
  subroutine plot_obsImport(set,oss,crc250,irc) ! get obs data
    use observations
    implicit none
    type(plot_set), pointer :: set
    type(obs_session), pointer :: oss
    character*250 :: crc250
    integer :: irc
    character*80 :: trg80,descr80,min80,max80
    character*250 :: pos250,info250
    character*22 :: myname="plot_obsImport"
    call observation_getTablePath(oss,set%tablepath,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from getTablePath.")
       return
    end if
    call observation_getBufrType(oss,set%category,set%subCategory,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from getBufrType.")
       return
    end if
    call observation_getIndex(oss,set%ind_obs80,set%ind_exp250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from getIndex.")
       return
    end if
    call observation_getIndexLimitsRaw(oss,set%ind,set%ind_start,set%ind_stop)
    ! cache file is stored in colocation-module
    call plot_clearObstrgStack(set,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearObstrgStack.")
       return
    end if
    do while (observation_loopTarget(oss,trg80,pos250,descr80,info250,min80,max80,crc250,irc))
       call plot_pushobstrg(set,trg80,pos250,descr80,info250,min80,max80,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from pushobstrg.")
          return
       end if
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopTarget.")
       return
    end if
    call observation_getfilter(oss,set%fltobs250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from getobsfilter.")
       return
    end if
    return
  end subroutine plot_obsImport
  !
  subroutine plot_obsExport(set,oss,crc250,irc) ! set obs data
    use observations
    implicit none
    type(plot_set), pointer :: set
    type(obs_session), pointer :: oss
    integer :: cnt
    logical :: bex
    character*250 :: crc250
    integer :: irc
    character*80 :: trg80,descr80,min80,max80
    character*250 :: pos250,info250
    integer :: lenn
    integer, external :: length
    character*22 :: myname="plot_obsExport"
    if (plot_countObsTrg(set).eq.0) return ! no targets = nothing to do
    call observation_setTablePath(oss,set%tablepath,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setTablePath.")
       return
    end if
    call observation_setBufrType(oss,set%category,set%subCategory,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setBufrType.")
       return
    end if
    call observation_setIndex(oss,set%ind_obs80,set%ind_exp250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setIndex.")
       return
    end if
    call observation_setIndexLimitsRaw(oss,set%ind,set%ind_start,set%ind_stop)
    call observation_loadCache(oss,set%obs250,crc250,irc) ! stored in colocation module
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loadCache.")
       return
    end if
    call observation_clearTargetStack(oss,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearTargetStack.")
       return
    end if
    do while (plot_loopObstrg(set,trg80,pos250,descr80,info250,min80,max80,crc250,irc))
       if (plot_bdeb) then
          lenn=length(trg80,80,10)
          write(*,*)myname,"Inside loopObsTrg '"//trg80(1:lenn)//"'"
       end if
       call observation_pushtarget(oss,trg80,pos250,descr80,info250,min80,max80,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from pushtarget.")
          return
       end if
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopObstrg.")
       return
    end if
    call observation_makeTargetList(oss,crc250,irc) ! make target list from target chain
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from makeTargetList.")
       return
    end if
    cnt = observation_targetCount(oss,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from targetCount.")
       return
    end if
    bex= observation_hasValidIndex(oss,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from hasValidIndex.")
       return
    end if
    call observation_setfilter(oss,set%fltobs250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setfilter.")
       return
    end if
    return
  end subroutine plot_obsExport
  !
  subroutine plot_modImport(set,mss,crc250,irc) ! get model data
    use model
    implicit none
    type(plot_set), pointer :: set
    type(mod_session), pointer :: mss
    character*250 :: crc250
    integer :: irc
    character*80  :: n80       ! target name
    character*80  :: v80       ! variable
    character*80  :: l80      ! min value
    character*80  :: u80      ! max value
    character*22 :: myname="plot_modImport"
    if (plot_bdeb) write(*,*)myname,'Entering.',irc
    call model_getIndex(mss,set%ind_trg80,set%ind_mod80,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from getIndex.")
       return
    end if
    if (plot_bdeb) write(*,*)myname,'Get target stack.',irc
    call plot_clearModTrgStack(set,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearModTrgStack.")
       return
    end if
    do while (model_loopTarget(mss,n80,v80,l80,u80,crc250,irc))
       call plot_pushModtrg(set,n80,v80,l80,u80,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from pushModtrg.")
          return
       end if
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopTarget.")
       return
    end if
    call model_getfilter(mss,set%fltmod250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from getfilter.")
       return
    end if
    if (plot_bdeb) write(*,*)myname,'Done.',irc
    return
  end subroutine plot_modImport
  !
  subroutine plot_modExport(set,mss,crc250,irc) ! set model data
    use model
    implicit none
    type(plot_set), pointer :: set
    type(mod_session), pointer :: mss
    character*250 :: crc250
    integer :: irc
    character*80 :: n80,v80,l80,u80
    integer :: lenn
    integer, external :: length
    character*22 :: myname="plot_modExport"
    if (plot_countModTrg(set).eq.0) return ! no targets = nothing to do
    call model_setIndex(mss,set%ind_trg80,set%ind_mod80,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setIndex.")
       return
    end if
    call model_loadCache(mss,set%mod250,crc250,irc) ! stored in colocation module
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loadCache.")
       return
    end if
    !
    call model_clearTargetStack(mss,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearTargetStack.")
       return
    end if
    do while (plot_loopModTrg(set,n80,v80,l80,u80,crc250,irc))
       if (plot_bdeb) then
          lenn=length(n80,80,10)
          write(*,*)myname,"Inside loopModTrg '"//n80(1:lenn)//"'"
       end if
       call model_pushTarget(mss,n80,v80,l80,u80,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from pushTarget.")
          return
       end if
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopModTrg.")
       return
    end if
    call model_setfilter(mss,set%fltmod250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from setfilter.")
       return
    end if
    !
    return
  end subroutine plot_modExport
  !
  subroutine plot_colImport(set,css,crc250,irc) ! get colocation data
    use colocation
    implicit none
    type(plot_set), pointer :: set
    type(col_session), pointer :: css
    character*250 :: path250
    character*250 :: crc250
    integer :: irc
    character*80 :: n80,v80,l80,u80
    character*250 :: e250
    integer, external :: length
    integer :: leno,lenn
    character*22 :: myname="plot_colImport"
    if (plot_bdeb) write(*,*)myname,'Entering.'
    call colocation_getmodcache(css,set%mod250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from getmodcache.")
       return
    end if
    call colocation_getobscache(css,set%obs250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from getobscache.")
       return
    end if
    if (plot_bdeb) then
       leno=length(set%obs250,250,10)
       write(*,*)myname,"Get default stack '"//set%obs250(1:leno)//"'",irc
    end if
    call plot_clearDefaultStack(set,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearDefaultStack.")
       return
    end if
    if (plot_bdeb)write(*,*)myname,'Looping over default.'
    do while (colocation_loopLocation(css,crc250,irc))
       do while (colocation_loopDefault(css,n80,v80,crc250,irc))
          if (plot_bdeb) then
             lenn=length(n80,80,10)
             write(*,*)myname,"Inside loopDefault '"//n80(1:lenn)//"'"
          end if
          call plot_addDefault(set,n80,v80,crc250,irc)
          if (irc.ne.0) then
             call plot_errorappend(crc250,myname)
             call plot_errorappend(crc250," Error return from addDefault.")
             return
          end if
       end do
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from loopDefaultItem.")
          return
       end if
       call plot_pushDefault(set,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from pushDefault.")
          return
       end if
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopDefault.")
       return
    end if
    if (plot_bdeb) write(*,*)myname,'Get match stack.',irc
    call plot_clearMatchStack(set,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearMatchStack.")
       return
    end if
    if (plot_bdeb) write(*,*)myname,'Starting match loop.',irc
    do while (colocation_loopMatch(css,n80,e250,l80,u80,crc250,irc))
       if (plot_bdeb) then
          lenn=length(n80,80,10)
          write(*,*)myname,"Inside loopMatch '"//n80(1:lenn)//"'"
       end if
       call plot_pushMatch(set,n80,e250,l80,u80,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from pushMatch.")
          return
       end if
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopMatch.")
       return
    end if
    call colocation_clearDefaultStack(css,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearDefaultStack.")
       return
    end if
    call colocation_clearMatchStack(css,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearMatchStack.")
       return
    end if
    return
  end subroutine plot_colImport
  !
  subroutine plot_colExport(set,css,crc250,irc) ! set colocation data
    use colocation
    use model
    use observations
    implicit none
    type(plot_set), pointer :: set
    type(col_session), pointer :: css
    character*250 :: crc250
    integer :: irc
    character*80 :: n80,v80,l80,u80
    character*250 :: e250
    integer :: lenn
    integer, external :: length
    character*22 :: myname="plot_colExport"
    if (plot_bdeb) write(*,*)myname,'Entering.'
    call colocation_clearDefaultStack(css,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearDefaultStack.")
       return
    end if
    call colocation_clearMatchStack(css,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from clearMatchStack.")
       return
    end if
    if (plot_bdeb) write(*,*)myname,'Looping defaults.'
    do while (plot_loopLocation(set,crc250,irc))
       do while (plot_loopDefault(set,n80,v80,crc250,irc))
          if (plot_bdeb) then
             lenn=length(n80,80,10)
             write(*,*)myname,"Inside loopDeafult '"//n80(1:lenn)//"'"
          end if
          call colocation_addDefault(css,n80,v80,crc250,irc)
          if (irc.ne.0) then
             call plot_errorappend(crc250,myname)
             call plot_errorappend(crc250," Error return from addDefault.")
             return
          end if
       end do
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from loopDefault.")
          return
       end if
       call colocation_pushDefault(css,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from pushDefault.")
          return
       end if
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopLocation.")
       return
    end if
    !
    if(plot_bdeb)write(*,*)myname,"Setting colocation match."
    do while (plot_loopMatch(set,n80,e250,l80,u80,crc250,irc))
       if (plot_bdeb) then
          lenn=length(n80,80,10)
          write(*,*)myname,"Inside loopMatch '"//n80(1:lenn)//"'",set%nmatch
       end if
       call colocation_pushMatch(css,n80,e250,l80,u80,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from pushMatch.")
          return
       end if
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopMatch.")
       return
    end if
    if(plot_bdeb)write(*,*)myname,"Done.",irc
    !
    return
  end subroutine plot_colExport
  !
  !
  !###############################################################################
  ! OUTPUT ROUTINES
  !###############################################################################
  !
  !
  subroutine plot_maketable(pss,css,mss,oss,tab250,gra250,cat250,test,fill250,crc250,irc)
    use model
    use observations
    use colocation
    use parse
    implicit none
    type(plot_session), pointer :: pss !  current session
    type(col_session), pointer ::  css !  current session
    type(mod_session), pointer ::  mss !  current session
    type(obs_session), pointer ::  oss !  current session
    integer :: cid,mid,oid
    character*250 :: tab250,gra250,cat250
    integer :: test
    character*250 :: fill250
    character*250 :: crc250
    integer :: irc
    character*22 :: myname="plot_maketable"
    integer :: ounit, ocnt
    character*250 :: leg250
    character*80 :: name80
    integer, external :: length
    integer :: lenc,lene,lenn,lenl,lent,leng
    integer :: ii,jj
    integer :: ncol
    integer :: lcnt
    character*80, allocatable :: col80(:)
    character*250, allocatable :: exp250(:)
    !
    if(plot_bdeb)write(*,*)myname,'Entering.',irc
    !
    ! open table file
    call plot_openFile(pss,ounit,tab250,lent,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," unable to open "//tab250(1:lent))
       call plot_errorappendi(crc250,irc)
       call plot_errorappend(crc250,"\n")
       return
    end if
    ocnt=0;
    !
    call plot_addComments(pss,css,mss,oss,ounit,tab250,lent,gra250,cat250,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from makecomments.")
       call plot_errorappendi(crc250,irc)
       call plot_errorappend(crc250,"\n")
       return
    end if
    ! close table output file unit, ounit
    call plot_closeFile(pss,ounit,tab250,lent,crc250,irc)
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," unable to close "//tab250(1:lent))
       call plot_errorappendi(crc250,irc)
       call plot_errorappend(crc250,"\n")
       return
    end if
    !
    if(plot_bdeb)then
       if (plot_checkSets(pss))then
          write(*,*)myname,'Observation targets differ...'
       end if
    end if
    lcnt=0
    do while (plot_loopset(pss,css,mss,oss,name80,ncol,col80,exp250,leg250,1,crc250,irc))
       call observation_resetStat(oss,crc250,irc)
       call model_resetStat(mss,crc250,irc)
       lcnt=lcnt+1
       !if (lcnt.eq.2) mod_bdeb=.true.
       !parse_bdeb=mod_bdeb
       !if (plot_bdeb) then
       lenn=length(name80,80,10)
       write(*,*)myname,"Processing set '"//name80(1:lenn)//"'"
       !end if
       ! append table file
       call plot_openFileApp(pss,ounit,tab250,lent,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," unable to append "//tab250(1:lent))
          call plot_errorappendi(crc250,irc)
          call plot_errorappend(crc250,"\n")
          return
       end if
       ! make output data for this set
       irc=0
       if(plot_bdeb)write(*,*)myname,'Making table.',ounit,ncol,size(col80),size(exp250)
       call colocation_makeTable(css,mss,oss,ounit,ocnt,name80,ncol,col80,&
            & exp250,leg250,test,fill250,crc250,irc)
       if (irc.ne.0) then
          call chop0(name80,80)
          lenn=length(name80,80,10)
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," Error return from makeOutput.")
          call plot_errorappend(crc250,name80(1:lenn))
          return
       end if
       ! close table output file unit, ounit
       call plot_closeFile(pss,ounit,tab250,lent,crc250,irc)
       if (irc.ne.0) then
          call plot_errorappend(crc250,myname)
          call plot_errorappend(crc250," unable to close "//tab250(1:lent))
          call plot_errorappendi(crc250,irc)
          call plot_errorappend(crc250,"\n")
          return
       end if
       call model_printFStat(mss,crc250,irc)
       call observation_printStat(oss,crc250,irc)
       call model_printLStat(mss,crc250,irc)
    end do
    if (irc.ne.0) then
       call plot_errorappend(crc250,myname)
       call plot_errorappend(crc250," Error return from loopset.")
       return
    end if
    !
    if (irc.ne.0) irc=0 ! oh well...
    !
    if (allocated(col80)) deallocate(col80)
    if (allocated(exp250)) deallocate(exp250)
    !
    write(*,'(X,A,I0,A)') myname,ocnt," locations written to table file "//tab250(1:lent)
    if(plot_bdeb)write(*,*)myname,'Done.',irc
    return
  end subroutine plot_maketable
  !
  !###############################################################################
  ! ERROR ROUTINES
  !###############################################################################
  !
  !
  subroutine plot_errorappend(crc250,string)
    implicit none
    character*250 :: crc250
    character*(*) :: string
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    lenb=len(trim(string))
    buff250=string(1:lenb)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//" "//buff250(1:min(250-lenc-1,lenb))
    end if
    call chop0(crc250,250)
  end subroutine plot_errorappend
  subroutine plot_errorappendi(crc250,inum)
    implicit none
    character*250 :: crc250
    integer :: inum
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    write(buff250,'(I12)')inum
    call chop0(buff250,250)
    lenb=length(buff250,250,1)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//" "//buff250(1:min(250-lenc-1,lenb))
    end if
    call chop0(crc250,250)
  end subroutine plot_errorappendi
  !
  subroutine findDelimiter(var80,del,pos)
    character*80 :: var80
    character*1 :: del
    integer :: pos
    logical :: bdone
    pos=min(80,pos+1)
    bdone=(pos.eq.80)
    do while (.not.bdone)
       if (var80(pos:pos).eq.del) then
          bdone=.true.
       else
          pos=min(80,pos+1)
          bdone=(pos.eq.80)
       end if
    end do
  end subroutine findDelimiter
  !
  subroutine plot_strep(str250,nn,src100,rep100,lrep,irc)
    implicit none
    ! search for, and replace, key words in string with given information...
    character*250 str250
    integer nn
    character*100 src100(nn)
    character*100 rep100(nn)
    logical lrep(nn)
    integer irc
    !
    logical bdone
    character*250 buff250
    character*1000 buff1000
    integer ii,jj,length,lens,lenr,leni
    !
    character*16 myname
    data myname /'strep'/
    !
    do ii=1,nn
       call chop0(src100(ii),100)
       call chop0(rep100(ii),100)
       leni=length(str250,250,10)
       lens=length(src100(ii),100,2)
       lenr=length(rep100(ii),100,2)
       bdone=(leni.eq.0)
       do while (.not.bdone)
          buff250=str250
          bdone=.true.
          do jj=1,leni-lens+1
             !     write(*,*) myname,'"',str250(jj:jj+lens-1),'"',
             !     &              src100(ii)(1:lens),'"'
             if (str250(jj:jj+lens-1).eq.&
                  &              src100(ii)(1:lens)) then
                buff1000=str250(1:jj-1)//&
                     &                 rep100(ii)(1:lenr)//&
                     &                 str250(jj+lens:leni)
                call chop0(buff1000,251)
                str250=buff1000(1:250)
                leni=length(str250,250,10)
                !     write(*,*) myname,str250(1:leni)
                lrep(ii)=.true.
                bdone=(buff250.eq.str250)
             end if
          end do
       end do
    end do
    !     
    return
  end subroutine plot_strep
  !
end module plot
#__file: 'libshape/fortranc.F90' 0100644    **DO NOT DELETE**
!    Copyright 2011 Davide Cesari <dcesari69 at gmail dot com>
!
!    This file is part of FortranGIS.
!
!    FortranGIS is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as
!    published by the Free Software Foundation, either version 3 of the
!    License, or (at your option) any later version.
!
!    FortranGIS is distributed in the hope that it will be useful, but
!    WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
!    Lesser General Public License for more details.
!
!    You should have received a copy of the GNU Lesser General Public
!    License along with FortranGIS.  If not, see
!    <http://www.gnu.org/licenses/>.
#include "config.h"

!> Utility module for supporting Fortran 2003 C language interface module.
!! This module contains various utilties for simplifying the exchange
!! of character variables between Fortran and C when using the
!! <tt>ISO_C_BINDING</tt> intrinsic module of Fortran 2003.
!!
!! For an example of application of the \a fortranc module, please
!! refer to the following test program, which, among the other
!! operations, decodes the output of a C function returning a
!! <tt>char**</tt> result:
!! \include fortranc_test.F90
!!
!! \ingroup libfortranc
MODULE fortranc
USE,INTRINSIC :: ISO_C_BINDING
#ifdef WITH_VARYING_STRING
USE iso_varying_string
#endif
IMPLICIT NONE


!> Fortran derived type for handling <tt>void**</tt>, <tt>char**</tt>,
!! etc C objects (pointer to pointer or array of pointers).  The array
!! of pointers is assumed to be terminated by a <tt>NULL</tt>
!! pointer. Methods are provided both for receiving the data structure
!! from C and unpacking it in Fortran as well as for creating it in
!! Fortran and passing it to C.
!!
!! Example of <tt>char**</tt> object created in C and unpacked in Fortran:
!! \code
!! TYPE(c_ptr_ptr) :: envp
!! INTEGER :: i
!! ...
!! envp = c_ptr_ptr_new(interfaced_c_procedure())
!! DO i = 1, c_ptr_ptr_getsize(envp)
!!   PRINT*,i,TRIM(strtofchar(c_ptr_ptr_getptr(envp, i),100))
!! ENDDO
!! CALL delete(envp)
!! \endcode
!!
!! Example of <tt>char**</tt> object created in Fortran and passed to C:
!! \code
!! TYPE(c_ptr_ptr) :: envp
!! ...
!! envp = c_ptr_ptr_new((/'APPLE=3  ','PEAR=2  ','ORANGE=20'/))
!! CALL interfaced_c_procedure(c_ptr_ptr_getobject(envp))
!! CALL delete(envp)
!! ...
!! \endcode
TYPE c_ptr_ptr
  PRIVATE
  TYPE(c_ptr),POINTER :: elem(:) => NULL()
  CHARACTER(len=1),POINTER :: buffer(:) => NULL()
END TYPE c_ptr_ptr

!> Equivalent of the strlen C function.
!!
!! \param string null-terminated C-style string to test
INTERFACE strlen
  MODULE PROCEDURE strlen_char, strlen_chararr, strlen_intarr, &
   strlen_ptr
#ifdef WITH_VARYING_STRING
  MODULE PROCEDURE strlen_var_str
#endif
END INTERFACE

!> Convert a null-terminated C string into a Fortran <tt>CHARACTER</tt>
!! variable of the proper length.  The input can be provided as a
!! Fortran <tt>CHARACTER</tt> scalar of any length, as a Fortran array
!! of <tt>CHARACTER</tt> of length one, as an array of 1-byte integers or as
!! a C pointer to char (<tt>char*</tt>).
!!
!! It is typically used for:
!!
!!  - converting a string created/modified by a C function and passed
!!    as a <tt>char *</tt> argument, interfaced as
!!    <tt>CHARACTER(kind=c_char,len=*) :: fchar</tt> for its
!!    subsequent use in Fortran
!!
!!  - (more frequently) converting a string returned by a C function
!!    declared as <tt>char*</tt>, interfaced as <tt>TYPE(c_ptr)</tt>
!!    for its subsequent use in Fortran
!!
!! \param string null-terminated C-style string to convert
INTERFACE strtofchar
  MODULE PROCEDURE strtofchar_char, strtofchar_chararr, strtofchar_intarr, &
   strtofchar_ptr_2
END INTERFACE

!> Constructor for a \a c_ptr_ptr object.
!! An object of this type can be constructed either from a pointer
!! returned by a C procedure, (either as an argument, interfaced as
!! <tt>TYPE(c_ptr),VALUE</tt> or as the result of a function,
!! interfaced as <tt>TYPE(c_ptr)</tt>) or from Fortran array of
!! character variables (<tt>char **</tt> objects only).
INTERFACE c_ptr_ptr_new
  MODULE PROCEDURE c_ptr_ptr_new_from_c, c_ptr_ptr_new_from_fchar
END INTERFACE c_ptr_ptr_new

INTERFACE ASSIGNMENT(=)
  MODULE PROCEDURE strtofchararr_assign
END INTERFACE ASSIGNMENT(=)

PRIVATE
PUBLIC strlen, strtofchar, fchartostr, fchartrimtostr, ASSIGNMENT(=)
PUBLIC c_ptr_ptr, c_ptr_ptr_new, c_ptr_ptr_getsize, c_ptr_ptr_getptr, c_ptr_ptr_getobject

CONTAINS


PURE FUNCTION strlen_char(string) RESULT(strlen)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strlen_char
#endif
CHARACTER(kind=c_char,len=*),INTENT(in) :: string
INTEGER :: strlen

INTEGER :: i

DO i = 1, LEN(string)
  IF (string(i:i) == CHAR(0)) EXIT
ENDDO
strlen = i - 1

END FUNCTION strlen_char


PURE FUNCTION strlen_chararr(string) RESULT(strlen)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strlen_chararr
#endif
CHARACTER(kind=c_char,len=1),INTENT(in) :: string(:)
INTEGER :: strlen

INTEGER :: i

DO i = 1, SIZE(string)
  IF (string(i) == CHAR(0)) EXIT
ENDDO
strlen = i - 1

END FUNCTION strlen_chararr


PURE FUNCTION strlen_intarr(string) RESULT(strlen)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strlen_intarr
#endif
INTEGER(kind=c_signed_char),INTENT(in) :: string(:)
INTEGER :: strlen

INTEGER :: i

DO i = 1, SIZE(string)
  IF (string(i) == 0) EXIT
ENDDO
strlen = i - 1

END FUNCTION strlen_intarr


FUNCTION strlen_ptr(string) RESULT(strlen)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strlen_ptr
#endif
TYPE(c_ptr),INTENT(in) :: string
INTEGER :: strlen

INTEGER(kind=c_signed_char),POINTER :: pstring(:)
INTEGER :: i

IF (C_ASSOCIATED(string)) THEN ! conflicts with PURE
! null C pointer does not produce unassociated Fortran pointer with Intel
  CALL C_F_POINTER(string, pstring, (/HUGE(i)/))
! IF (ASSOCIATED(pstring)) THEN
  DO i = 1, SIZE(pstring)
    IF (pstring(i) == 0) EXIT
  ENDDO
  strlen = i - 1
ELSE
  strlen = 0
ENDIF

END FUNCTION strlen_ptr


#ifdef WITH_VARYING_STRING
PURE FUNCTION strlen_var_str(string) RESULT(strlen)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strlen_var_str
#endif
TYPE(varying_string),INTENT(in) :: string
INTEGER :: strlen

strlen = len(string)

END FUNCTION strlen_var_str
#endif


FUNCTION strtofchar_char(string) RESULT(fchar)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strtofchar_char
#endif
CHARACTER(kind=c_char,len=*),INTENT(in) :: string
CHARACTER(len=strlen(string)) :: fchar

fchar(:) = string(1:LEN(fchar))

END FUNCTION strtofchar_char


FUNCTION strtofchar_chararr(string) RESULT(fchar)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strtofchar_chararr
#endif
CHARACTER(kind=c_char,len=1),INTENT(in) :: string(:)
CHARACTER(len=strlen(string)) :: fchar

INTEGER :: i

DO i = 1, LEN(fchar)
  fchar(i:i) = string(i)
ENDDO

END FUNCTION strtofchar_chararr


FUNCTION strtofchar_intarr(string) RESULT(fchar)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strtofchar_intarr
#endif
INTEGER(kind=c_signed_char),INTENT(in) :: string(:)
CHARACTER(len=strlen(string)) :: fchar

fchar(:) = TRANSFER(string(1:LEN(fchar)), fchar)

END FUNCTION strtofchar_intarr


! this unfortunately works only with gfortran where c_f_pointer is
! "erroneously" declared as PURE thus strlen_ptr can be PURE as well

!FUNCTION strtofchar_ptr(string) RESULT(fchar)
!TYPE(c_ptr),INTENT(in) :: string
!CHARACTER(len=strlen(string)) :: fchar
!
!CHARACTER(len=strlen(string)),POINTER :: pfchar
!
!IF (C_ASSOCIATED(string)) THEN
!  CALL c_f_pointer(string, pfchar)
!  fchar(:) = pfchar(:)
!!ELSE
!! silently return an empty string probably useless because
!! strlen is zero in this case (to be tested)
!!  fchar = ''
!ENDIF
!
!END FUNCTION strtofchar_ptr


FUNCTION strtofchar_ptr_2(string, fixlen) RESULT(fchar)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strtofchar_ptr_2
#endif
TYPE(c_ptr),INTENT(in) :: string
INTEGER,INTENT(in) :: fixlen
CHARACTER(len=fixlen) :: fchar

CHARACTER(len=fixlen),POINTER :: pfchar
INTEGER :: safelen

safelen = MIN(strlen(string), fixlen)

fchar = ''
IF (C_ASSOCIATED(string)) THEN
  CALL c_f_pointer(string, pfchar)
  fchar(1:safelen) = pfchar(1:safelen)
ENDIF

END FUNCTION strtofchar_ptr_2


!> Convert a Fortran \a CHARACTER variable into a null-terminated C
!! string. The result is still of type \a CHARACTER but it is
!! interoperable with a C null-terminated string argument <tt>const
!! char*</tt> interfaced as <tt>CHARACTER(kind=c_char) :: cstr</tt>.
FUNCTION fchartostr(fchar) RESULT(string)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: fchartostr
#endif
CHARACTER(len=*),INTENT(in) :: fchar !< Fortran \a CHARACTER variable to convert
CHARACTER(kind=c_char,len=LEN(fchar)+1) :: string

string = fchar//CHAR(0)

END FUNCTION fchartostr


!> Trim trailing blanks and convert a Fortran \a CHARACTER variable
!! into a null-terminated C string. The result is still of type \a
!! CHARACTER but it is interoperable with a C null-terminated string
!! argument <tt>const char*</tt> interfaced as
!! <tt>CHARACTER(kind=c_char) :: cstr</tt>.
FUNCTION fchartrimtostr(fchar) RESULT(string)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: fchartrimtostr
#endif
CHARACTER(len=*),INTENT(in) :: fchar !< Fortran \a CHARACTER variable to convert
CHARACTER(kind=c_char,len=LEN_TRIM(fchar)+1) :: string

string = TRIM(fchar)//CHAR(0)

END FUNCTION fchartrimtostr


SUBROUTINE strtofchararr_assign(fchar, string)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: strtofchararr_assign
#endif
CHARACTER(kind=c_char,len=1),ALLOCATABLE,INTENT(out) :: fchar(:)
TYPE(c_ptr),INTENT(in) :: string

CHARACTER(kind=c_char),POINTER :: pstring(:)
INTEGER :: l

l = strlen(string)
CALL C_F_POINTER(string, pstring, (/l/))
ALLOCATE(fchar(l))
fchar(:) = pstring(:)

END SUBROUTINE strtofchararr_assign


!> Constructor for a \a c_ptr_ptr object.
!! The argument, a generic C pointer, must be a C array of pointers
!! (<tt>char** c_ptr_ptr_c</tt> or <tt>char* c_ptr_ptr_c[n]</tt>),
!! typically the result of a C function. The resulting object can be
!! queried by means of the \a c_ptr_ptr_getsize and \a
!! c_ptr_ptr_getptr methods, but it should not be modified by Fortran.
FUNCTION c_ptr_ptr_new_from_c(c_ptr_ptr_c) RESULT(this)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: c_ptr_ptr_new_from_c
#endif
TYPE(c_ptr),VALUE :: c_ptr_ptr_c !< pointer returned by a C procedure
TYPE(c_ptr_ptr) :: this

INTEGER :: i
TYPE(c_ptr),POINTER :: charp(:)

IF (C_ASSOCIATED(c_ptr_ptr_c)) THEN
  ! HUGE() here is ugly, but we must set a finite size
  CALL C_F_POINTER(c_ptr_ptr_c, charp, (/HUGE(1)/))
  DO i = 1, SIZE(charp)
    IF (.NOT.C_ASSOCIATED(charp(i))) THEN
      CALL C_F_POINTER(c_ptr_ptr_c, this%elem, (/i/))
      RETURN
    ENDIF
  ENDDO
ENDIF
END FUNCTION c_ptr_ptr_new_from_c


!> Constructor for a \a c_ptr_ptr object.
!! The argument is an array of Fortran character variables which will
!! be trimmed and stored in the resulting object. The object can be
!! passed to a C procedure as a <tt>char **</tt> argument after
!! applying the \a c_ptr_prt_getptr method, but it should not be
!! modified by the C procedure.
FUNCTION c_ptr_ptr_new_from_fchar(fchar) RESULT(this)
CHARACTER(len=*) :: fchar(:) !< array of characters that will compose the object
TYPE(c_ptr_ptr) :: this

INTEGER :: i, j, totlen

totlen = 0
DO i = 1, SIZE(fchar)
  totlen = totlen + LEN_TRIM(fchar(i)) + 1
ENDDO
ALLOCATE(this%buffer(totlen), this%elem(SIZE(fchar) + 1))
totlen = 1
DO i = 1, SIZE(fchar)
  this%elem(i) = C_LOC(this%buffer(totlen))
  DO j = 1, LEN_TRIM(fchar(i))
    this%buffer(totlen) = fchar(i)(j:j)
    totlen = totlen + 1
  ENDDO
  this%buffer(totlen) = CHAR(0)
  totlen = totlen + 1
ENDDO
this%elem(i) = C_NULL_PTR

END FUNCTION c_ptr_ptr_new_from_fchar


!> Return the number of valid pointers in the array pointer \a this.
!! If the object has not been initialized or has been initialized with
!! errors, zero is returned.
FUNCTION c_ptr_ptr_getsize(this)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: c_ptr_ptr_getsize
#endif
TYPE(c_ptr_ptr),INTENT(in) :: this
INTEGER :: c_ptr_ptr_getsize

IF (ASSOCIATED(this%elem)) THEN
  c_ptr_ptr_getsize = SIZE(this%elem) - 1
ELSE
  c_ptr_ptr_getsize = 0
ENDIF

END FUNCTION c_ptr_ptr_getsize

!> Return the n-th pointer in the array pointer \a this.
!! Ths method is useful if the object \a this has been created from C.
!! If the object has not been initialized, or \a n is out of bounds, a
!! NULL pointer is returned, this condition can be checked by means of
!! the <tt>C_ASSOCIATED()</tt> function. If \a this is an array of
!! pointers to C null-terminated strings, the string can be returned
!! as a Fortran \a CHARACTER variable of the proper length by using
!! the \a strtofchar function.
FUNCTION c_ptr_ptr_getptr(this, n)
#ifdef DLL_EXPORT
!GCC$ ATTRIBUTES DLLEXPORT :: c_ptr_ptr_getptr
#endif
TYPE(c_ptr_ptr),INTENT(in) :: this !< object to query
INTEGER,INTENT(in) :: n !< the number of pointer to get (starting from 1)
TYPE(c_ptr) :: c_ptr_ptr_getptr

c_ptr_ptr_getptr = C_NULL_PTR
IF (ASSOCIATED(this%elem)) THEN
  IF (n > 0 .AND. n <= SIZE(this%elem)) THEN
    c_ptr_ptr_getptr = this%elem(n)
  ENDIF
ENDIF

END FUNCTION c_ptr_ptr_getptr


!> Return the C pointer to the first pointer in the array pointer \a this.
!! This method is useful if the object \a this has been created from
!! Fortran and it has to be passed to a C procedure.
FUNCTION c_ptr_ptr_getobject(this)
TYPE(c_ptr_ptr),INTENT(in) :: this !< object to query
TYPE(c_ptr) :: c_ptr_ptr_getobject

c_ptr_ptr_getobject = C_NULL_PTR
IF (ASSOCIATED(this%elem)) THEN
  c_ptr_ptr_getobject = C_LOC(this%elem(1))
ENDIF

END FUNCTION c_ptr_ptr_getobject

END MODULE fortranc
#__file: 'libshape/shape.F90' 0100644    **DO NOT DELETE**
!    Copyright 2011 Davide Cesari <dcesari69 at gmail dot com>
!
!    This file is part of FortranGIS.
!
!    FortranGIS is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License as
!    published by the Free Software Foundation, either version 3 of the
!    License, or (at your option) any later version.
!
!    FortranGIS is distributed in the hope that it will be useful, but
!    WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
!    Lesser General Public License for more details.
!
!    You should have received a copy of the GNU Lesser General Public
!    License along with FortranGIS.  If not, see
!    <http://www.gnu.org/licenses/>.

!> Fortran 2003 interface to the libshape http://libshape.maptools.org/
!! library.
!! This module defines an API which reflects the original libshape C
!! API with some modifications:
!!
!!  - \a shpopen, \a shpcreate and \a shpclose functions act also on
!!    .dbf files
!!  - \a shpgetinfo accesses also .dbf information
!!  - the \a DBFRead*Attribute and \a DBWrite*Attribute are converted
!!    into two f90 interfaces called \a dbfreadattribute and \a
!!    dbwriteattribute respectively.
!!
!! The module defines two derived types: \a shpfileobject associated
!! to a shapefile dataset, and \a shpobject associated to a single
!! shape within a dataset. Access to database (.dbf) information is
!! done by accessing the file object only.
!!
!! For an example of application of the \a libshape module, please
!! refer to the following test program, which creates a shapefile and
!! successively reads it:
!! \include libshape_test.F90
!!
!! \ingroup libfortrangis
MODULE shape
  USE,INTRINSIC :: ISO_C_BINDING
  USE fortranc
  IMPLICIT NONE
  logical     :: shape_bdeb=.false.
  INTEGER,PARAMETER :: shpt_null = 0 !< Series of constants for specifying type of new shape datasets with \a shpcreate, null shape
  INTEGER,PARAMETER :: shpt_point = 1 !< points
  INTEGER,PARAMETER :: shpt_arc = 3 !< arcs (Polylines, possible in parts)
  INTEGER,PARAMETER :: shpt_polygon = 5 !< polygons (possible in parts)
  INTEGER,PARAMETER :: shpt_multipoint = 8 !< multiPoint (related points)
  INTEGER,PARAMETER :: shpt_pointz = 11 !< 3D (+ measure) points
  INTEGER,PARAMETER :: shpt_arcz = 13 !< 3D (+ measure) arcs
  INTEGER,PARAMETER :: shpt_polygonz = 15 !< 3D (+ measure) polygons
  INTEGER,PARAMETER :: shpt_multipointz = 18 !< 3D (+ measure) multiPoint
  INTEGER,PARAMETER :: shpt_pointm = 21 !< 2D + measure points
  INTEGER,PARAMETER :: shpt_arcm = 23 !< 2D + measure arcs
  INTEGER,PARAMETER :: shpt_polygonm = 25 !< 2D + measure polygons
  INTEGER,PARAMETER :: shpt_multipointm = 28 !< 2D + measure multiPoint

  INTEGER,PARAMETER :: shpt_multipatch = 31 !< complex (TIN-like) with Z, and Measure

  INTEGER,PARAMETER :: ftstring = 0 !< Series of constants for specifying dbf field type, fixed length string field
  INTEGER,PARAMETER :: ftinteger = 1 !< numeric field with no decimals
  INTEGER,PARAMETER :: ftdouble = 2 !< numeric field with decimals
  INTEGER,PARAMETER :: ftlogical = 3 !< LOGICAL field
  INTEGER,PARAMETER :: ftinvalid = 4 !< not a recognised field TYPE

  TYPE shpSeg
     real :: spos(3), epos(3)
     type(shpSeg), pointer :: prev => null()
     type(shpSeg), pointer :: next => null()
  END type shpSeg
  
  !> Object describing a shapefile dataset.
  !! Its components are private so they should not be manipulated
  !! directly.
  TYPE shpfileobject
     PRIVATE
     TYPE(c_ptr) :: shpfile_orig=c_null_ptr
     TYPE(c_ptr) :: dbffile_orig=c_null_ptr
  END TYPE shpfileobject


  !> Object describing the geometrical properties of a shape.
  !! It is used for reading a shape, or for manipulating a newly created
  !! shape; in the latter case the single values can be changed, but not
  !! the size of the arrays.
  TYPE shpobject
     TYPE(c_ptr) :: shpobject_orig=c_null_ptr !< pointer to C information, it should not be used
     INTEGER :: nshptype=0 !< shape type, one of the \a shpt_* constants defined
     INTEGER :: nshapeid=-1 !< shape number (-1 is unknown/unassigned)
     INTEGER :: nparts=0 !< number of parts (0 implies single part with no info)
     INTEGER,POINTER :: panpartstart(:)=>NULL() !< starting vertex of each part
     INTEGER,POINTER :: panparttype(:)=>NULL() !< part type (SHPP_RING if not SHPT_MULTIPATCH)
     INTEGER :: nvertices !< number of vertices
     REAL(kind=c_double),POINTER :: padfx(:)=>NULL() !< x coordinates of vertices
     REAL(kind=c_double),POINTER :: padfy(:)=>NULL() !< y coordinates of vertices
     REAL(kind=c_double),POINTER :: padfz(:)=>NULL() !< z coordinates of vertices
     REAL(kind=c_double),POINTER :: padfm(:)=>NULL() !< measure of vertices
     REAL(kind=c_double) :: dfxmin=0.0_c_double !< lower bound in x dimension
     REAL(kind=c_double) :: dfymin=0.0_c_double !< lower bound in y dimension
     REAL(kind=c_double) :: dfzmin=0.0_c_double !< lower bound in z dimension
     REAL(kind=c_double) :: dfmmin=0.0_c_double !< lower bound in measure dimension
     REAL(kind=c_double) :: dfxmax=0.0_c_double !< upper bound in x dimension
     REAL(kind=c_double) :: dfymax=0.0_c_double !< upper bound in y dimension
     REAL(kind=c_double) :: dfzmax=0.0_c_double !< upper bound in z dimension
     REAL(kind=c_double) :: dfmmax=0.0_c_double !< upper bound in measure dimension
     logical            ,POINTER :: valid(:)=>NULL() !< is node valid
     logical            ,POINTER :: actual(:)=>NULL() !< is segment actual
     integer :: nseg=0
     type(shpSeg), pointer :: currentSegment => null()
     type(shpSeg), pointer :: firstSegment => null()
     type(shpSeg), pointer :: lastSegment => null()
  END TYPE shpobject

  !TYPE(shpfileobject),PARAMETER :: shpfileobject_null = shpfileobject(0, 0)
  TYPE(shpobject),PARAMETER :: shpobject_null = shpobject(c_null_ptr, &
       0, -1, 0, &
       NULL(), NULL(), 0, NULL(), NULL(), NULL(), NULL(), &
       0.0_c_double, 0.0_c_double, 0.0_c_double, 0.0_c_double, &
       0.0_c_double, 0.0_c_double, 0.0_c_double, 0.0_c_double)

  !> Interface to SUBROUTINEs for reading dbf attributes.
  !! The type of the attribute can be either INTEGER,
  !! REAL(kind=c_double) (double) or CHARACTER. In case of CHARACTER
  !! attributes it is important that the length of the string passed is
  !! big enough to contain the attribute. The maximum length for each
  !! field can be obtained with the \a dbfgetfieldinfo function, but it
  !! is limited anyway to a maximum of 512 characters. The type of the
  !! attribute requested may not coincide with the native type of the
  !! field, if possible a conversion will be performed.
  !!
  !! \param hshp TYPE(shpfileobject),INTENT(inout) shapefile object to query
  !! \param ishape INTEGER,INTENT(in) the number of shape to query
  !! \param ifield INTEGER,INTENT(in) the number of field to query
  !! \param attr INTEGER, CHARACTER or REAL(kind=c_double), INTENT(out) the value of the attribute
  INTERFACE dbfreadattribute
     MODULE PROCEDURE dbfreadintegerattribute_f, dbfreaddoubleattribute_f, &
          dbfreadstringattribute_f
  END INTERFACE dbfreadattribute


  !> Interface to FUNCTIONs for setting dbf attributes.
  !! The type of the attribute can be either INTEGER,
  !! REAL(kind=c_double) (double) or CHARACTER. The type of the
  !! attribute provided may not coincide with the native type of the
  !! field, if possible a conversion will be performed. If the \a attr
  !! parameter is not provided the attribute will be set to a null
  !! value.
  !!
  !! \param hshp TYPE(shpfileobject),INTENT(inout) shapefile object to set
  !! \param ishape INTEGER,INTENT(in) the number of shape to set
  !! \param ifield INTEGER,INTENT(in) the number of field to set
  !! \param attr INTEGER, CHARACTER or REAL(kind=c_double), INTENT(in) the value of the attribute to set
  INTERFACE dbfwriteattribute
     MODULE PROCEDURE dbfwriteintegerattribute_f, dbfwritedoubleattribute_f, &
          dbfwritestringattribute_f, dbfwritenullattribute_f
  END INTERFACE dbfwriteattribute


  INTERFACE
     FUNCTION shpopen_orig(pszlayer, pszaccess) BIND(C,name='SHPOpen')
       IMPORT
       CHARACTER(kind=c_char) :: pszlayer(*)
       CHARACTER(kind=c_char) :: pszaccess(*)
       TYPE(c_ptr) :: shpopen_orig
     END FUNCTION shpopen_orig

     SUBROUTINE shpclose_orig(psshp) BIND(C,name='SHPClose')
       IMPORT
       TYPE(c_ptr),VALUE :: psshp
     END SUBROUTINE shpclose_orig

     SUBROUTINE shpgetinfo_orig(psshp, pnentities, pnshapetype, padfminbound, padfmaxbound) BIND(C,name='SHPGetInfo')
       IMPORT
       TYPE(c_ptr),VALUE :: psshp
       INTEGER(kind=c_int) :: pnentities
       INTEGER(kind=c_int) :: pnshapetype
       REAL(kind=c_double) :: padfminbound(*)
       REAL(kind=c_double) :: padfmaxbound(*)
     END SUBROUTINE shpgetinfo_orig

     FUNCTION shpcreate_orig(pszlayer, nshapetype) BIND(C,name='SHPCreate')
       IMPORT
       CHARACTER(kind=c_char) :: pszlayer(*)
       INTEGER(kind=c_int),VALUE :: nshapetype
       TYPE(c_ptr) :: shpcreate_orig
     END FUNCTION shpcreate_orig

     SUBROUTINE shpcomputeextents_int(psobject, ftnobject) BIND(C,name='SHPComputeExtentsInt')
       IMPORT
       TYPE(c_ptr),VALUE :: psobject
       TYPE(c_ptr),VALUE :: ftnobject
     END SUBROUTINE shpcomputeextents_int

     FUNCTION shpcreateobject_int(nshptype, nshapeid, nparts, panpartstart, panparttype, &
          nvertices, padfx, padfy, padfz, padfm, ftnobject) BIND(C,name='SHPCreateObjectInt')
       IMPORT
       INTEGER(kind=c_int),VALUE :: nshptype
       INTEGER(kind=c_int),VALUE :: nshapeid
       INTEGER(kind=c_int),VALUE :: nparts
       INTEGER(kind=c_int) :: panpartstart(*)
       INTEGER(kind=c_int) :: panparttype(*)
       INTEGER(kind=c_int),VALUE :: nvertices
       REAL(kind=c_double) :: padfx(*)
       REAL(kind=c_double) :: padfy(*)
       REAL(kind=c_double) :: padfz(*)
       REAL(kind=c_double) :: padfm(*)
       TYPE(c_ptr),VALUE :: ftnobject
       INTEGER(kind=c_int) :: shpcreateobject_int
     END FUNCTION shpcreateobject_int

     FUNCTION shpcreatesimpleobject_int(nshptype, nvertices, padfx, padfy, padfz, ftnobject) BIND(C,name='SHPCreateSimpleObjectInt')
       IMPORT
       INTEGER(kind=c_int),VALUE :: nshptype
       INTEGER(kind=c_int),VALUE :: nvertices
       REAL(kind=c_double) :: padfx(*)
       REAL(kind=c_double) :: padfy(*)
       REAL(kind=c_double) :: padfz(*)
       TYPE(c_ptr),VALUE :: ftnobject
       INTEGER(kind=c_int) :: shpcreatesimpleobject_int
     END FUNCTION shpcreatesimpleobject_int

     FUNCTION shpwriteobject_orig(psshp, nshapeid, psobject) BIND(C,name='SHPWriteObject')
       IMPORT
       TYPE(c_ptr),VALUE :: psshp
       INTEGER(kind=c_int),VALUE :: nshapeid
       TYPE(c_ptr),VALUE :: psobject
       INTEGER(kind=c_int) :: shpwriteobject_orig
     END FUNCTION shpwriteobject_orig

     FUNCTION shpreadobject_int(psshp, hentity, ftnobject) BIND(C,name='SHPReadObjectInt')
       IMPORT
       TYPE(c_ptr),VALUE :: psshp
       INTEGER(kind=c_int),VALUE :: hentity
       TYPE(c_ptr),VALUE :: ftnobject
       INTEGER(kind=c_int) :: shpreadobject_int
     END FUNCTION shpreadobject_int

     SUBROUTINE shpdestroyobject_orig(psshape) BIND(C,name='SHPDestroyObject')
       IMPORT
       TYPE(c_ptr),VALUE :: psshape
     END SUBROUTINE shpdestroyobject_orig

#ifndef LIBSHAPE_PRE10
     FUNCTION shprewindobject_int(hshp, psobject, ftnobject) BIND(C,name='SHPRewindObjectInt')
       IMPORT
       TYPE(c_ptr),VALUE :: hshp
       TYPE(c_ptr),VALUE :: psobject
       TYPE(c_ptr),VALUE :: ftnobject
       INTEGER(kind=c_int) :: shprewindobject_int
     END FUNCTION shprewindobject_int
#endif
  END INTERFACE

  INTERFACE
     FUNCTION dbfopen(pszfilename, pszaccess) BIND(C,name='DBFOpen')
       IMPORT
       CHARACTER(kind=c_char) :: pszfilename(*)
       CHARACTER(kind=c_char) :: pszaccess(*)
       TYPE(c_ptr) :: dbfopen
     END FUNCTION dbfopen

     SUBROUTINE dbfclose(psdbf) BIND(C,name='DBFClose')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
     END SUBROUTINE dbfclose

     FUNCTION dbfcreate(pszfilename) BIND(C,name='DBFCreate')
       IMPORT
       CHARACTER(kind=c_char) :: pszfilename(*)
       TYPE(c_ptr) :: dbfcreate
     END FUNCTION dbfcreate

     FUNCTION dbfaddfield_orig(psdbf, pszfieldname, etype, nwidth, ndecimals) BIND(C,name='DBFAddField')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       CHARACTER(kind=c_char) :: pszfieldname(*)
       INTEGER(kind=c_int),VALUE :: etype
       INTEGER(kind=c_int),VALUE :: nwidth
       INTEGER(kind=c_int),VALUE :: ndecimals
       INTEGER(kind=c_int) :: dbfaddfield_orig
     END FUNCTION dbfaddfield_orig

     FUNCTION dbfreadintegerattribute_orig(psdbf, irecord, ifield) BIND(C,name='DBFReadIntegerAttribute')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       INTEGER(kind=c_int) :: dbfreadintegerattribute_orig
     END FUNCTION dbfreadintegerattribute_orig

     FUNCTION dbfreaddoubleattribute_orig(psdbf, irecord, ifield) BIND(C,name='DBFReadDoubleAttribute')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       REAL(kind=c_double) :: dbfreaddoubleattribute_orig
     END FUNCTION dbfreaddoubleattribute_orig

     FUNCTION dbfreadstringattribute_orig(psdbf, irecord, ifield) BIND(C,name='DBFReadStringAttribute')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       TYPE(c_ptr) :: dbfreadstringattribute_orig
     END FUNCTION dbfreadstringattribute_orig

     SUBROUTINE dbfreadstringattribute_int(psdbf, irecord, ifield, attr, lattr) BIND(C,name='DBFReadStringAttributeInt')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       CHARACTER(kind=c_char) :: attr(*)
       INTEGER(kind=c_int),VALUE :: lattr
     END SUBROUTINE dbfreadstringattribute_int

     FUNCTION dbfreadlogicalattribute(psdbf, irecord, ifield) BIND(C,name='DBFReadLogicalAttribute')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       CHARACTER(kind=c_char) :: dbfreadlogicalattribute
     END FUNCTION dbfreadlogicalattribute

#ifndef LIBSHAPE_PRE10
     FUNCTION dbfisattributenull_orig(psdbf, irecord, ifield) BIND(C,name='DBFIsAttributeNULL')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       INTEGER(kind=c_int) :: dbfisattributenull_orig
     END FUNCTION dbfisattributenull_orig
#endif

     FUNCTION dbfgetfieldcount(psdbf) BIND(C,name='DBFGetFieldCount')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int) :: dbfgetfieldcount
     END FUNCTION dbfgetfieldcount

     FUNCTION dbfgetrecordcount(psdbf) BIND(C,name='DBFGetRecordCount')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int) :: dbfgetrecordcount
     END FUNCTION dbfgetrecordcount

     FUNCTION dbfgetfieldinfo_orig(psdbf, ifield, pszfieldname, pnwidth, pndecimals) BIND(C,name='DBFGetFieldInfo')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: ifield
       CHARACTER(kind=c_char) :: pszfieldname(*)
       INTEGER(kind=c_int) :: pnwidth
       INTEGER(kind=c_int) :: pndecimals
       INTEGER(kind=c_int) :: dbfgetfieldinfo_orig
     END FUNCTION dbfgetfieldinfo_orig

     FUNCTION dbfwritedoubleattribute(psdbf, irecord, ifield, dvalue) BIND(C,name='DBFWriteDoubleAttribute')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       REAL(kind=c_double),VALUE :: dvalue
       INTEGER(kind=c_int) :: dbfwritedoubleattribute
     END FUNCTION dbfwritedoubleattribute

     FUNCTION dbfwriteintegerattribute(psdbf, irecord, ifield, nvalue) BIND(C,name='DBFWriteIntegerAttribute')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       INTEGER(kind=c_int),VALUE :: nvalue
       INTEGER(kind=c_int) :: dbfwriteintegerattribute
     END FUNCTION dbfwriteintegerattribute

     FUNCTION dbfwritestringattribute(psdbf, irecord, ifield, pszvalue) BIND(C,name='DBFWriteStringAttribute')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       CHARACTER(kind=c_char) :: pszvalue(*)
       INTEGER(kind=c_int) :: dbfwritestringattribute
     END FUNCTION dbfwritestringattribute

     FUNCTION dbfwritenullattribute(psdbf, irecord, ifield) BIND(C,name='DBFWriteNULLAttribute')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       INTEGER(kind=c_int) :: dbfwritenullattribute
     END FUNCTION dbfwritenullattribute

     FUNCTION dbfwritelogicalattribute(psdbf, irecord, ifield, lvalue) BIND(C,name='DBFWriteLogicalAttribute')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: irecord
       INTEGER(kind=c_int),VALUE :: ifield
       CHARACTER(kind=c_char),VALUE :: lvalue
       INTEGER(kind=c_int) :: dbfwritelogicalattribute
     END FUNCTION dbfwritelogicalattribute

#ifndef LIBSHAPE_PRE10
     FUNCTION dbfgetnativefieldtype_orig(psdbf, ifield) BIND(C,name='DBFGetNativeFieldType')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       INTEGER(kind=c_int),VALUE :: ifield
       INTEGER(kind=c_signed_char) :: dbfgetnativefieldtype_orig
     END FUNCTION dbfgetnativefieldtype_orig

     FUNCTION dbfgetfieldindex_orig(psdbf, pszfieldname) BIND(C,name='DBFGetFieldIndex')
       IMPORT
       TYPE(c_ptr),VALUE :: psdbf
       CHARACTER(kind=c_char) :: pszfieldname(*)
       INTEGER(kind=c_int) :: dbfgetfieldindex_orig
     END FUNCTION dbfgetfieldindex_orig
#endif
  END INTERFACE

  PRIVATE
  PUBLIC shpt_null, shpt_point, shpt_arc, shpt_polygon, shpt_multipoint, &
       shpt_pointz, shpt_arcz, shpt_polygonz, shpt_multipointz, shpt_pointm, &
       shpt_arcm, shpt_polygonm, shpt_multipointm, shpt_multipatch, &
       ftstring, ftinteger, ftdouble, ftlogical, ftinvalid
  PUBLIC shpfileobject, shpobject
  PUBLIC dbfreadattribute, dbfwriteattribute
  PUBLIC shpopen, shpfileisnull, dbffileisnull, shpcreate, shpgetinfo, &
       shpreadobject, shpisnull, shpclose, shpcreatesimpleobject, shpcreateobject, &
       shpcomputeextents, shpwriteobject, shpdestroyobject, shpretraceobject,shpLoopSegment,&
       dbfgetfieldindex, dbfgetfieldinfo, dbfaddfield, dbfisattributenull, &
       dbfgetnativefieldtype
  PUBLIC shape_pnpoly, shape_ddpoly, shape_getDist, shape_getDistBox, shape_inside
  PUBLIC shape_rtodeg, shape_degtor, shape_lonlat2pos, shape_bdeb
  PUBLIC shape_dot,shape_multiply,shape_divide,shape_cross
CONTAINS


  !> It tries to open the files composing a shapefile dataset.
  !! The filename should be provided without the extension
  !! (.shp/.shx/.dbf). It tries to open all files associated, but it
  !! does not fail if part of the files are missing, so that it is
  !! possible to work on datasets not including .shp/.shx or .dbf parts.
  !! The access mode should be "rb" for reading or "rb+" for updating a
  !! file.  It returns an object of type \a shpfileobject to be used in
  !! the subsequent calls for obtaining both shp and dbf information
  !! from the dataset.  The function should not be used for creating a
  !! shapefile dataset from scratch, in that case \a shpcreate should be
  !! used.
  FUNCTION shpopen(pszshapefile, pszaccess)
    CHARACTER(len=*),INTENT(in) :: pszshapefile !< filename without extension
    CHARACTER(len=*),INTENT(in) :: pszaccess !< file access mode
    TYPE(shpfileobject) :: shpopen

    shpopen%shpfile_orig = shpopen_orig(fchartrimtostr(pszshapefile), fchartrimtostr(pszaccess))
    shpopen%dbffile_orig = dbfopen(fchartrimtostr(pszshapefile), fchartrimtostr(pszaccess))

  END FUNCTION shpopen


  !> It returns \c .TRUE. if the provided shapefile object is correctly
  !! associated with .shp/.shx file pair.  It can be called after \a
  !! shpopen to test whether .shp/.shx files have been successfully
  !! opened.
  FUNCTION shpfileisnull(hshp) RESULT(isnull)
    TYPE(shpfileobject),INTENT(in) :: hshp !< shapefile object to test
    LOGICAL :: isnull

    isnull = .NOT.c_associated(hshp%shpfile_orig)

  END FUNCTION shpfileisnull


  !> It returns \c .TRUE. if the provided shapefile object is correctly
  !! associated with a .dbf file.  It can be called after \a shpopen to
  !! test whether .dbf file has been successfully opened.
  FUNCTION dbffileisnull(hshp) RESULT(isnull)
    TYPE(shpfileobject),INTENT(in) :: hshp !< shapefile object to test
    LOGICAL :: isnull

    isnull = .NOT.c_associated(hshp%dbffile_orig)

  END FUNCTION dbffileisnull


  !> It creates a new, empty set of files composing a shapefile dataset.
  !! The filename should be provided without the extension
  !! (.shp/.shx/.dbf). If the files already exist, they will be
  !! overwritten.  The type of shapes should be specified using one of
  !! the constants \a shpt_*.  It returns an object of type \a
  !! shpfileobject to be used in the subsequent calls for populating the
  !! dataset both with shp and dbf information.
  FUNCTION shpcreate(pszshapefile, nshapetype)
    CHARACTER(len=*),INTENT(in) :: pszshapefile !< filename without extension
    INTEGER,INTENT(in) :: nshapetype !< type of shapes in the dataset
    TYPE(shpfileobject) :: shpcreate

    shpcreate%shpfile_orig = shpcreate_orig(fchartrimtostr(pszshapefile), nshapetype)
    shpcreate%dbffile_orig = dbfcreate(fchartrimtostr(pszshapefile))

  END FUNCTION shpcreate


  !> It gets information about the shapefile database, including dbf.
  !! If a part of the dataset has not been correctly opened
  !! (e.g. .shp/.shx or .dbf files), the corresponding information, in
  !! particular \a nentities or \a dbfrecordcount will be zero.
  SUBROUTINE shpgetinfo(hshp, nentities, shapetype, minbound, maxbound, &
       dbffieldcount, dbfrecordcount)
    TYPE(shpfileobject),INTENT(in) :: hshp !< shapefile object to query
    INTEGER,INTENT(out) :: nentities !< number of shapes
    INTEGER,INTENT(out) :: shapetype !< type of shapes in the file, one of the \a shpt_* constants
    REAL(kind=c_double),INTENT(out) :: minbound(4) !< lower bounds of shape values
    REAL(kind=c_double),INTENT(out) :: maxbound(4) !< upper bounds of shape values
    INTEGER,INTENT(out) :: dbffieldcount !< number of dbf fields
    INTEGER,INTENT(out) :: dbfrecordcount !< number of dbf records, it should be equal to \a nentities, but it is not guaranteed

    IF (.NOT.shpfileisnull(hshp)) THEN
       CALL shpgetinfo_orig(hshp%shpfile_orig, nentities, shapetype, minbound, maxbound)
    ELSE
       nentities = 0
       shapetype = 0
       minbound(:) = 0.0D0
       maxbound(:) = 0.0D0
    ENDIF
    IF (.NOT.dbffileisnull(hshp)) THEN
       dbffieldcount = dbfgetfieldcount(hshp%dbffile_orig)
       dbfrecordcount = dbfgetrecordcount(hshp%dbffile_orig)
    ELSE
       dbffieldcount = 0
       dbfrecordcount = 0
    ENDIF

  END SUBROUTINE shpgetinfo


  !> It reads a single shape from a shapefile.
  !! This function reads a single shape from a shapefile dataset (only
  !! .shp/.shx part) and it returns an object of type \a shpobject
  !! containing all the information read. The value of \a ishape should
  !! be in the range 0, \a nentites (as returned from \a shpgetinfo).
  !! The shape object returned should be destroyed with the \a
  !! shpdestroyobject subroutine before being reused, in order to avoid
  !! memory leaks.
  FUNCTION shpreadobject(hshp, ishape)
    TYPE(shpfileobject),INTENT(inout) :: hshp !< shapefile object to read from
    INTEGER :: ishape !< number of shape to be read
    TYPE(shpobject),TARGET :: shpreadobject

    TYPE(shpobject) :: lshpobject

    INTEGER :: ier

    IF (.NOT.shpfileisnull(hshp)) THEN
       ier = shpreadobject_int(hshp%shpfile_orig, ishape, C_LOC(shpreadobject))
    ELSE ! initialize to empty
       shpreadobject = shpobject_null
    ENDIF

  END FUNCTION shpreadobject


  !> It returns \c .TRUE. if the provided shape object is not valid.
  !! It can be called after \a shpreadobject to test whether
  !! a valid shape has ben read.
  FUNCTION shpisnull(psobject) RESULT(isnull)
    TYPE(shpobject),INTENT(in) :: psobject !< shape object to test
    LOGICAL :: isnull

    isnull = .NOT.c_associated(psobject%shpobject_orig)

  END FUNCTION shpisnull


  !> It closes all the files associated with the shapefile dataset.
  SUBROUTINE shpclose(hshp)
    TYPE(shpfileobject),INTENT(inout) :: hshp !< shapefile object to be closed
    
    IF (.NOT.shpfileisnull(hshp)) THEN
       CALL shpclose_orig(hshp%shpfile_orig)
       hshp%shpfile_orig = c_null_ptr
    ENDIF
    IF (.NOT.dbffileisnull(hshp)) THEN
       CALL dbfclose(hshp%dbffile_orig)
       hshp%dbffile_orig = c_null_ptr
    ENDIF
    
  END SUBROUTINE shpclose

  subroutine shpClearSegment(shpObj)
    TYPE(shpobject),INTENT(inout) :: shpObj !< shapefile object to be closed
    type(shpSeg), pointer :: cs, ocs
    if (.not.associated(shpObj%firstSegment).or..not.associated(shpObj%lastSegment))then
       if (associated(shpObj%firstSegment))deallocate(shpObj%firstSegment)
       if (associated(shpObj%lastSegment))deallocate(shpObj%lastSegment)
       allocate(shpObj%firstSegment,shpObj%lastSegment)
    else
       cs => shpObj%firstSegment%next
       do while (.not.associated(cs,target=shpObj%lastSegment))
          ocs => cs%next
          deallocate(cs)
          cs => ocs
       end do
    end if
    shpObj%nseg=0
    shpObj%firstSegment%next => shpObj%lastSegment
    shpObj%lastSegment%prev => shpObj%firstSegment
    return
  end subroutine shpClearSegment
  
  !> It creates a new shape object, simple version.
  !! It creates a new shape object and returns it as a variable of type
  !! \a shpobject; the object has x,y,z coordinates with no measure and
  !! a single part. The successful creation can be checked with the
  !! function \a shpisnull.
  FUNCTION shpcreatesimpleobject(nshptype, nvertices, padfx, padfy, padfz)
    INTEGER :: nshptype !< type of shape, one of the \a shpt_* constants
    INTEGER :: nvertices !< number of vertices
    REAL(kind=c_double) :: padfx(nvertices) !< x coordinates
    REAL(kind=c_double) :: padfy(nvertices) !< y coordinates
    REAL(kind=c_double),OPTIONAL :: padfz(nvertices) !< z coordinates, it can be skipped
    TYPE(shpobject),TARGET :: shpcreatesimpleobject

    TYPE(shpobject) :: lshpobject

    IF (shpcreatesimpleobject_int(nshptype, nvertices, padfx, padfy, padfz, &
         C_LOC(shpcreatesimpleobject)) /= 0) THEN
       shpcreatesimpleobject = shpobject_null
    ENDIF

  END FUNCTION shpcreatesimpleobject


  !> It creates a new shape object, full version.
  !! It creates a new shape object and returns it as a variable of type
  !! \a shpobject; the object has x,y,z coordinates with measure and
  !! possibly multiple parts. The successful creation can be checked
  !! with the function \a shpisnull.
  FUNCTION shpcreateobject(nshptype, ishape, nparts, panpartstart, panparttype, &
       nvertices, padfx, padfy, padfz, padfm)
    INTEGER :: nshptype !< type of shape, one of the \a shpt_* constants
    INTEGER :: ishape !< shapeid to be recorded with this shape
    INTEGER :: nparts !< number of parts
    INTEGER :: nvertices !< number of vertices
    INTEGER :: panpartstart(nparts) !< start indices of each part
    INTEGER :: panparttype(nparts) !< type of each of the parts, this is only meaningful for \a MULTIPATCH files, for all other cases it will be assumed to be \a SHPP_RING 
    REAL(kind=c_double) :: padfx(nvertices) !< x coordinates
    REAL(kind=c_double) :: padfy(nvertices) !< y coordinates
    REAL(kind=c_double),OPTIONAL :: padfz(nvertices) !< z coordinates, it can be skipped
    REAL(kind=c_double),OPTIONAL :: padfm(nvertices) !< measure, it can be skipped
    TYPE(shpobject),TARGET :: shpcreateobject

    TYPE(shpobject) :: lshpobject

    IF (shpcreateobject_int(nshptype, ishape, nparts, panpartstart, panparttype, &
         nvertices, padfx, padfy, padfz, padfm, C_LOC(shpcreateobject)) /= 0) THEN
       shpcreateobject = shpobject_null
    ENDIF

  END FUNCTION shpcreateobject


  !> It recomputes the extents of a shape.
  !! This subroutine replaces the existing values of the dfXMin, dfYMin,
  !! dfZMin, dfMMin, dfXMax, dfYMax, dfZMax, and dfMMax with updated
  !! values based on the current set of vertices for the shape. It is
  !! automatically called by shpcreateobject, but if the vertices of an
  !! existing object are altered it should be called again to fix up the
  !! extents.
  SUBROUTINE shpcomputeextents(psobject)
    TYPE(shpobject),TARGET :: psobject !< shape object to update

    CALL shpcomputeextents_int(psobject%shpobject_orig, C_LOC(psobject))

  END SUBROUTINE shpcomputeextents


  !> It writes a shape object to a file.
  !! It returns the number of shape written, starting from 0, or -1 in
  !! case of failure.
  FUNCTION shpwriteobject(hshp, ishape, psobject)
    TYPE(shpfileobject),INTENT(inout) :: hshp !< shapefile object where to write
    INTEGER :: ishape !< number of shape to write in the file, starting from 0, -1 to append to existing shapes
    TYPE(shpobject) :: psobject !< shape object to be written
    INTEGER :: shpwriteobject

    IF (.NOT.shpfileisnull(hshp)) THEN
       shpwriteobject = shpwriteobject_orig(hshp%shpfile_orig, ishape, psobject%shpobject_orig)
    ELSE
       shpwriteobject = 0
    ENDIF

  END FUNCTION shpwriteobject


  !> It destroys a shape object for subsequent reuse or when not used anymore.
  SUBROUTINE shpdestroyobject(psobject)
    TYPE(shpobject) :: psobject !< shape object to be destroyed

    call shpClearSegment(psObject)
    if (associated(psObject%firstSegment)) deallocate(psObject%firstSegment)
    if (associated(psObject%lastSegment)) deallocate(psObject%lastSegment)
    nullify(psObject%currentSegment)
    if (associated(psObject%valid)) deallocate(psObject%valid)
    if (associated(psObject%actual)) deallocate(psObject%actual)
    IF (c_associated(psobject%shpobject_orig)) THEN
       CALL shpdestroyobject_orig(psobject%shpobject_orig)
    ENDIF
    psobject = shpobject_null

  END SUBROUTINE shpdestroyobject


#ifndef LIBSHAPE_PRE10
  !> It sets the correct ring order.
  !! This function will reverse any ring necessary in order to enforce
  !! the shapefile restrictions on the required order of inner and outer
  !! rings in the Shapefile specification. It returns TRUE if a change
  !! is made and FALSE if no change is made. Only polygon objects will
  !! be affected though any object may be passed.
  !! This procedure is available only with libshape version 1.2.10 or
  !! later.
  FUNCTION shprewindobject(hshp, psobject)
    TYPE(shpfileobject),INTENT(inout) :: hshp !< shapefile object (not used)
    TYPE(shpobject),INTENT(inout),TARGET :: psobject !< shape object to be rewound
    LOGICAL :: shprewindobject

    INTEGER :: ier

    if (shape_bdeb) write(*,*) "Rewinding rings in shape."
    ier = shprewindobject_int(hshp%shpfile_orig, psobject%shpobject_orig, &
         C_LOC(psobject))
    IF (ier == 0) THEN
       shprewindobject = .FALSE.
    ELSE
       shprewindobject = .TRUE.
    ENDIF

  END FUNCTION shprewindobject

  logical function shpLoopSegment(shpObj,spos,epos)
    TYPE(shpobject) :: shpObj !< shape object to be destroyed
    real :: spos(3),epos(3)
    if (.not.associated(shpObj%currentSegment)) then
       shpObj%currentSegment =>  shpObj%firstSegment%next 
    else
       shpObj%currentSegment =>  shpObj%currentSegment%next
    end if
    if (associated(shpObj%currentSegment,target=shpObj%lastSegment)) then
       nullify(shpObj%currentSegment)
       shploopSegment=.false.
    else
       spos(1)=shpObj%currentSegment%spos(1)
       spos(2)=shpObj%currentSegment%spos(2)
       spos(3)=shpObj%currentSegment%spos(3)
       epos(1)=shpObj%currentSegment%epos(1)
       epos(2)=shpObj%currentSegment%epos(2)
       epos(3)=shpObj%currentSegment%epos(3)
       shploopSegment=.true.
    end if
    return
  end function shpLoopSegment
  
  !> It returns the index of the field matching the name.
  !! The comparison is case insensitive, however lengths must match
  !! exactly. It returns -1 if the field is not found or if the shape
  !! object is not valid.
  !! This procedure is available only with libshape version 1.2.10 or
  !! later.
  FUNCTION dbfgetfieldindex(hshp, pszfieldname)
    TYPE(shpfileobject),INTENT(in) :: hshp !< shape object to query
    CHARACTER(len=*),INTENT(in) :: pszfieldname !< field name to search
    INTEGER :: dbfgetfieldindex

    IF (.NOT.dbffileisnull(hshp)) THEN
       dbfgetfieldindex = dbfgetfieldindex_orig(hshp%dbffile_orig, fchartrimtostr(pszfieldname))
    ELSE
       dbfgetfieldindex = -1
    ENDIF

  END FUNCTION dbfgetfieldindex
#endif


  !> It returns information about a dbf field.
  !! The return value is the type of the requested field, which is one
  !! of the \a ft* constants. The field type returned does not
  !! correspond one to one with the xBase field types. For instance the
  !! xBase field type for Date will just be returned as being
  !! ftinteger. It returns -1 if the shape object is not valid.
  FUNCTION dbfgetfieldinfo(hshp, ifield, pszfieldname, pnwidth, pndecimals)
    TYPE(shpfileobject),INTENT(inout) :: hshp !< shapefile object to query
    INTEGER,INTENT(in) :: ifield !< number of field to query, in the interval 0, nfield - 1
    CHARACTER(len=*),INTENT(out) :: pszfieldname !< the name of the field, it can be up to 11 characters long
    INTEGER,INTENT(out) :: pnwidth !< the width of the field in characters
    INTEGER,INTENT(out) :: pndecimals !< the number of decimals in a floating point representation, nonzero only for fields of type \a ftdouble
    INTEGER :: dbfgetfieldinfo

    CHARACTER(len=11) :: lpszfieldname

    IF (.NOT.dbffileisnull(hshp)) THEN
       dbfgetfieldinfo = dbfgetfieldinfo_orig(hshp%dbffile_orig, ifield, &
            lpszfieldname, pnwidth, pndecimals)
       pszfieldname = lpszfieldname ! must strip null here!
    ELSE
       dbfgetfieldinfo = -1
    ENDIF

  END FUNCTION dbfgetfieldinfo


  !> It adds a new field to an existing dataset.
  !! Note that fields can only be added to datasets with no dbf records,
  !! though this is limitation of this API, not of the file format. This
  !! function returns the number of the new field, starting from 0, or
  !! -1 in case of error.
  FUNCTION dbfaddfield(hshp, pszfieldname, etype, nwidth, ndecimals)
    TYPE(shpfileobject),INTENT(inout) :: hshp !< shapefile object to update
    CHARACTER(len=*),INTENT(in) :: pszfieldname !< the name of the new field, at most 11 characters will be used
    INTEGER,INTENT(in) :: etype !< the type of the new field, one of the \a ft* constants
    INTEGER,INTENT(in) :: nwidth !< the width of the field to be created in characters
    INTEGER,INTENT(in) :: ndecimals !< the number of decimals in a floating point representation for fields of type \a ftdouble, for the other types it should be 0
    INTEGER :: dbfaddfield

    IF (.NOT.dbffileisnull(hshp)) THEN
       dbfaddfield = dbfaddfield_orig(hshp%dbffile_orig, fchartrimtostr(pszfieldname), &
            etype, nwidth, ndecimals)
    ELSE
       dbfaddfield = -1
    ENDIF

  END FUNCTION dbfaddfield


  SUBROUTINE dbfreadintegerattribute_f(hshp, ishape, ifield, attr)
    TYPE(shpfileobject),INTENT(inout) :: hshp
    INTEGER,INTENT(in) :: ishape, ifield
    INTEGER,INTENT(out) :: attr

    IF (.NOT.dbffileisnull(hshp)) THEN
       attr = dbfreadintegerattribute_orig(hshp%dbffile_orig, ishape, ifield)
    ELSE
       attr = 0
    ENDIF

  END SUBROUTINE dbfreadintegerattribute_f


  SUBROUTINE dbfreaddoubleattribute_f(hshp, ishape, ifield, attr)
    TYPE(shpfileobject),INTENT(inout) :: hshp
    INTEGER,INTENT(in) :: ishape, ifield
    REAL(kind=c_double),INTENT(out) :: attr

    IF (.NOT.dbffileisnull(hshp)) THEN
       attr = dbfreaddoubleattribute_orig(hshp%dbffile_orig, ishape, ifield)
    ELSE
       attr = 0.0_c_double
    ENDIF

  END SUBROUTINE dbfreaddoubleattribute_f


  SUBROUTINE dbfreadstringattribute_f(hshp, ishape, ifield, attr)
    TYPE(shpfileobject),INTENT(inout) :: hshp
    INTEGER,INTENT(in) :: ishape, ifield
    CHARACTER(len=*),INTENT(out) :: attr

    IF (.NOT.dbffileisnull(hshp)) THEN
       attr = strtofchar(dbfreadstringattribute_orig(hshp%dbffile_orig, ishape, ifield), LEN(attr))
    ELSE
       attr = ''
    ENDIF

  END SUBROUTINE dbfreadstringattribute_f


#ifndef LIBSHAPE_PRE10
  !> It returns \c .TRUE. if the requested attribute is NULL valued.
  !! Note that NULL fields are represented in the .dbf file as having
  !! all spaces in the field. Reading NULL fields will result in a value
  !! of 0.0 or an empty string with the dbfreadattribute interface.
  !! It returns \c .TRUE. in case of error as well.
  !! This procedure is available only with libshape version 1.2.10 or
  !! later.
  FUNCTION dbfisattributenull(hshp, ishape, ifield)
    TYPE(shpfileobject),INTENT(inout) :: hshp !< shapefile object to query
    INTEGER,INTENT(in) :: ishape !< number of shape (record) to query
    INTEGER,INTENT(in) :: ifield !< number of field to query
    LOGICAL :: dbfisattributenull

    IF (.NOT.dbffileisnull(hshp)) THEN
       dbfisattributenull = dbfisattributenull_orig(hshp%dbffile_orig, ishape, ifield) == 0
    ELSE ! force to null
       dbfisattributenull = .FALSE.
    ENDIF

  END FUNCTION dbfisattributenull
#endif


  FUNCTION dbfwriteintegerattribute_f(hshp, ishape, ifield, attr) RESULT(dbfwriteattribute)
    TYPE(shpfileobject),INTENT(inout) :: hshp
    INTEGER,INTENT(in) :: ishape, ifield
    INTEGER,INTENT(in) :: attr
    INTEGER :: dbfwriteattribute

    IF (.NOT.dbffileisnull(hshp)) THEN
       dbfwriteattribute = dbfwriteintegerattribute(hshp%dbffile_orig, ishape, ifield, attr)
    ELSE
       dbfwriteattribute = 0
    ENDIF

  END FUNCTION dbfwriteintegerattribute_f


  FUNCTION dbfwritedoubleattribute_f(hshp, ishape, ifield, attr) RESULT(dbfwriteattribute)
    TYPE(shpfileobject),INTENT(inout) :: hshp
    INTEGER,INTENT(in) :: ishape, ifield
    REAL(kind=c_double),INTENT(in) :: attr
    INTEGER :: dbfwriteattribute

    IF (.NOT.dbffileisnull(hshp)) THEN
       dbfwriteattribute = dbfwritedoubleattribute(hshp%dbffile_orig, ishape, ifield, attr)
    ELSE
       dbfwriteattribute = 0
    ENDIF

  END FUNCTION dbfwritedoubleattribute_f


  FUNCTION dbfwritestringattribute_f(hshp, ishape, ifield, attr) RESULT(dbfwriteattribute)
    TYPE(shpfileobject),INTENT(inout) :: hshp
    INTEGER,INTENT(in) :: ishape, ifield
    CHARACTER(len=*),INTENT(in) :: attr
    INTEGER :: dbfwriteattribute

    IF (.NOT.dbffileisnull(hshp)) THEN
       dbfwriteattribute = dbfwritestringattribute(hshp%dbffile_orig, ishape, ifield, fchartostr(attr))
    ELSE
       dbfwriteattribute = 0
    ENDIF

  END FUNCTION dbfwritestringattribute_f


  FUNCTION dbfwritenullattribute_f(hshp, ishape, ifield) RESULT(dbfwriteattribute)
    TYPE(shpfileobject),INTENT(inout) :: hshp
    INTEGER,INTENT(in) :: ishape, ifield
    INTEGER :: dbfwriteattribute

    IF (.NOT.dbffileisnull(hshp)) THEN
       dbfwriteattribute = dbfwritenullattribute(hshp%dbffile_orig, ishape, ifield)
    ELSE
       dbfwriteattribute = 0
    ENDIF

  END FUNCTION dbfwritenullattribute_f


#ifndef LIBSHAPE_PRE10
  !> It returns the dbf type code of the requested field.
  !! The return value is a single character and it can assume the
  !! following values:
  !!
  !! - 'C' (String)
  !! - 'D' (Date)
  !! - 'F' (Float)
  !! - 'N' (Numeric, with or without decimal)
  !! - 'L' (Logical)
  !! - 'M' (Memo: 10 digits .DBT block ptr)
  !! - ' ' (field out of range or other error)
  !!
  !! This procedure is available only with libshape version 1.2.10 or
  !! later.
  FUNCTION dbfgetnativefieldtype(hshp, ifield)
    TYPE(shpfileobject),INTENT(inout) :: hshp !< shapefile object to query
    INTEGER,INTENT(in) :: ifield !< number of field to query
    CHARACTER(len=1) :: dbfgetnativefieldtype

    IF (.NOT.dbffileisnull(hshp)) THEN
       dbfgetnativefieldtype = CHAR(dbfgetnativefieldtype_orig(hshp%dbffile_orig, ifield))
    ELSE ! force to null
       dbfgetnativefieldtype = ' '
    ENDIF

  END FUNCTION dbfgetnativefieldtype
#endif


  SUBROUTINE shpsetobjectfortran(ftnobject, cobject, nshptype, nshapeid, &
       nparts, panpartstart, panparttype, &
       nvertices, padfx, padfy, padfz, padfm, &
       dfxmin, dfymin, dfzmin, dfmmin, dfxmax, dfymax, dfzmax, dfmmax) &
       BIND(C,name='SHPSetObjectFortran')
    TYPE(c_ptr),VALUE :: ftnobject
    TYPE(c_ptr),VALUE :: cobject
    INTEGER(kind=c_int) :: nshptype ! Shape Type (SHPT_* - see list above)
    INTEGER(kind=c_int) :: nshapeid ! Shape Number (-1 is unknown/unassigned)
    INTEGER(kind=c_int) :: nparts ! # of Parts (0 implies single part with no info)
    INTEGER(kind=c_int),TARGET :: panpartstart(nparts), & ! Start Vertex of part
         panparttype(nparts) ! Part Type (SHPP_RING if not SHPT_MULTIPATCH)
    INTEGER(kind=c_int) :: nvertices ! Vertex list 
    REAL(kind=c_double),TARGET ::  padfx(nvertices), padfy(nvertices), &
         padfz(nvertices), padfm(nvertices) ! (all zero if not provided)
    REAL(kind=c_double) :: & ! Bounds in X, Y, Z and M dimensions
         dfxmin, dfymin, dfzmin, dfmmin, dfxmax, dfymax, dfzmax, dfmmax

    TYPE(shpobject),POINTER :: obj

    CALL C_F_POINTER(ftnobject, obj)

    obj%shpobject_orig = cobject
    obj%nshptype = nshptype
    obj%nshapeid = nshapeid
    obj%nparts = nparts
    obj%panpartstart => panpartstart
    obj%panparttype => panparttype
    obj%nvertices = nvertices
    obj%padfx => padfx
    obj%padfy => padfy
    obj%padfz => padfz
    obj%padfm => padfm
    obj%dfxmin = dfxmin
    obj%dfymin = dfymin
    obj%dfzmin = dfzmin
    obj%dfmmin = dfmmin
    obj%dfxmax = dfxmax
    obj%dfymax = dfymax
    obj%dfzmax = dfzmax
    obj%dfmmax = dfmmax

  END SUBROUTINE shpsetobjectfortran

  subroutine shpReTraceObject(hshp, shpobj,leps,eps)
    implicit none
    TYPE(shpfileobject),INTENT(inout) :: hshp !< shapefile object to read from
    TYPE(shpobject),INTENT(inout) :: shpobj !< shape object to test
    logical :: leps
    real :: eps
    !
    logical :: cl    ! last node in ring
    integer :: cii   ! start index
    real :: cpos(3)  ! start node of ring
    logical :: ol    ! does previous ring exist
    integer :: oii   ! stop index
    real :: opos(3)  ! stop node of previous ring
    type(shpSeg), pointer :: cs
    integer :: ii
    call shpClearSegment(shpobj)
    ol=.false.   ! previous ring does not exist
    oii=0
    cl=.true.    ! should we start a new ring?
    cii=0
    if (shape_bdeb) write(*,*)'Initial number of vertices:',&
         & shpobj%nvertices,leps
    if (associated(shpobj%valid)) deallocate(shpobj%valid)
    if (associated(shpobj%actual)) deallocate(shpobj%actual)
    allocate(shpobj%valid(shpobj%nvertices),&
         & shpobj%actual(shpobj%nvertices))
    do ii=1,shpobj%nvertices
       shpobj%valid(ii) = .TRUE.
       shpobj%actual(ii)= .TRUE.
    end do
    do ii=1,shpobj%nvertices
       if (cl) then
          cl=.false. ! do not start a new ring until we find end of this ring
          if (ol) then ! add segment c->o to front of list
             allocate(cs)
             cs%spos(1)=shpobj%padfx(ii) ! start point
             cs%spos(2)=shpobj%padfy(ii)
             cs%spos(3)=shpobj%padfz(ii)
             cs%epos(1)=opos(1) ! end point
             cs%epos(2)=opos(2)
             cs%epos(3)=opos(3)
             ! add to front of list
             shpObj%nseg=shpObj%nseg+1
             cs%next=>shpObj%firstSegment%next
             cs%prev=>shpObj%firstSegment
             shpObj%firstSegment%next%prev => cs
             shpObj%firstSegment%next => cs
             nullify(cs)
             ! simplify ring...
             if (leps) then
                call shape_simplify(shpObj,cii,oii,eps)
             end if
          end if
          cii=ii
          cpos(1)=shpobj%padfx(ii)
          cpos(2)=shpobj%padfy(ii)
          cpos(3)=shpobj%padfz(ii)
       else if (cpos(1).eq.shpobj%padfx(ii).and.cpos(2).eq.shpobj%padfy(ii)) then
          shpObj%actual(ii)=.false. ! next segment is not actual
          cl=.true. ! start a new ring
          ol=.true. ! previous ring exists
          oii=ii
          opos(1)=shpobj%padfx(ii)
          opos(2)=shpobj%padfy(ii)
          opos(3)=shpobj%padfz(ii)
          if (leps) then
             call shape_simplify(shpObj,cii,oii,eps)
          end if
       end if
    end do 
    if (.not.cl ) then ! last ring was not closed properly
       if (leps) then
          oii=ii
          call shape_simplify(shpObj,cii,oii,eps)
       end if
       ! close ring
       allocate(cs)
       cs%spos(1)=shpobj%padfx(ii)! start point
       cs%spos(2)=shpobj%padfy(ii)
       cs%spos(3)=shpobj%padfz(ii)
       cs%epos(1)=cpos(1) ! end point
       cs%epos(2)=cpos(2)
       cs%epos(3)=cpos(3)
       ! add to front of list
       shpObj%nseg=shpObj%nseg+1
       cs%next=>shpObj%firstSegment%next
       cs%prev=>shpObj%firstSegment
       shpObj%firstSegment%next%prev => cs
       shpObj%firstSegment%next => cs
       nullify(cs)
    end if
    ! check if rings are already closed (if so delete all segments)
    if (shpObj%nseg .gt. 0) then
       if (shpObj%firstSegment%next%spos(1).eq.shpObj%lastSegment%prev%epos(1).and. &
            shpObj%firstSegment%next%spos(2).eq.shpObj%lastSegment%prev%epos(2).and. &
            shpObj%firstSegment%next%spos(3).eq.shpObj%lastSegment%prev%epos(3)) then
          call shpClearSegment(shpObj)
       end if
    end if
    return
  end subroutine shpReTraceObject
  
  ! SUBROUTINE PNPOLY C
  ! PURPOSE
  ! TO DETERMINE WHETHER A POINT IS INSIDE A POLYGON
  !
  ! USAGE
  ! CALL PNPOLY (PX, PY, N, XX, YY, INOUT )
  !
  ! DESCRIPTION OF THE PARAMETERS
  !
  ! PX - X-COORDINATE OF POINT IN QUESTION.
  !
  ! PY - Y-COORDINATE OF POINT IN QUESTION.
  !
  ! N - NUMBER OF VERTICES IN THE POLYGON.
  !
  ! XX - N LONG VECTOR CONTAINING X-COORDINATES OF VERTICES OF POLYGON.
  !
  ! YY - N LONG VECTOR CONTAING Y-COORDINATES OF VERTICES OF POLYGON.
  !
  ! INOUT - THE SIGNAL RETURNED:
  !
  ! -1 IF THE POINT IS OUTSIDE OF THE POLYGON,
  !
  ! 0 IF THE POINT IS ON AN EDGE OR AT A VERTEX,
  !
  ! 1 IF THE POINT IS INSIDE OF THE POLYGON.
  !
  ! REMARKS
  ! THE VERTICES MAY BE LISTED CLOCKWISE OR ANTICLOCKWISE.
  ! THE FIRST MAY OPTIONALLY BE REPEATED, IF SO N MAY
  ! OPTIONALLY BE INCREASED BY 1.
  ! THE INPUT POLYGON MAY BE A COMPOUND POLYGON CONSISTING
  ! OF SEVERAL SEPARATE SUBPOLYGONS. IF SO, THE FIRST VERTEX
  ! OF EACH SUBPOLYGON MUST BE REPEATED, AND WHEN CALCULATING
  ! N, THESE FIRST VERTICES MUST BE COUNTED TWICE.
  ! INOUT IS THE ONLY PARAMETER WHOSE VALUE IS CHANGED.
  ! THE SIZE OF THE ARRAYS MUST BE INCREASED IF N > MAXDIM
  ! WRITTEN BY RANDOLPH FRANKLIN, UNIVERSITY OF OTTAWA, 7/70.
  !
  !
  !     ..................................................................
  !
  !        SUBROUTINE PNPOLY
  !
  !        PURPOSE
  !           TO DETERMINE WHETHER A POINT IS INSIDE A POLYGON
  !
  !        USAGE
  !           CALL PNPOLY (PX, PY, N, XX, YY, INOUT )
  !
  !        DESCRIPTION OF THE PARAMETERS
  !           PX      - X-COORDINATE OF POINT IN QUESTION.
  !           PY      - Y-COORDINATE OF POINT IN QUESTION.
  !           N       - NUMBER OF VERTICES IN THE POLYGON.
  !           XX      - N LONG VECTOR CONTAINING X-COORDINATES OF
  !                     VERTICES OF POLYGON.
  !           YY      - N LONG VECTOR CONTAING Y-COORDINATES OF
  !                     VERTICES OF POLYGON.
  !           INOUT   - THE SIGNAL RETURNED:
  !                     -1 IF THE POINT IS OUTSIDE OF THE POLYGON,
  !                      0 IF THE POINT IS ON AN EDGE OR AT A VERTEX,
  !                      1 IF THE POINT IS INSIDE OF THE POLYGON.
  !
  !        REMARKS
  !           THE VERTICES MAY BE LISTED CLOCKWISE OR ANTICLOCKWISE.
  !           THE FIRST MAY OPTIONALLY BE REPEATED, IF SO N MAY
  !           OPTIONALLY BE INCREASED BY 1.
  !           THE INPUT POLYGON MAY BE A COMPOUND POLYGON CONSISTING
  !           OF SEVERAL SEPARATE SUBPOLYGONS. IF SO, THE FIRST VERTEX
  !           OF EACH SUBPOLYGON MUST BE REPEATED, AND WHEN CALCULATING
  !           N, THESE FIRST VERTICES MUST BE COUNTED TWICE.
  !           INOUT IS THE ONLY PARAMETER WHOSE VALUE IS CHANGED.
  !           THE SIZE OF THE ARRAYS MUST BE INCREASED IF N > MAXDIM
  !           WRITTEN BY RANDOLPH FRANKLIN, UNIVERSITY OF OTTAWA, 7/70.
  !
  !        SUBROUTINES AND FUNCTION SUBPROGRAMS REQUIRED
  !           NONE
  !
  !        METHOD
  !           A VERTICAL LINE IS DRAWN THRU THE POINT IN QUESTION. IF IT
  !           SHAPE_CROSSES THE POLYGON AN ODD NUMBER OF TIMES, THEN THE
  !           POINT IS INSIDE OF THE POLYGON.
  !
  !     ..................................................................
  !
  SUBROUTINE shape_pnpoly(PX,PY,N,X,Y,INOUT)
    ! Run semi-infinite ray horizontally (increasing x, fixed y)
    ! out from the test point, and count how many edges it crosses.
    ! At each crossing, the ray switches between inside and outside.
    ! This is called the Jordan curve theorem. 
    implicit none
    integer n,inout
    REAL PX,PY,X(N),Y(N),MM
    LOGICAL MX,MY,NX,NY
    INTEGER :: i,j,unt,cnt=0
    INOUT=-1 ! point is outside
    if (n.le.1) return
    i=1
    j=2
    LOOP: DO I=1,N
       J=1+MOD(I,N)
       mx=x(i).ge.px
       nx=x(j).ge.px
       my=y(i).ge.py
       ny=y(j).ge.py
       ! find out if segment crosses horisontal ray to the right og the point
       if ((my.and..not.ny).or.(.not.my.and.ny)) then ! crosses left or right
          if ((mx.and..not.nx).or.(.not.mx.and.nx)) then ! may cross right
             MM=(px-x(i))-(x(j)-x(i))*(py-y(i))/(y(j)-y(i))
             if (abs(mm).lt.1.0D-10) then ! point on segment (undetermined)
                inout=0
                if (shape_bdeb)write(*,*) 'Segment crossing:',i,x(i)-px,y(i)-py,j,x(j)-px,y(j)-py,inout
                return
             else if (MM .lt. 0.0D0) then ! crosses right of point
                inout=-inout
                if (shape_bdeb)write(*,*) 'Proximity crossing:',i,x(i)-px,y(i)-py,j,x(j)-px,y(j)-py,inout
             else
                if (shape_bdeb)write(*,*) 'Close crossing:',i,x(i)-px,y(i)-py,j,x(j)-px,y(j)-py,inout
             end if
          else if (mx.and.nx) then ! crosses right of point for sure
             inout=-inout
             if (shape_bdeb)write(*,*) 'Clear crossing:',i,x(i)-px,y(i)-py,j,x(j)-px,y(j)-py,inout
          end if
       end if
    end do LOOP
    if (shape_bdeb) then
       cnt=cnt+1
       unt=10+mod(cnt,50)
       if (inout.eq.-1) then
          write(*,*) 'Outside:',px,py,inout,unt
       else if (inout.eq.0) then
          write(*,*) 'Border:',px,py,inout,unt
       else
          write(*,*) 'Inside:',px,py,inout,unt
       end if
#ifdef JNK
       DO I=1,N
          J=1+MOD(I,N)
          mx=x(i).ge.px
          nx=x(j).ge.px
          my=y(i).ge.py
          ny=y(j).ge.py
          write(unt,'(2(2X,I0,X,2(F12.5),2L1))') i,x(i)-px,y(i)-py,mx,my,&
               & j,x(j)-px,y(j)-py,nx,ny
       end do
#endif
    end if
  end SUBROUTINE shape_pnpoly
  SUBROUTINE shape_pnpoly_old(PX,PY,N,XX,YY,INOUT)
    implicit none
    integer n,inout
    REAL PX,PY,XX(N),YY(N)
    LOGICAL MX,MY,NX,NY
    INTEGER i,j, old
    real X(n),Y(n),mm
    old=-10
    INOUT=-1 ! point is outside
    if (n.le.1) return
    DO I=1,N
       X(I)=XX(I)-PX
       Y(I)=YY(I)-PY
    end do
    i=1
    j=2
    if (shape_bdeb)write(*,*) 'Loop:',i,x(i),y(i),j,x(j),y(j),inout
    LOOP: DO I=1,N
       J=1+MOD(I,N)
       MX=X(I).GE.0.0
       NX=X(J).GE.0.0
       MY=Y(I).GE.0.0
       NY=Y(J).GE.0.0
       IF(.NOT.((MY.OR.NY).AND.(MX.OR.NX)).OR.(MX.AND.NX)) CYCLE LOOP
       IF(.NOT.(MY.AND.NY.AND.(MX.OR.NX).AND..NOT.(MX.AND.NX))) then
          mm=(Y(I)*X(J)-X(I)*Y(J))/(X(J)-X(I))
          if (shape_bdeb)write(*,*) 'MM:',mm,inout
          IF(mm.lt.0) then
             cycle loop
          else if (mm.eq.0) then
             inout=0 ! point is on a vertex
             return
          else if (mm.gt.0) then
             INOUT=-INOUT
             if (shape_bdeb)write(*,*) 'Loop:',i,x(i),y(i),j,x(j),y(j),inout
             cycle loop
          end if
       end if
       INOUT=-INOUT
       if (shape_bdeb)write(*,*) 'Loop:',i,x(i),y(i),j,x(j),y(j),inout
       CYCLE LOOP
    end do LOOP
    RETURN
  END SUBROUTINE shape_pnpoly_old
  !
  real function shape_ddpoly(POS,N,XPOS,ACTUAL)
    ! gives smalles distance to cartesian polygon
    implicit none
    integer n
    real pos(3),xpos(3,n)
    logical actual(n)
    INTEGER i,j
    real dd,ddmin
    logical llmin
    shape_ddpoly=-1.0D0
    llmin=.false.
    ddmin=-1.0D0
    if (n.le.1) return
    LOOP: DO I=1,N
       J=1+MOD(I,N)
       if (actual(i)) then
          dd=shape_getDist(pos,xpos(1,i),xpos(1,j))
          if (llmin) then
             ddmin=min(ddmin,dd)
          else
             ddmin=dd
             llmin=.true.
          end if
       end if
    end do LOOP
    shape_ddpoly=ddmin
    RETURN
  END function shape_ddpoly
  !
  REAL(kind=8) FUNCTION length2(x)
    IMPLICIT NONE
    REAL(kind=8),DIMENSION(2) :: x 
    length2 = dsqrt(DOT_PRODUCT(x,x))
  END FUNCTION length2

  ! Calcule la distance d'un point P a un segment (V1,V2)
  ! Input     vP  : coordonnees du point P
  !           v1  : coordonnees du debut du segment V1
  !           v2  : coordonnees de la fin du segment V2
  function perpendicularDistance(vP, v1, v2)
    implicit none
    REAL(kind=8)              :: perpendicularDistance
    REAL(kind=8),DIMENSION(2) :: vP,v1,v2,LI,LP
    LI = v2 - v1
    LP = vP - v1
    perpendicularDistance = abs( LI(1) * LP(2) - LP(1) * LI(2)) / length2(LI)
  end function perpendicularDistance

  ! simplification of a polygon based on RamerDouglasPeucker algorithm
  ! Input    v(2,n)   : coordinates of the vertices
  !          i1       : indice of first vertex
  !          i2       : indice of last vertex
  !          eps      : distance of simplification
  ! Output   valid(n) : boolean to know if this vertex belongs or not to the simplified polygon
  recursive subroutine shape_DouglasPeuckerRecursive(v, i1, i2, eps, valid)
    implicit none
    INTEGER,INTENT(IN)                   :: i1,i2
    REAL(kind=8),INTENT(IN)              :: eps
    REAL(kind=8),DIMENSION(:,:),POINTER  :: v
    LOGICAL,DIMENSION(:),POINTER         :: valid
    INTEGER                              :: ip,imax
    REAL(kind=8)                         :: dist,dmax
    dmax = 0.D0
    imax = 1
    ! regarde les points intermediaires
    ! et calcule la distance perpenticulaire maximale
    DO ip = i1+1,i2-1
       dist = perpendicularDistance(v(:,ip), v(:,i1), v(:,i2))
       IF ( dist > dmax ) THEN
          imax = ip
          dmax = dist
       ENDIF
    ENDDO
    ! si la distance perpenticulaire maximale est plus grande que eps, 
    ! simplifie les 2 branches [i1,imax] et [imax,i2]
    IF ( dmax > eps ) THEN
       call shape_DouglasPeuckerRecursive(v, i1, imax, eps, valid)
       call shape_DouglasPeuckerRecursive(v, imax, i2, eps, valid)
       ! sinon on vire tous les points entre i1 et i2   
    ELSE
       valid(i1+1:i2-1) = .FALSE.
    ENDIF
  end subroutine shape_DouglasPeuckerRecursive

  real function log2(x)
    implicit none
    real, intent(in) :: x
    log2 = log(x) / log(2.)
  end function log2

  ! simplification of a polygon based on RamerDouglasPeucker algorithm
  ! Input    v(2,n)   : coordinates of the vertices
  !          i1       : indice of first vertex
  !          i2       : indice of last vertex
  !          eps      : distance of simplification
  ! Output   valid(n) : boolean to know if this vertex belongs or not to the simplified polygon
  recursive subroutine shape_DouglasPeuckerIteratif(v, eps, valid)
    implicit none
    REAL(kind=8),INTENT(IN)              :: eps
    REAL(kind=8),DIMENSION(:,:),POINTER  :: v
    LOGICAL,DIMENSION(:),POINTER         :: valid
    INTEGER                              :: i1,i2
    INTEGER                              :: ip,imax
    REAL(kind=8)                         :: dist,dmax
    integer, dimension(:,:), pointer     :: loop_index
    integer                              :: offset_loop_index
    integer                              :: next_loop_index
    integer                              :: nbp
    integer                              :: nb_sub_step
    nbp = size(valid)
    nb_sub_step = 2 ** ( ceiling( log2( real(nbp) - 1 ) ) + 1 )
    allocate( loop_index( 2, nb_sub_step ) )
    loop_index = -1
    loop_index( : , 1 ) = (/ 1, nbp /)
    ! print *, loop_index
    offset_loop_index = 1
    next_loop_index   = 1
    i1 = loop_index( 1, offset_loop_index )
    i2 = loop_index( 2, offset_loop_index )
    do while( (i1 /= -1) .and. (i2 /= -1) .and. (offset_loop_index <= nb_sub_step) )
       dmax = 0.D0
       imax = 1
       ! regarde les points intermediaires
       ! et calcule la distance perpenticulaire maximale
       DO ip = i1+1,i2-1
          dist = perpendicularDistance(v(:,ip), v(:,i1), v(:,i2))
          IF ( dist > dmax ) THEN
             imax = ip
             dmax = dist
          ENDIF
       ENDDO
       ! si la distance perpenticulaire maximale est plus grande que eps, 
       ! simplifie les 2 branches [i1,imax] et [imax,i2]
       IF ( dmax > eps ) THEN
          ! call shape_DouglasPeuckerRecursive(v, i1, imax, eps, valid)
          next_loop_index = next_loop_index + 1
          loop_index( 1, next_loop_index ) = i1
          loop_index( 2, next_loop_index ) = imax
          ! call shape_DouglasPeuckerRecursive(v, imax, i2, eps, valid)
          next_loop_index = next_loop_index + 1
          loop_index( 1, next_loop_index ) = imax
          loop_index( 2, next_loop_index ) = i2
          ! sinon on vire tous les points entre i1 et i2   
       ELSE
          valid(i1+1:i2-1) = .FALSE.
       ENDIF
       offset_loop_index = offset_loop_index + 1
       i1 = loop_index( 1, offset_loop_index )
       i2 = loop_index( 2, offset_loop_index )
    end do  ! END - do while
    deallocate(loop_index)
  end subroutine shape_DouglasPeuckerIteratif

  ! Does not work over 180-meridian
  subroutine shape_simplify(shpobj,cii,oii,eps)
    IMPLICIT NONE
    TYPE(shpobject),INTENT(inout) :: shpobj     ! shape object to simplify
    integer :: cii,oii                          ! start end vertice index
    real :: eps                                 ! tolerance in km
    !
    integer :: ii
    real :: pst
    INTEGER                                 :: nbp
    REAL(kind=8),DIMENSION(:,:),POINTER     :: points
    LOGICAL,DIMENSION(:),POINTER            :: valid
    real :: re=6371.0D0 ! earth radius in km
    logical :: meet
    !
    ! For the ramer-douglas-peucker algorithm, the last point must be different
    ! of the first point to avoid a division by 0 in 'perpendicularDistance()'
    ! nbp = 10
    ! allocate(points(2,nbp))
    meet=(shpobj%padfx(cii).eq.shpobj%padfx(oii) .and. &
         & shpobj%padfy(cii).eq.shpobj%padfy(oii))
    if (meet) then
       nbp=oii-cii
    else
       nbp=oii-cii-1
    end if
    if (nbp.le.3) return
    allocate(points(2,nbp),valid(nbp))
    do ii=1,nbp
       points(1,ii)=shape_degtor(shpobj%padfy(ii))*re                      ! latitude
       points(2,ii)=shape_degtor(shpobj%padfx(ii))*re*shape_cosdeg(shpobj%padfy(ii))  ! longitude
       valid(ii)=.true.
    end do
    call shape_DouglasPeuckerRecursive(points, 1, nbp, eps, valid)
    do ii=cii,nbp+cii-1
       shpobj%valid(ii)=valid(ii-cii+1)
    end do
    shpobj%valid(cii)=.true.
    if (meet) shpobj%valid(oii)=.true.
    !call shape_DouglasPeuckerIteratif(points, eps, valid)
    deallocate( points )
    deallocate( valid )
    return
  end subroutine shape_simplify
  
  logical function shape_inside(plon,plat,minlon,minlat,maxlon,maxlat)
    implicit none
    real plon,plat,minlon,minlat,maxlon,maxlat
    shape_inside= (plon.ge.minlon.and. &
         & plon.le.maxlon.and. &
         & plat.ge.minlat.and. &
         & plat.le.maxlat)
    return
  end function shape_inside
  
  real function shape_getDistBox(pos,mimi,mima,mami,mama)
    implicit none
    real pos(3),mimi(3),mima(3),mami(3),mama(3)
    real :: d1,d2,d3,d4
    d1=shape_getDist(pos,mimi,mima)
    d2=shape_getDist(pos,mima,mama)
    d3=shape_getDist(pos,mama,mami)
    d4=shape_getDist(pos,mami,mimi)
    shape_getDistBox=min(d1,d2,d3,d4)
    return
  end function shape_getDistBox
  real function shape_getDist(p,a,b)
    ! get distance between point (P) and segment (between A and B)
    implicit none
    real :: p(3)
    real :: a(3)
    real :: b(3)
    real :: ab(3) ! A-B
    real :: ap(3) ! A-P
    real :: bp(3) ! B-P
    real :: dab,dd,r
    call shape_subtract(b,a,ab)
    call shape_subtract(p,a,ap)
    dab=dot_product(ab,ab)
    if (dab.lt.1.0D-10) then ! A and B are identical
       shape_getDist=dsqrt(dot_product(ap,ap))
    else
       dd=dot_product(ab,ap)
       r=dd/dab
       if (r.le.0.0D0) then ! a is closest
          shape_getDist=sqrt(dot_product(ap,ap))
       else if (r.ge.1.0D0) then ! b=closest
          call shape_subtract(p,b,bp)
          shape_getDist=sqrt(dot_product(bp,bp))
       else ! between a and b
          shape_getDist=sqrt(max(0.0D0,dot_product(ap,ap) - dab*(R**2)))
       end if
    end if
    return
  end function shape_getDist
  subroutine shape_lonlat2pos(lon,lat,pos)
    implicit none
    real :: lat,lon,pos(3),rr
    pos(3) = shape_sindeg(lat)
    rr     = shape_cosdeg(lat)
    pos(1) = rr*shape_cosdeg(lon)
    pos(2) = rr*shape_sindeg(lon)
    return
  end subroutine shape_lonlat2pos

  subroutine shape_cross(a, b, c)
    real, dimension(3), intent(in) :: a, b
    real, dimension(3), intent(out) :: c
    c(1) = a(2) * b(3) - a(3) * b(2)
    c(2) = a(3) * b(1) - a(1) * b(3)
    c(3) = a(1) * b(2) - a(2) * b(1)
    return
  end subroutine shape_cross
  
  subroutine shape_divide(a, b, c)
    real, dimension(3), intent(in) :: a
    real, intent(in) :: b
    real, dimension(3), intent(out) :: c
    c(1) = a(1) /b
    c(2) = a(2) /b
    c(3) = a(3) /b
    return
  end subroutine shape_divide

  subroutine shape_multiply(a, b, c)
    real, dimension(3), intent(in) :: a
    real, intent(in) :: b
    real, dimension(3), intent(out) :: c
    c(1) = a(1) * b
    c(2) = a(2) * b
    c(3) = a(3) * b
    return
  end subroutine shape_multiply
  
  real function shape_dot(a, b)
    real, dimension(3), intent(in) :: a
    real, dimension(3), intent(in) :: b
    shape_dot = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
    return
  end function shape_dot
  
  subroutine shape_subtract(a, b, c)
    real, dimension(3), intent(in) :: a, b
    real, dimension(3), intent(out) :: c
    c(1) = a(1) - b(1)
    c(2) = a(2) - b(2)
    c(3) = a(3) - b(3)
    return
  end subroutine shape_subtract
  
  real function shape_getAngle(apos,bpos)
    implicit none
    real :: apos(3),bpos(3),dd ! assuming normalised vectors
    dd=dot_product(apos,bpos)
    shape_getAngle=shape_acosdeg(dd)
    return
  end function shape_getAngle
  
  character*20 function string20(pos)
    real :: pos(3)
    write(string20,'(F6.3,X,F6.3,X,F6.3)') pos
  end function string20
    
  real function shape_degtor(x)
    implicit none
    real :: x
    real :: pi
    parameter (pi=3.14159265359)
    shape_degtor=x*pi/180.
  end function shape_degtor

  real function shape_rtodeg(x)
    implicit none
    real :: x
    real :: pi
    parameter (pi=3.14159265359)
    shape_rtodeg=x*180./pi
  end function shape_rtodeg

  real function shape_sindeg(x)
    implicit none
    real :: x
    shape_sindeg=sin(shape_degtor(x))
  end function shape_sindeg

  real function shape_cosdeg(x)
    implicit none
    real :: x
    shape_cosdeg=cos(shape_degtor(x))
  end function shape_cosdeg

  real function shape_tandeg(x)
    implicit none
    real :: x
    shape_tandeg=tan(shape_degtor(x))
  end function shape_tandeg

  real function shape_asindeg(x)
    implicit none
    real :: x
    shape_asindeg=shape_rtodeg(asin(x))
  end function shape_asindeg

  real function shape_acosdeg(x)
    implicit none
    real :: x
    shape_acosdeg=shape_rtodeg(acos(x))
  end function shape_acosdeg

  real function shape_atandeg(x)
    implicit none
    real :: x
    shape_atandeg=shape_rtodeg(atan(x))
  end function shape_atandeg

  real function atan2deg(y,x)
    implicit none
    real :: y,x
    atan2deg=shape_rtodeg(atan2(y,x))
  end function atan2deg

  ! !
  ! real function shape_degtor(x)
  !   implicit none
  !   real(kind=8),INTENT(IN)  :: x
  !   real pi
  !   parameter (pi=3.14159265359)
  !   shape_degtor=x*pi/180.
  ! end function shape_degtor

  ! real function shape_rtodeg(x)
  !   implicit none
  !   real(kind=8),INTENT(IN)  :: x
  !   real pi
  !   parameter (pi=3.14159265359)
  !   shape_rtodeg=x*180./pi
  ! end function shape_rtodeg
  ! !
  ! real function shape_sindeg(x)
  !   implicit none
  !   real(kind=8),INTENT(IN)  :: x
  !   shape_sindeg=sin(shape_degtor(x))
  ! end function shape_sindeg

  ! real function shape_cosdeg(x)
  !   implicit none
  !   real(kind=8),INTENT(IN)  :: x
  !   shape_cosdeg=cos(shape_degtor(x))
  ! end function shape_cosdeg

END MODULE shape

#__file: 'libsort/sort.F90' 0100644    **DO NOT DELETE**
module sort
  IMPLICIT NONE
  !
  ! Global constants
  !
  logical     :: sort_bdeb=.false.
  !
  CONTAINS
  !
  !###############################################################################
  ! SORTING ROUTINES
  !###############################################################################
  !
  subroutine sort_heapsearch1r(maxnn,key,eps,nn,ind,tkey,left,right)
    !
    implicit none
    !
    integer :: maxnn
    real :: key(maxnn)
    real :: eps ! tolerance
    integer :: nn
    integer :: ind(nn)
    real :: tkey
    integer :: left
    integer :: right
    !
    real :: mid
    integer :: mfl,mcl,kfl,kcl,mch
    logical bdone
    !
    if (nn.eq.0) then
       left=-1                ! first element regardless of value
       return
    end if
    !
    left = 1
    right = nn
    do
       mid=float(left+right)/2.0D0
       mfl=floor(mid)
       mcl=ceiling(mid)
       kfl=sort_cmpr(tkey,key(ind(mfl)),eps)
       kcl=sort_cmpr(tkey,key(ind(mcl)),eps)
       !write(*,'(X,A,X,I3,F9.2,5(X,I3),3(X,F9.2),2(X,I5))')'sort_heapsearch:',left,mid,right,mfl,mcl,kfl,kcl,&
       !& tkey,key(ind(mfl)),key(ind(mcl)),ind(mfl),ind(mcl)
       if (kfl.eq.0) then        ! target is at ceiling => exit
          left=mfl
          right=mfl
          exit
       else if (kcl.eq.0) then   ! target is at floor => exit
          left=mcl
          right=mcl
          exit
       else if (kfl.gt.0) then   ! target is lower than floor
          IF (left.eq.right) then
             right=mfl-1
             exit ! out of bounds -> exit
          else
             right=mfl
          end if
       else if (kcl.lt.0) then   ! target is higher than ceiling
          if (left.eq.right) then
             left=mcl+1
             exit ! out of bounds -> exit
          else
             left=mcl
          end if
       else                      ! target is between floor and ceiling => exit
          left=mfl
          right=mcl
          exit
       end if
    end do
    IF (left > right) return
    !find first match...
    bdone=(left<2)
    do while (.not.bdone)
       mch=sort_cmpr(tkey, key(ind(left-1)),eps)
       if (mch == 0) then ! equal or target is below
          left=left-1
          bdone=(left<2)
       else
          bdone=.true.
       end if
    end do
    !find last match
    bdone=(right>nn-1)
    do while (.not.bdone)
       mch=sort_cmpr(tkey, key(ind(right+1)),eps)
       if (mch == 0) then ! equal or target is above
          right=right+1
          bdone=(right>nn-1)
       else
          bdone=.true.
       end if
    end do
    !
  end subroutine sort_heapsearch1r
  !
  subroutine sort_heapsearch1i(maxnn,key,nn,ind,tkey,left,right)
    !
    implicit none
    !
    integer :: maxnn
    integer, allocatable :: key(:)
    integer :: nn
    integer,allocatable :: ind(:)
    integer :: tkey
    integer :: left
    integer :: right
    !
    real :: mid
    integer :: mfl,mcl,kfl,kcl,mch
    logical bdone
    !
    if (nn.eq.0) then
       left=-1                ! first element regardless of value
       return
    end if
    !
    left = 1
    right = nn
    do
       mid=float(left+right)/2.0D0
       mfl=floor(mid)
       mcl=ceiling(mid)
       kfl=sort_cmpi(tkey,key(ind(mfl)))
       kcl=sort_cmpi(tkey,key(ind(mcl)))
       !write(*,'(X,A,X,I3,F0.2,5(X,I3),3(X,F0.2),2(X,I0))')'sort_heapsearch:',left,mid,right,mfl,mcl,kfl,kcl,&
       !& tkey,key(ind(mfl)),key(ind(mcl)),ind(mfl),ind(mcl)
       if (kfl.eq.0) then        ! target is at ceiling => exit
          left=mfl
          right=mfl
          exit
       else if (kcl.eq.0) then   ! target is at floor => exit
          left=mcl
          right=mcl
          exit
       else if (kfl.gt.0) then   ! target is lower than floor
          IF (left.eq.right) then
             right=mfl-1
             exit ! out of bounds -> exit
          else
             right=mfl
          end if
       else if (kcl.lt.0) then   ! target is higher than ceiling
          if (left.eq.right) then
             left=mcl+1
             exit ! out of bounds -> exit
          else
             left=mcl
          end if
       else                      ! target is between floor and ceiling => exit
          left=mfl
          right=mcl
          exit
       end if
    end do
    IF (left > right) return
    !find first match...
    bdone=(left<2)
    do while (.not.bdone)
       mch=sort_cmpi(tkey, key(ind(left-1)))
       if (mch == 0) then ! equal or target is below
          left=left-1
          bdone=(left<2)
       else
          bdone=.true.
       end if
    end do
    !find last match
    bdone=(right>nn-1)
    do while (.not.bdone)
       mch=sort_cmpi(tkey, key(ind(right+1)))
       if (mch == 0) then ! equal or target is above
          right=right+1
          bdone=(right>nn-1)
       else
          bdone=.true.
       end if
    end do
    !
  end subroutine sort_heapsearch1i
  !
  subroutine sort_heapsort1r(mm,key1,eps,newnn,nn,ind,uniq)
    !
    !! Generate sorted index for key1 
    !
    implicit none

    integer :: mm                ! Number of elements
    real :: key1(mm)             ! key
    real :: eps                  ! key tolerance (when are they equal)
    integer :: newnn             ! new number of keys
    integer :: nn                ! Number of elements
    integer :: ind(nn)           ! Resulting sorted index
    logical uniq               ! Ignore duplicate records
    !
    integer :: ii,dmp

    if (nn.eq.0) then
       newnn=0
       return
    end if
    !
    do ii = nn/2, 1, -1
       call sort_pushdownr(ii, nn, mm,key1,eps,newnn,nn,ind)
    end do
    do ii = nn, 2, -1
       call sort_swap(ind(1), ind(ii))
       call sort_pushdownr(1, ii-1, mm,key1,eps,newnn,nn,ind)
    end do
    !
    if (uniq) then
       dmp=0
       newnn=1
       do ii=2,nn
          if (sort_cmpr(key1(ind(ii-1)),key1(ind(ii)),eps) /= 0) then
             ! Keep ind(ii)
             newnn = newnn+1
             ind(newnn) = ind(ii)
          else
             dmp=dmp+1
          end if
       end do
       if(sort_bdeb)write(*,*) "SORT_HEAPSORT dumped elements:",dmp
    else
       newnn=nn
    end if
    !
    !
  end subroutine sort_heapsort1r
  !
  subroutine sort_heapsort1i(mm,key1,newnn,nn,ind,uniq)
    !
    !! Generate sorted index for key1 
    !
    implicit none

    integer :: mm                ! Number of elements
    integer :: key1(mm)             ! key
    integer :: newnn             ! new number of keys
    integer :: nn                ! Number of elements
    integer :: ind(nn)           ! Resulting sorted index
    logical uniq               ! Ignore duplicate records
    !
    integer :: ii,dmp

    if (nn.eq.0) then
       newnn=0
       return
    end if
    !
    do ii = nn/2, 1, -1
       call sort_pushdowni(ii, nn, mm,key1,newnn,nn,ind)
    end do
    do ii = nn, 2, -1
       call sort_swap(ind(1), ind(ii))
       call sort_pushdowni(1, ii-1, mm,key1,newnn,nn,ind)
    end do
    !
    if (uniq) then
       dmp=0
       newnn=1
       do ii=2,nn
          if (sort_cmpi(key1(ind(ii-1)),key1(ind(ii))) /= 0) then
             ! Keep ind(ii)
             newnn = newnn+1
             ind(newnn) = ind(ii)
          else
             dmp=dmp+1
          end if
       end do
       if(sort_bdeb)write(*,*) "SORT_HEAPSORT dumped elements:",dmp
    else
       newnn=nn
    end if
    !
    !
  end subroutine sort_heapsort1i
  !
  subroutine sort_pushdownr(first, last,mm,key1,eps,newnn,nn,ind)
    !
    integer :: first
    integer :: last
    integer :: mm                ! Number of elements
    real :: key1(mm)             ! key
    real :: eps                  ! key tolerance (when are they equal)
    integer :: newnn             ! new number of keys
    integer :: nn                ! Number of elements
    integer :: ind(nn)           ! Resulting sorted index
    !
    integer :: r
    !
    r = first
    !
    MAINLOOP: do while (r <= last/2)
       if (last == 2*r) then
          if (sort_cmpr(key1(ind(r)),key1(ind( 2*r)),eps) > 0) then
             call sort_swap(ind(r), ind(2*r))
          end if
          exit MAINLOOP
       else
          if (sort_cmpr(key1(ind(r)),key1(ind(2*r)),eps) > 0 .and. &
               & sort_cmpr(key1(ind(2*r)),key1(ind(2*r+1)),eps) <= 0) then
             call sort_swap(ind(r), ind(2*r))
             r = 2*r
          else if (sort_cmpr(key1(ind(r)),key1(ind(2*r+1)),eps)>0 .and. &
               & sort_cmpr(key1(ind(2*r+1)),key1(ind(2*r)),eps)<0) then
             call sort_swap(ind(r), ind(2*r+1))
             r = 2*r+1
          else
             exit MAINLOOP
          end if
       end if
    end do MAINLOOP
    !
  end subroutine sort_pushdownr
  !
  subroutine sort_pushdowni(first, last,mm,key1,newnn,nn,ind)
    !
    integer :: first
    integer :: last
    integer :: mm                ! Number of elements
    integer :: key1(mm)          ! key
    integer :: newnn             ! new number of keys
    integer :: nn                ! Number of elements
    integer :: ind(nn)           ! Resulting sorted index
    !
    integer :: r
    !
    r = first
    !
    MAINLOOP: do while (r <= last/2)
       if (last == 2*r) then
          if (sort_cmpi(key1(ind(r)),key1(ind( 2*r))) > 0) then
             call sort_swap(ind(r), ind(2*r))
          end if
          exit MAINLOOP
       else
          if (sort_cmpi(key1(ind(r)),key1(ind(2*r))) > 0 .and. &
               & sort_cmpi(key1(ind(2*r)),key1(ind(2*r+1))) <= 0) then
             call sort_swap(ind(r), ind(2*r))
             r = 2*r
          else if (sort_cmpi(key1(ind(r)),key1(ind(2*r+1)))>0 .and. &
               & sort_cmpi(key1(ind(2*r+1)),key1(ind(2*r)))<0) then
             call sort_swap(ind(r), ind(2*r+1))
             r = 2*r+1
          else
             exit MAINLOOP
          end if
       end if
    end do MAINLOOP
    !
  end subroutine sort_pushdowni
  !
  !
  integer function sort_cmpr(a,b,eps)
    real :: a
    real :: b
    real :: eps
    if (abs(a-b) < eps) then
       sort_cmpr = 0
    else if (a < b) then
       sort_cmpr = 1
    else
       sort_cmpr = -1
    end if
  end function sort_cmpr
  !
  integer function sort_cmpi(a,b)
    integer :: a
    integer :: b
    if (a == b) then
       sort_cmpi = 0
    else if (a < b) then
       sort_cmpi = 1
    else
       sort_cmpi = -1
    end if
  end function sort_cmpi
  !
  !
  subroutine sort_swap(k1, k2)
    !
    implicit none
    !
    integer :: k1
    integer :: k2
    !
    integer :: tmp
    !
    tmp = k1
    k1 = k2
    k2 = tmp
    !
  end subroutine sort_swap
  !
  !
  ! E R R O R    R O U T I N E S
  !
  subroutine sort_errorappend(crc250,string)
    implicit none
    character*250 :: crc250
    character*(*) :: string
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    character*22 :: myname ="sort_errorappend"
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    lenb=len(trim(string))
    buff250=string(1:lenb)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//""//buff250(1:min(250-lenc-1,lenb))
    end if
  end subroutine sort_errorappend
  subroutine sort_errorappendi(crc250,inum)
    implicit none
    character*250 :: crc250
    integer :: inum
    character*250 :: buff250
    integer :: lenc, lenb
    integer, external :: length
    character*22 :: myname ="sort_errorappendi"
    call chop0(crc250,250)
    lenc=length(crc250,250,10)
    write(buff250,'(I12)')inum
    call chop0(buff250,250)
    lenb=length(buff250,250,1)
    if (lenc.eq.0) then
       crc250=buff250(1:lenb)
    else
       crc250=crc250(1:lenc)//""//buff250(1:min(250-lenc-1,lenb))
    end if
  end subroutine sort_errorappendi
end module sort
