.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "fark 3pm"
.TH fark 3pm "2018-01-20" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  fark.pm \- a perl library for colocating model and observation data from BUFR, GRIB and NetCDF files.
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use fark;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The fark perl library is a tool for colocating data from model files and 
observation files. The library accepts a list of model files and observation
files. Model data can be sorted using a index-variable specified by the user, and
the values of this variable is available when looping through the model files.
The observation files within a specified index period can be accessed in an
inner loop. For each observation file, the relevant observations can be retrieved.
Finally, the model fields can be sliced according to variable-match-rules.
.PP
By reducing the amount of data returned to the perl script, the user can dramatically
speed up the data processing. Processing data in perl typically takes 100\-fold
more time than processing the data in Fortran/C\-routines.
.SH "SESSION FUNCTIONS"
.IX Header "SESSION FUNCTIONS"
.SS "remote"
.IX Subsection "remote"
Run remote script.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
fark::remote(\*(L"dir.pl\*(R",\*(L"?ls='/usr/var'\*(R",\*(L"www\-data\*(R");
.SS "open"
.IX Subsection "open"
open \- creates a new fark session.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
my \f(CW$fark\fR = fark\->\fIopen()\fR;
.SS "close"
.IX Subsection "close"
close \- closes a fark session.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->\fIclose()\fR;
.SH "MODEL FUNCTIONS"
.IX Header "MODEL FUNCTIONS"
.SS "clearModelFileStack"
.IX Subsection "clearModelFileStack"
clearModelFileStack \- clears the model file stack and sets the sorting variable (optional).
.PP
Arguments:
.IP "(string) variable used for sorting the files (optional)." 4
.IX Item "(string) variable used for sorting the files (optional)."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->clearModelFileStack(\*(L"time\*(R");
.SS "pushModelFile"
.IX Subsection "pushModelFile"
pushModelFile \- adds model file to the model file stack.
.PP
Files pushed to the model file stack must be from the same model. An error is returned if the file type is unknown.
.PP
Arguments:
.IP "(string) ... paths to model netCDF files." 4
.IX Item "(string) ... paths to model netCDF files."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
my \f(CW@modelFiles\fR=/opdata/arome25/AROME_MetCoOp*.nc>;
\&\f(CW$fark\fR\->pushModelFile(@modelFiles);
.SS "peekModelFile"
.IX Subsection "peekModelFile"
peekModelFile \- returns dimension and variable data on the last model file on the model file stack,
along with the values of the sorting variable specified by \*(L"clearModelFileStack\*(R".
.PP
Return:
.IP "(hash) file structure" 4
.IX Item "(hash) file structure"
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
my \f(CW$peekdata\fR = \f(CW$fark\fR\->\fIpeekModelFile()\fR;
.SS "popModelFile"
.IX Subsection "popModelFile"
popModelFile \- removes (the last) model file from the model file stack.
.PP
Arguments:
.IP "(string) ... paths to model netCDF files (optional)." 4
.IX Item "(string) ... paths to model netCDF files (optional)."
.PP
Return:
.IP "(hash) file structure hash" 4
.IX Item "(hash) file structure hash"
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->\fIpopModelFile()\fR;
.SS "updateModelRegister"
.IX Subsection "updateModelRegister"
updateModelRegister \- automatically pushes \*(L"new\*(R" files to the stack, and pops \*(L"deleted\*(R" files, using a register-file and file-mask.
.PP
Arguments:
.IP "(string) path to register file (if missing, the register-file is created and no model-files are pushed to the stack)." 4
.IX Item "(string) path to register file (if missing, the register-file is created and no model-files are pushed to the stack)."
.PD 0
.IP "(string) file mask." 4
.IX Item "(string) file mask."
.IP "(string) minimum file age (in days)" 4
.IX Item "(string) minimum file age (in days)"
.IP "(string) maximum file age (in days)" 4
.IX Item "(string) maximum file age (in days)"
.IP "(int) test flag (1 or 0), 1= only check input" 4
.IX Item "(int) test flag (1 or 0), 1= only check input"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->updateModelRegister($xmlfile,$modregfile,\*(L"/opdata/arome/\*(R", \*(L".*\e.nc\*(R","\*(L",\*(R"",0);
.SS "makeModelCache"
.IX Subsection "makeModelCache"
makeModelCache \- makes a cache of the model-file-stack in the session.
.PP
Arguments:
.IP "(string) path to model cache file." 4
.IX Item "(string) path to model cache file."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->makeModelCache($modfile);
.SS "loadModelCache"
.IX Subsection "loadModelCache"
loadModelCache \- loads a cache of the model-file-stack created by \*(L"makeModelCache\*(R".
.PP
Arguments:
.IP "(string) path to model cache file (optional in repeated calls)." 4
.IX Item "(string) path to model cache file (optional in repeated calls)."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->loadModelCache($modfile);
.SS "setModelCache"
.IX Subsection "setModelCache"
setModelCache \- sets name of cache file.
.PP
Arguments:
.IP "(string) path to model cache file (optional in repeated calls)." 4
.IX Item "(string) path to model cache file (optional in repeated calls)."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->setModelCache($modfile);
.SS "setModelIndex"
.IX Subsection "setModelIndex"
setModelIndex \- sets a target for the model parameters
.PP
Arguments:
.IP "(string) modelTarget" 4
.IX Item "(string) modelTarget"
.PD 0
.IP "(string) modelVariable" 4
.IX Item "(string) modelVariable"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\& $fark\->setModelIndex("time_trg","time");
.Ve
.SS "setModelIndexLimits"
.IX Subsection "setModelIndexLimits"
setModelIndexLimits \- sets model index limits
.PP
Arguments:
.IP "(string) start index value" 4
.IX Item "(string) start index value"
.PD 0
.IP "(string) stop index value" 4
.IX Item "(string) stop index value"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\& $fark\->setModelSortLimits(0,1);
.Ve
.SS "clearModelTargetStack"
.IX Subsection "clearModelTargetStack"
clearModelTargetStack \-  clears the model target stack. If the model target is used, only models with valid targets are visible to the system.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->\fIclearModelTargetStack()\fR;
.SS "pushModelTarget"
.IX Subsection "pushModelTarget"
pushModelTarget \- defines an model target on the target stack
.PP
Arguments:
.IP "(string) name" 4
.IX Item "(string) name"
.PD 0
.IP "(string) variable" 4
.IX Item "(string) variable"
.IP "(real) min" 4
.IX Item "(real) min"
.IP "(real) max" 4
.IX Item "(real) max"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->pushModelTarget(\*(L"modeltime\*(R",\*(L"time\*(R","\*(L",\*(R"");
.SS "clearDefaultStack"
.IX Subsection "clearDefaultStack"
clearDefaultStack \-  clears the default stack. If the model default is used, only models with valid defaults are visible to the system.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->\fIclearDefaultStack()\fR;
.SS "addDefault"
.IX Subsection "addDefault"
addDefault \- defines model default target value (in the absence of observations).
.PP
Arguments:
.IP "(string) name" 4
.IX Item "(string) name"
.PD 0
.IP "(int) value" 4
.IX Item "(int) value"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->addDefault(\*(L"modeltime\*(R",\*(L"12220.0\*(R");
.SS "pushDefault"
.IX Subsection "pushDefault"
pushDefault \- pushes the \*(L"added\*(R" default values to the stack.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->\fIpushDefault()\fR;
.SH "OBSERVATION FUNCTIONS"
.IX Header "OBSERVATION FUNCTIONS"
.SS "setObservationTablePath"
.IX Subsection "setObservationTablePath"
setObservationTablePath \- defines the table path used to read the observation files.
.PP
Arguments:
.IP "(string) path to the BUFR-table directory." 4
.IX Item "(string) path to the BUFR-table directory."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->setObservationTablePath(\*(L"/usr/share/metno\-bufrtables/\*(R");
.SS "clearObservationFileStack"
.IX Subsection "clearObservationFileStack"
clearObservationFileStack \- clears the observation file stack.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->\fIclearObservationFileStack()\fR;
.SS "pushObservationFile"
.IX Subsection "pushObservationFile"
pushObservationFile \- adds observation file to the observation file stack.
.PP
Arguments:xs
.IP "(string) ... paths to observation files." 4
.IX Item "(string) ... paths to observation files."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 2
\&   my @obsFiles=/opdata/arome25/AROME_MetCoOp*.nc>;
\&   $fark\->pushObservationFile(@obsFiles);
.Ve
.SS "peekObservationFile"
.IX Subsection "peekObservationFile"
peekObservationFile \- returns dimension and variable data on the last observation file on the observation file stack.
along with the values of the sorting variable specified by \*(L"clearObservationFileStack\*(R".
.PP
Return:
.IP "(hash) file structure" 4
.IX Item "(hash) file structure"
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
my \f(CW$peekdata\fR = \f(CW$fark\fR\->\fIpeekObservationFile()\fR;
.SS "popObservationFile"
.IX Subsection "popObservationFile"
popObservationFile \- removes (the last) observation file from the observation file stack.
.PP
Arguments:
.IP "(string) ... paths to observation files (optional)." 4
.IX Item "(string) ... paths to observation files (optional)."
.PP
Return:
.IP "(hash) file structure hash" 4
.IX Item "(hash) file structure hash"
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->\fIpopObservationFile()\fR;
.SS "updateObservationRegister"
.IX Subsection "updateObservationRegister"
updateObservationRegister \- automatically pushes \*(L"new\*(R" files to the stack, and pops \*(L"deleted\*(R" files, using a register-file and file-mask.
.PP
Arguments:
.IP "(string) path to register file (if missing, the register-file is created and no observation-files are pushed to the stack)." 4
.IX Item "(string) path to register file (if missing, the register-file is created and no observation-files are pushed to the stack)."
.PD 0
.IP "(string) file mask." 4
.IX Item "(string) file mask."
.IP "(string) minimum file age (in days)" 4
.IX Item "(string) minimum file age (in days)"
.IP "(string) maximum file age (in days)" 4
.IX Item "(string) maximum file age (in days)"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->updateObservationRegister($obsregfile,\*(L"/opdata/obs_dec/rdb/temp/temp_*06*.bufr\*(R","\*(L",\*(R"",0);
.SS "makeObservationCache"
.IX Subsection "makeObservationCache"
makeObservationCache \- makes a cache of the observation-file-stacks in the session.
.PP
Arguments:
.IP "(string) path to obs cache file." 4
.IX Item "(string) path to obs cache file."
.PD 0
.IP "(int) test flag (1 or 0), 1= only check input" 4
.IX Item "(int) test flag (1 or 0), 1= only check input"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->makeObservationCache($obsfile);
.SS "loadObservationCache"
.IX Subsection "loadObservationCache"
loadObservationCache \- loads a cache of the observation-file-stack created by \*(L"makeObservationCache\*(R".
.PP
Arguments:
.IP "(string) path to obs cache file (optional in repeated calls)." 4
.IX Item "(string) path to obs cache file (optional in repeated calls)."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->loadObservationCache($obsfile);
.SS "setObservationCache"
.IX Subsection "setObservationCache"
setObservationCache \- sets name of cache file.
.PP
Arguments:
.IP "(string) path to obs cache file (optional in repeated calls)." 4
.IX Item "(string) path to obs cache file (optional in repeated calls)."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->setObservationCache($obsfile);
.SS "setObservationType"
.IX Subsection "setObservationType"
setObservationType \- sets the type of \s-1BUFR\s0 files that should be processed
.PP
Arguments:
.IP "(integer) bufrType" 4
.IX Item "(integer) bufrType"
.PD 0
.IP "(integer) subType" 4
.IX Item "(integer) subType"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\& $fark\->setObservationType(4,143);
.Ve
.SS "setObservationIndexLimits"
.IX Subsection "setObservationIndexLimits"
setObservationIndexLimits \-  sets the first and last dates to consider in the processing of observation files and their observations. Call without arguments to clear the index limits.
.PP
Arguments:
.IP "(string) start value of index expression" 4
.IX Item "(string) start value of index expression"
.PD 0
.IP "(string) stop value of index expression" 4
.IX Item "(string) stop value of index expression"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->setObservationIndexLimits(10,100);
\&\f(CW$fark\fR\->\fIsetObservationIndexLimits()\fR;
.SS "clearObservationTargetStack"
.IX Subsection "clearObservationTargetStack"
clearObservationTargetStack \-  clears the observation target stack. If the observation target is used, only observations with valid targets are visible to the system.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->\fIclearObservationTargetStack()\fR;
.SS "pushObservationTarget"
.IX Subsection "pushObservationTarget"
pushObservationTarget \- defines an observation target on the target stack
.PP
Arguments:
.IP "(string) name" 4
.IX Item "(string) name"
.PD 0
.IP "(int) pos" 4
.IX Item "(int) pos"
.IP "(int) descr" 4
.IX Item "(int) descr"
.IP "(string) info" 4
.IX Item "(string) info"
.IP "(real) min" 4
.IX Item "(real) min"
.IP "(real) max" 4
.IX Item "(real) max"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->pushObservationTarget(\*(L"yy\*(R",\*(L"10\*(R",\*(L"4001\*(R",\*(L"year\*(R","\*(L",\*(R"");
.SS "setObservationIndex"
.IX Subsection "setObservationIndex"
setObservationIndex \- set the observation index (used for sorting the stack).
.PP
Arguments:
.IP "(string) target name" 4
.IX Item "(string) target name"
.PD 0
.IP "(string) expression" 4
.IX Item "(string) expression"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->setObservationIndex(\*(L"time\*(R",\*(L"dtg(yy,mm,dd,hh,mi)\*(R");
.SS "clearMatchRuleStack"
.IX Subsection "clearMatchRuleStack"
clearMatchRuleStack \- clear match-rule expressions.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\& $fark\->clearMatchRuleStack();
.Ve
.SS "pushMatchRule"
.IX Subsection "pushMatchRule"
pushMatchRule \- add a match-rule to the stack
.PP
Arguments:
.IP "(string) model targetName" 4
.IX Item "(string) model targetName"
.PD 0
.IP "(string) obs expression" 4
.IX Item "(string) obs expression"
.IP "(string) min" 4
.IX Item "(string) min"
.IP "(string) max" 4
.IX Item "(string) max"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\& $fark\->pushMatchRule("latitude_model","180.0*latitude_obs/3.14",0,90.0);
.Ve
.SS "makeMatchList"
.IX Subsection "makeMatchList"
makeMatchList \- make match list from match stack
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\& $fark\->makeMatchList();
.Ve
.SS "setModelFilter"
.IX Subsection "setModelFilter"
setModelFilter \- add a model filter.
.PP
Arguments:
.IP "(string) model filter (can contain observation targets)." 4
.IX Item "(string) model filter (can contain observation targets)."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\& $fark\->setModelFilter("member(obs_id,1047,1049)");
.Ve
.SS "setObservationFilter"
.IX Subsection "setObservationFilter"
setObservationFilter \- sets the type of \s-1BUFR\s0 files that should be processed
.PP
Arguments:
.IP "(string) observation filter" 4
.IX Item "(string) observation filter"
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\& $fark\->setObservationFilter("member(obs_id,1,2,3)");
.Ve
.SS "makeColocXML"
.IX Subsection "makeColocXML"
makeColocXML \- make \s-1XML\s0 file...
.PP
Arguments:
.IP "(string) Path to \s-1XML\s0 file (with wildcards \s-1YYYY,MM,DD,HH,MI,SS\s0 for timestamp)" 4
.IX Item "(string) Path to XML file (with wildcards YYYY,MM,DD,HH,MI,SS for timestamp)"
.PD 0
.IP "(int) test flag (1 or 0), 1= only check input" 4
.IX Item "(int) test flag (1 or 0), 1= only check input"
.PD
.PP
my \f(CW$xmlFile\fR = \f(CW$fark\fR\->makeColocXML($xmlPattern);
.SH "PLOT FUNCTIONS"
.IX Header "PLOT FUNCTIONS"
.SS "setPlotType"
.IX Subsection "setPlotType"
setPlotType \- defines the type of output files.
.PP
Arguments:
.ie n .IP "(string) name of the type, e.g. ""rms+stdv"", ""scatter"", ""skill"", ""text""" 4
.el .IP "(string) name of the type, e.g. ``rms+stdv'', ``scatter'', ``skill'', ``text''" 4
.IX Item "(string) name of the type, e.g. rms+stdv, scatter, skill, text"
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->setPlotType(\*(L"rms+stdv\*(R");
.SS "setPlotTableFile"
.IX Subsection "setPlotTableFile"
setPlotTableFile \- sets the tableFile.
.PP
Arguments:
.IP "(string) name of table file." 4
.IX Item "(string) name of table file."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->setPlotTableFile(\*(L"rms+stdv\*(R");
.SS "getPlotTableFile"
.IX Subsection "getPlotTableFile"
getPlotTableFile \- gets the tableFile.
.PP
Arguments:
.IP "(string) name of table file." 4
.IX Item "(string) name of table file."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->getPlotTableFile(\*(L"rms+stdv\*(R");
.SS "setPlotGraphicsFile"
.IX Subsection "setPlotGraphicsFile"
setPlotGraphicsFile \- sets the graphicsFile.
.PP
Arguments:
.IP "(string) name of graphics file." 4
.IX Item "(string) name of graphics file."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->setPlotGraphicsFile(\*(L"rms+stdv\*(R");
.SS "getPlotGraphicsFile"
.IX Subsection "getPlotGraphicsFile"
getPlotGraphicsFile \- gets the graphicsFile.
.PP
Arguments:
.IP "(string) name of graphics file." 4
.IX Item "(string) name of graphics file."
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->getPlotGraphicsFile(\*(L"rms+stdv\*(R");
.SS "clearPlotSetStack"
.IX Subsection "clearPlotSetStack"
clearPlotSetStack \- clears the datasets in the plot set stack.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->\fIclearPlotSetStack()\fR;
.SS "clearPlotColumn"
.IX Subsection "clearPlotColumn"
clearPlotColumn \- clears all output columns from the set.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\&   $fark\->clearPlotColumn();
.Ve
.SS "pushPlotColumn"
.IX Subsection "pushPlotColumn"
pushPlotColumn \- adds a column expression to the set.
.PP
Arguments:xs
.IP "(string) column name" 4
.IX Item "(string) column name"
.PD 0
.IP "(string) column value expression" 4
.IX Item "(string) column value expression"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\&   $fark\->pushPlotColumn("X\-value","temperature_2m");
.Ve
.SS "pushPlotSet"
.IX Subsection "pushPlotSet"
pushPlotSet \- adds a data set to the plot set stack.
.PP
Arguments:xs
.IP "(string) plot session id" 4
.IX Item "(string) plot session id"
.PD 0
.IP "(string) colocation session id" 4
.IX Item "(string) colocation session id"
.IP "(string) model session id" 4
.IX Item "(string) model session id"
.IP "(string) observation session id" 4
.IX Item "(string) observation session id"
.IP "(string) name of set" 4
.IX Item "(string) name of set"
.IP "(string) legend" 4
.IX Item "(string) legend"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\&   $fark\->pushPlotSet("1","time","temperature_2m","Arome (T2M)");
.Ve
.SS "clearPlotAttributeStack"
.IX Subsection "clearPlotAttributeStack"
clearPlotAttributeStack \- clears the plot attribute stack.
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
\&\f(CW$fark\fR\->clearPlotAttributeStack;
.SS "pushPlotAttribute"
.IX Subsection "pushPlotAttribute"
pushPlotAttribute \- adds an attribute.
.PP
Arguments:xs
.IP "(string) name of attribute" 4
.IX Item "(string) name of attribute"
.PD 0
.IP "(string) attribute value." 4
.IX Item "(string) attribute value."
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 1
\&   $fark\->pushPlotAttribute("title","Temperature \- Tryvann");
.Ve
.SS "makePlotTable"
.IX Subsection "makePlotTable"
makePlotTable \- make table file, return name of plot graphics file...
.PP
Arguments:
.IP "(string) Path to table file (with wildcards \s-1YYYY,MM,DD,HH,MI,SS\s0 for timestamp)" 4
.IX Item "(string) Path to table file (with wildcards YYYY,MM,DD,HH,MI,SS for timestamp)"
.PD 0
.IP "(string) Path to plot file (with wildcards \s-1YYYY,MM,DD,HH,MI,SS\s0 for timestamp)" 4
.IX Item "(string) Path to plot file (with wildcards YYYY,MM,DD,HH,MI,SS for timestamp)"
.IP "(string) Path to Rscript file" 4
.IX Item "(string) Path to Rscript file"
.IP "(int) test flag (1 or 0), 1= only check input" 4
.IX Item "(int) test flag (1 or 0), 1= only check input"
.PD
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
my ($tablefile,$plotfile) = \f(CW$fark\fR\->makePlotTable($tablepattern,$plotpattern,$catfile,0);
.SS "expression"
.IX Subsection "expression"
expression \- evaluate expression
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
my \f(CW$result\fR = fark\->expression('1+2');
.SS "debug"
.IX Subsection "debug"
debug \- set debug flag.
.PP
Arguments:xs
.IP "(int) 1=debug on, 0=debug off" 4
.IX Item "(int) 1=debug on, 0=debug off"
.PP
\s-1EXAMPLE\s0
.IX Subsection "EXAMPLE"
.PP
.Vb 3
\&   fark::debug(1);
\&   ...
\&   fark::debug(0);
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
# fark-perl installation:   
 sudo dpkg \-\-install /vol/fou/atmos2/franktt/fark/fark\-perl_0.13\-1_amd64.deb
.PP
# run test-script
 /vol/fou/atmos2/franktt/fark/farkmod.pl
 /vol/fou/atmos2/franktt/fark/farkobs.pl
.PP
# manual
 man fark
 man farkdata
.PP
# remove package
 sudo dpkg \-\-remove fark-perl
.SH "AUTHOR"
.IX Header "AUTHOR"
Frank Thomas Tveter, <f.t.tveter@met.no>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 4
\& NETCDF
\& BUFR
\& ncdump \-h
\& ncview
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1321:" 4
.IX Item "Around line 1321:"
=back doesn't take any parameters, but you said =back  =head4 \s-1EXAMPLE\s0
